head	1.8;
access;
symbols;
locks; strict;
comment	@ * @;


1.8
date	2006.04.24.13.05.41;	author lewis;	state Exp;
branches;
next	1.7;

1.7
date	2006.04.24.12.45.05;	author lewis;	state Exp;
branches;
next	1.6;

1.6
date	2006.04.21.15.58.22;	author lewis;	state Exp;
branches;
next	1.5;

1.5
date	2006.04.21.08.59.52;	author lewis;	state Exp;
branches;
next	1.4;

1.4
date	2006.04.21.07.39.51;	author lewis;	state Exp;
branches;
next	1.3;

1.3
date	2006.04.20.17.35.06;	author lewis;	state Exp;
branches;
next	1.2;

1.2
date	2006.04.20.16.47.22;	author lewis;	state Exp;
branches;
next	1.1;

1.1
date	2006.04.18.16.45.14;	author lewis;	state Exp;
branches;
next	;


desc
@@


1.8
log
@*** empty log message ***
@
text
@/* ============================================================= */
/* Send packets to a Socket                                      */
/* Julian Lewis AB/CO/HT 23rd Feb 2006 Julian.Lewis@@CERN.ch      */
/* For Email the Subject line should contain the string "nospam" */
/* ============================================================= */

#include <stdarg.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <netdb.h>
#include <sys/time.h>
#include <errno.h>
#include <strings.h>
#include <string.h>
#include <time.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#include <err/err.h>      /* Error handling */
#include <tgv/tgv.h>

#include <TimLib.h>
#include <SendSocket.h>

static int ssock     = 0;
static int connected = 0;
static int seqnum    = 0;
static int errors    = 0;
static int debug     = 0;
static int qflag     = 0;
static int tmout     = 20000;
static int domain    = PF_UNIX;

char *options[OPTIONS] = {"-p","-t","-inet","-eC","-eP","-d"};

/* ============================================================= */
/* Open a UDP port for SendSocket data                           */
/* ============================================================= */

int OpenPort(unsigned short port) {

struct sockaddr_un snm;
struct sockaddr_in sin;

int s, size;
char   fnam[FILE_NAME_SIZE];

   if (!ssock) {

      s = socket(domain, SOCK_DGRAM, 0);
      if (s < 0) {
	 fprintf(stderr,"SendSocket:OpenPort:Error:Cant open sockets\n");
	 perror("SendSocket:OpenPort:errno");
	 return FAIL;
      }
      ssock = s;

      if (domain == PF_INET) {
	 bzero((void *) &sin, SinSIZE);
	 sin.sin_family = domain;
	 sin.sin_port = htons(port);
	 sin.sin_addr.s_addr = htonl(INADDR_ANY);
	 if (bind(s,(struct sockaddr *) &sin, SinSIZE) < 0) {
	    fprintf(stderr,"SendSocket:OpenPort:Error:Cant bind port:%d\n",port);
	    perror("SendSocket:OpenPort:errno");
	    close(s);
	    ssock = 0;
	    return FAIL;
	 }
      } else {
	 sprintf(fnam,"/tmp/SktSnd%d",(int) port);
	 unlink(fnam);
	 snm.sun_family = PF_LOCAL;
	 strncpy(snm.sun_path, fnam, sizeof (snm.sun_path));
	 size = SUN_LEN(&snm);
	 if (bind(ssock,(struct sockaddr *) &snm,size) < 0) {
	    fprintf(stderr,"SendSocket:OpenPort:Error:Cant bind port:%d\n",port);
	    perror("SendSocket:OpenPort:errno");
	    close(ssock);
	    ssock = 0;
	    return FAIL;
	 }
      }
   }
   return ssock;
}

/* ============================================================= */
/* Get Configuration data for tim lib                            */
/* ============================================================= */

char *defaultconfigpath = "/dsc/bin/tim/timtest.config";

char *configpath = NULL;
char localconfigpath[128];  /* After a CD */

static char path[128];

/* ============================================================= */

char *GetFile(char *name) {
FILE *gpath = NULL;
char txt[128];
int i, j;

   if (configpath) {
      gpath = fopen(configpath,"r");
      if (gpath == NULL) {
	 configpath = NULL;
      }
   }

   if (configpath == NULL) {
      configpath = "./timtest.config";
      gpath = fopen(configpath,"r");
      if (gpath == NULL) {
	 configpath = "/dsc/local/data/timtest.config";
	 gpath = fopen(configpath,"r");
	 if (gpath == NULL) {
	    configpath = defaultconfigpath;
	    gpath = fopen(configpath,"r");
	    if (gpath == NULL) {
	       configpath = NULL;
	       sprintf(path,"./%s",name);
	       return path;
	    }
	 }
      }
   }

   bzero((void *) path,128);

   while (1) {
      if (fgets(txt,128,gpath) == NULL) break;
      if (strncmp(name,txt,strlen(name)) == 0) {
	 for (i=strlen(name); i<strlen(txt); i++) {
	    if (txt[i] != ' ') break;
	 }
	 j= 0;
	 while ((txt[i] != ' ') && (txt[i] != 0)) {
	    path[j] = txt[i];
	    j++; i++;
	 }
	 strcat(path,name);
	 fclose(gpath);
	 return path;
      }
   }
   fclose(gpath);
   return NULL;
}

/* ============================================================= */
/* Convert a TimLib time in milliseconds to a string routine.    */
/* Result is a pointer to a static string representing the time. */
/*    the format is: Thu-18/Jan/2001 08:25:14.967                */
/*                   day-dd/mon/yyyy hh:mm:ss.ddd                */
/* ============================================================= */

volatile char *TimeToStr(TimLibTime *t) {

static char tbuf[128];

char tmp[128];
char *yr, *ti, *md, *mn, *dy;

   bzero((void *) tbuf, 128);
   bzero((void *) tmp, 128);

   if (t->Second) {
      ctime_r(&t->Second, tmp);
      tmp[3] = 0;
      dy = &(tmp[0]);
      tmp[7] = 0;
      mn = &(tmp[4]);
      tmp[10] = 0;
      md = &(tmp[8]);
      if (md[0] == ' ') md[0] = '0';
      tmp[19] = 0;
      ti = &(tmp[11]);
      tmp[24] = 0;
      yr = &(tmp[20]);
      sprintf (tbuf, "%s-%s/%s/%s %s"  , dy, md, mn, yr, ti);
      if (t->Nano) {
      	  sprintf(&tbuf[strlen(tbuf)],".%09lu",t->Nano);
      }

   } else sprintf (tbuf, "--- Zero ---");

   
   if ((t->Machine != TgmMACHINE_NONE) && (t->CTrain > 0)) {
      strcat(tbuf," ");
      strcat(tbuf,TgmGetMachineName(t->Machine));
      strcat(tbuf," C:");
      sprintf(tmp,"%d",(int) t->CTrain);
      strcat(tbuf,tmp);
   }
   return (tbuf);
}

/* ============================================================= */
/* Convert an Ltim to its name                                    */
/* ============================================================= */

PtmNames ptm_names[128];
static char ptm_name_txt[128];
int ptm_names_size = 0;

/* ============================================================= */

char *GetPtmName(unsigned long eqp) {

char *cp, *ep;
int i;
FILE *inp;

   if (ptm_names_size == 0) {
      GetFile("ltim.obnames");
      inp = fopen(path,"r");
      if (inp) {
	 while (fgets(ptm_name_txt,128,inp) != NULL) {
	    cp = ep = ptm_name_txt;
	    ptm_names[ptm_names_size].Eqp = strtoul(cp,&ep,0);
	    if (cp == ep) continue;
	    for (i=strlen(ep); i>=0; i--) {
	       if (ep[i] == '\n') {
		  ep[i] = 0;
		  break;
	       }
	    }
	    strcpy(ptm_names[ptm_names_size++].Name,++ep);
	    if (ptm_names_size >= 128) break;
	 }
	 fclose(inp);
      }
   }

   for (i=0; i<ptm_names_size; i++) {
      if (ptm_names[i].Eqp == eqp) {
	 sprintf(ptm_name_txt,"%04d:%s",(int) eqp,ptm_names[i].Name);
	 return ptm_name_txt;
      }
   }

   sprintf(ptm_name_txt,"%04d",(int) eqp);
   return ptm_name_txt;
}

/* ============================================================= */
/* Convert a packet to a string                                  */
/* ============================================================= */

char *PacketToStr(AcqPacket *pkt) {

TgvName tname;
char *evn;
char *cln;

static char spkt[PACKET_STRING_SIZE];

   evn = cln = "?";

   if (pkt->Class == TimLibClassPTIM) {
      evn = GetPtmName(pkt->Equipment);
      cln = "PTIM";
   }

   if (pkt->Class == TimLibClassCTIM) {
      TgvGetNameForMember(pkt->Equipment,&tname);
      evn = (char *) tname;
      cln = "CTIM";
   }

   bzero((void *) spkt, PACKET_STRING_SIZE);

   sprintf(spkt,"eventName      :%s\n"
		"eventId        :%d\n"
		"eventClass     :%s\n"
		"oCounter       :%d\n"
		"acqC           :%d\n"
		"acqUTC         :%d\n"
		"acqNano        :%d\n"
		"cycleUTC       :%d\n"
		"cycleNano      :%d\n"
		"eventPayload   :0x%04X (%d)\n"
		"cycleUserName  :%s\n"
		"acqTimeString  :%s\n"
		"cycleTimeString:%s\n",
		      evn,
		(int) pkt->Equipment,
		      cln,
		(int) pkt->SequenceNumber,
		(int) pkt->Acquisition.CTrain,
		(int) pkt->Acquisition.Second,
		(int) pkt->Acquisition.Nano,
		(int) pkt->StartCycle.Second,
		(int) pkt->StartCycle.Nano,
		(int) pkt->Payload,
		(int) pkt->Payload,
		      pkt->CycleName,
		TimeToStr(&(pkt->Acquisition)),
		TimeToStr(&(pkt->StartCycle)));

   if (debug) printf("\n%s\n",spkt);

   return spkt;
}

/* ============================================================= */
/* Send packet to a port via UDP                                 */
/* ============================================================= */

int SendToPort(char *target_ip, unsigned short target_port, AcqPacket *pkt) {

int  cc, size;
char *cp;
char fnam[FILE_NAME_SIZE];

struct sockaddr_un snm;
struct sockaddr_in sin;

   if (ssock) {

      cp = PacketToStr(pkt);

      if (domain == PF_INET) {
	 bzero((void *) &sin, SinSIZE);
	 sin.sin_family = domain;
	 sin.sin_port = htons(target_port);
	 sin.sin_addr.s_addr = inet_addr(target_ip);
	 cc = sendto(ssock,
		     (char *) cp,
		     PACKET_STRING_SIZE,
		     0,
		     (struct sockaddr *) &sin,
		     SinSIZE);
      } else {
	 sprintf(fnam,"/tmp/SktRcv%d",(int) target_port);
	 snm.sun_family = PF_LOCAL;
	 strncpy (snm.sun_path, fnam, sizeof (snm.sun_path));
	 size = SUN_LEN(&snm);
	 cc = sendto(ssock,
		     (char *) cp,
		     strlen(cp),
		     0,
		     (struct sockaddr *) &snm,
		     size);
      }
      if (cc < 0) {
	 fprintf(stderr,
		"SendSocket:SendToPort:Error:Cant sendto port:%d at:%s\n",
		 target_port,
		 target_ip);
	 perror("SendSocket:SendToPort:errno");
	 return FAIL;
      }
      if (debug) printf("SendSocket:SendToPort:Debug:Sent:%d packets\n",(int) pkt->SequenceNumber);
      return OK;
   }
   return FAIL;
}

/* ============================================================= */
/* Connect to a CTIM equipment                                   */
/* ============================================================= */

int ConnectToCtim(unsigned long ctim) {

TimLibError err;

   err = TimLibInitialize(TimLibDevice_ANY);
   if (err != TimLibErrorSUCCESS) {
      fprintf(stderr,"SendSocket:Error:%s\n",TimLibErrorToString(err));
      if (err == TimLibErrorIO) perror("SendSocket:TimLib:errno");
      return FAIL;
   }

   err = TimLibQueue(qflag,tmout);
   if (err != TimLibErrorSUCCESS) {
      fprintf(stderr,"SendSocket:Error:%s\n",TimLibErrorToString(err));
      if (err == TimLibErrorIO) perror("SendSocket:TimLib:errno");
      return FAIL;
   }

   err = TimLibConnect(TimLibClassCTIM,ctim,0);
   if (err != TimLibErrorSUCCESS) {
      fprintf(stderr,"SendSocket:Error:%s\n",TimLibErrorToString(err));
      if (err == TimLibErrorIO) perror("SendSocket:TimLib:errno");
      return FAIL;
   }
   connected++;
   return connected;
}

/* ============================================================= */
/* Connect to a PTIM = Ltim equipment                            */
/* ============================================================= */

int ConnectToPtim(unsigned long ptim) {

TimLibError err;

   err = TimLibInitialize(TimLibDevice_ANY);
   if (err != TimLibErrorSUCCESS) {
      fprintf(stderr,"SendSocket:Error:%s\n",TimLibErrorToString(err));
      if (err == TimLibErrorIO) perror("SendSocket:TimLib:errno");
      return FAIL;
   }

   err = TimLibQueue(qflag,tmout);
   if (err != TimLibErrorSUCCESS) {
      fprintf(stderr,"SendSocket:Error:%s\n",TimLibErrorToString(err));
      if (err == TimLibErrorIO) perror("SendSocket:TimLib:errno");
      return FAIL;
   }

   err = TimLibConnect(TimLibClassPTIM,ptim,0);
   if (err != TimLibErrorSUCCESS) {
      fprintf(stderr,"SendSocket:Error:%s\n",TimLibErrorToString(err));
      if (err == TimLibErrorIO) perror("SendSocket:TimLib:errno");
      return FAIL;
   }
   connected++;
   return connected;
}

/* ============================================================= */
/* Wait for a connected interrupt                                */
/* ============================================================= */

int WaitForConnection(AcqPacket *pkt) {

char          *cp, txt[32];
TimLibError   err;
TimLibClass   iclss;
TimLibTime    trigger;
TimLibTime    output;
TimLibTime    cstamp;
unsigned long payload, equp;

   if (connected) {
      err = TimLibWait(&iclss,    /* Class of interrupt */
		       &equp,     /* PTIM CTIM or hardware mask */
		       NULL,      /* Ptim line number 1..n or 0 */
		       NULL,      /* Hardware source of interrupt */
		       &output,   /* Time of interrupt/output */
		       &trigger,  /* Time of counters load */
		       NULL,      /* Time of counters start */
		       NULL,      /* CTIM trigger equipment ID */
		       &payload,  /* Payload of trigger event */
		       NULL,      /* Module that interrupted */
		       NULL,      /* Number of missed interrupts */
		       NULL,      /* Remaining interrupts on queue */
		       NULL);     /* Corresponding TgmMachine */

      if (err != TimLibErrorSUCCESS) {
	 fprintf(stderr,"SendSocket:Error:%s\n",TimLibErrorToString(err));
	 if (err == TimLibErrorIO) perror("SendSocket:TimLib:errno");
	 return FAIL;
      }

      pkt->SequenceNumber = seqnum++;
      pkt->Equipment = equp;
      pkt->Class     = iclss;

      err = TimLibGetTgmInfo(trigger,&cstamp,NULL,NULL);
      if (err != TimLibErrorSUCCESS) {
	 fprintf(stderr,"SendSocket:Error:%s\n",TimLibErrorToString(err));
	 if (err == TimLibErrorIO) perror("SendSocket:TimLib:errno");
	 return FAIL;
      }
      bcopy((void *) &cstamp,  (void *) &(pkt->StartCycle), sizeof(TimLibTime));

      if (iclss == TimLibClassCTIM) {
	 bcopy((void *) &trigger, (void *) &(pkt->Acquisition),sizeof(TimLibTime));
      } else {
	 bcopy((void *) &output, (void *) &(pkt->Acquisition),sizeof(TimLibTime));
      }

      pkt->Payload = payload;
      if ((payload>0) && (payload<=24)) cp = (char *) TgmGetLineName(TgmSPS,"USER",payload);
      else {
	 sprintf(txt,"0x%04X (Legacy)",(int) payload);
	 cp = txt;
      }
      if (cp) {
	 strcpy(pkt->CycleName,cp);
	 if (cp != txt) free(cp);
      } else pkt->CycleName[0] = 0;

      return OK;
   }
   return FAIL;
}

/* ============================================================= */
/* Errlog handler                                                */
/* ============================================================= */

static Boolean error_handler(class,text)
ErrClass class;
char *text; {

   errors++;
   fprintf(stderr,"SendSocket:Errors:%d %s\n",errors,text);
   return(False);
}

/* ============================================================= */
/* Main: Proccess arguments and send events for ever             */
/* ============================================================= */

int main(int argc,char *argv[]) {

char           target[TARGET_IP_NAME_SIZE];
unsigned short port;

int           events;
unsigned long event [MAX_EVENTS];
TimLibClass   tclass[MAX_EVENTS];

TgvName   tname;
AcqPacket pkt;
int       i;
char      *cp,
	  *ep;

   if (argc <= 1) {
      printf("SendSocket: Parameters are ...\n\n"
	     "   -p  <PORT>        ;Sets the target host port number\n"
	     "   -t  <IP ADDRESS>  ;Sets the target host IP address\n"
	     "   -eC <CTIM NUMBER> ;Set a CTIM event (OEX_EN_CT=988 OEX_WE_CT=987)\n"
	     "   -eP <PTIM NUMBER  ;Set a PTIM/LTIM equipment (on this host)>\n"
	     "   -d                ;Set Debug printing on\n"
	     "   -inet             ;Use INET domain for remote host\n"
	    );
      exit(1);
   }

   /* Set up defaults */

   port = 1234;
   strcpy(target,"127.0.0.1");

   events=0;
   bzero((void *) event,  MAX_EVENTS * sizeof(unsigned long));
   bzero((void *) tclass, MAX_EVENTS * sizeof(unsigned long));
   bzero((void *) &pkt, sizeof(AcqPacket));

   /* Process command line arguments */

   for (i=1; i<argc; i++) {

      cp = NULL;

      if (strncmp(argv[i],options[PORT],strlen(options[PORT])) == 0) {
	 i++;
	 cp = argv[i];
	 if (cp) port = (unsigned short) strtoul(cp,&ep,0);
	 continue;
      }

      if (strncmp(argv[i],options[TARGET],strlen(options[TARGET])) == 0) {
	 i++;
	 cp = argv[i];
	 if (cp) {
	    strcpy(target,cp);
	 }
	 continue;
      }

      if (strncmp(argv[i],options[DOMAIN],strlen(options[DOMAIN])) == 0) {
	 domain = PF_INET;
	 continue;
      }

      if (strncmp(argv[i],options[CTIM],strlen(options[CTIM])) == 0) {
	 i++;
	 cp = argv[i];
	 if (cp) {
	    tclass[events  ] = TimLibClassCTIM;
	    event [events++] = strtoul(cp,&ep,0);
	 }
	 continue;
      }

      if (strncmp(argv[i],options[PTIM],strlen(options[PTIM])) == 0) {
	 i++;
	 cp = argv[i];
	 if (cp) {
	    tclass[events  ] = TimLibClassPTIM;
	    event [events++] = strtoul(cp,&ep,0);
	 }
	 continue;
      }

      if (strncmp(argv[i],options[DEBUG],strlen(options[DEBUG])) == 0) {
	 debug = 1;
	 continue;
      }

      printf("SendSocket: No such option: %s\n",argv[i]);
      exit(1);
   }

   if (events) {
      fprintf(stderr,
	     "SendSocket: Sartup: Port:%d Target:%s ",
	      port,
	      target);

      for (i=0; i<events; i++) {
	 if (tclass[i] == TimLibClassPTIM) {
	    cp = GetPtmName(event[i]);
	    if (cp) fprintf(stderr,"PTIM:%s(%d) ",cp,(int) event[i]);
	    else {
	       fprintf(stderr,"\nSendSocket: No such PTIM:%d\n",(int) event[i]);
	       exit(1);
	    }
	 } else {
	    if (TgvGetNameForMember(event[i],&tname)) cp = (char *) tname;
	    if (cp) fprintf(stderr,"CTIM:%s(%d) ",cp,(int) event[i]);
	    else {
	       fprintf(stderr,"\nSendSocket: No such CTIM:%d\n",(int) event[i]);
	       exit(1);
	    }
	 }
      }

      if (domain == PF_INET) fprintf(stderr,"Using:PF_INET (Remote Host)\n");
      else                   fprintf(stderr,"Using:PF_LOCAL (Local Host)\n");

   } else {
      fprintf(stderr,"SendSocket: No events specified, FATAL, exit\n");
      exit(1);
   }

   ErrSetHandler((ErrHandler) error_handler);

   if (OpenPort(port)) {
      for (i=0; i<events; i++) {
	 if (tclass[i] == TimLibClassPTIM) {
	    if (ConnectToPtim(event[i]) == FAIL) {
	       fprintf(stderr,"SendSocket: Can't connect to PTIM:%d\n",(int) event[i]);
	       close(ssock);
	       exit(1);
	    }
	 } else {
	    if (ConnectToCtim(event[i]) == FAIL) {
	       fprintf(stderr,"SendSocket: Can't connect to CTIM:%d\n",(int) event[i]);
	       close(ssock);
	       exit(1);
	    }
	 }
      }
      fprintf(stderr,"SendSocket: Up and Running OK\n");

      while (errors < MAX_ERRORS) {

	 if (WaitForConnection(&pkt)) {
	    if (!SendToPort(target,port,&pkt)) { sleep(1); errors++; }
	 } else { sleep(1); errors++; }
      }
   } else errors++;

   fprintf(stderr,"SendSocket: ABORTED, after ErrorCount:%d\n",errors);
   close(ssock);
   exit(1);
}
@


1.7
log
@*** empty log message ***
@
text
@d282 1
a282 1
		"className      :%s\n"
@


1.6
log
@Yipee !!!
@
text
@d38 1
a38 1
char *options[OPTIONS] = {"-p","-t","-eC","-eP","-d"};
d70 1
a70 1
	    close(ssock);
d282 1
a282 1
		"ClassName      :%s\n"
a327 6
      bzero((void *) &sin, SinSIZE);

      sin.sin_family      = domain;
      sin.sin_port        = htons(target_port);
      sin.sin_addr.s_addr = inet_addr(target_ip);

d334 1
a334 1
	 sin.sin_addr.s_addr = htonl(INADDR_ANY);
d337 1
a337 1
		     strlen(cp),
d539 1
a539 1
	     "SendSocket: Warning the -t parameter sets up for a REMOTE host\n"
a571 1
	    domain = PF_INET;
d576 5
@


1.5
log
@*** empty log message ***
@
text
@d19 1
d36 1
a36 1
static int domain    = AF_LOCAL;
d46 1
d49 2
a50 1
int s;
a53 6
      bzero((void *) &sin, SinSIZE);

      sin.sin_family      = domain;
      sin.sin_port        = htons(port);
      sin.sin_addr.s_addr = htonl(INADDR_ANY);

d56 1
a56 1
	 fprintf(stderr,"SendSocket:OpenPort:Error:Cant open AF_INET sockets\n");
d62 25
a86 6
      if (bind(s,(struct sockaddr *) &sin, SinSIZE) < 0) {
	 fprintf(stderr,"SendSocket:OpenPort:Error:Cant bind port:%d\n",port);
	 perror("SendSocket:OpenPort:errno");
	 close(ssock);
	 ssock = 0;
	 return FAIL;
d319 1
a319 1
int cc;
d321 3
d336 23
a358 6
      cc = sendto(ssock,
		  (char *) cp,
		  strlen(cp),
		  0,
		  (struct sockaddr *) &sin,
		  SinSIZE);
d540 2
a541 2
	     "   -p  <PORT>        ;Sets the target port number\n"
	     "   -t  <IP ADDRESS>  ;Sets the target IP address (Local=127.0.0.1)\n"
d545 1
d578 1
a578 1
	    domain = AF_INET;
d617 1
d635 4
a638 1
      fprintf(stderr,"\n");
d651 1
d657 1
d673 1
a673 1

@


1.4
log
@*** empty log message ***
@
text
@d35 1
d53 1
a53 1
      sin.sin_family      = AF_INET;
d57 1
a57 1
      s = socket(AF_INET, SOCK_DGRAM, 0);
d68 2
d247 1
a247 1
static char res[PACKET_STRING_SIZE];
d262 1
a262 1
   bzero((void *) res, PACKET_STRING_SIZE);
d264 27
a290 27
   sprintf(res,"eventName      :%s\n"
	       "eventId        :%d\n"
	       "ClassName      :%s\n"
	       "oCounter       :%d\n"
	       "acqC           :%d\n"
	       "acqUTC         :%d\n"
	       "acqNano        :%d\n"
	       "cycleUTC       :%d\n"
	       "cycleNano      :%d\n"
	       "eventPayload   :0x%04X (%d)\n"
	       "cycleUserName  :%s\n"
	       "acqTimeString  :%s\n"
	       "cycleTimeString:%s\n",
		     evn,
	       (int) pkt->Equipment,
		     cln,
	       (int) pkt->SequenceNumber,
	       (int) pkt->Acquisition.CTrain,
	       (int) pkt->Acquisition.Second,
	       (int) pkt->Acquisition.Nano,
	       (int) pkt->StartCycle.Second,
	       (int) pkt->StartCycle.Nano,
	       (int) pkt->Payload,
	       (int) pkt->Payload,
		     pkt->CycleName,
	       TimeToStr(&(pkt->Acquisition)),
	       TimeToStr(&(pkt->StartCycle)));
d292 1
a292 1
   if (debug) printf("\n%s\n",res);
d294 1
a294 1
   return res;
d311 1
a311 1
      sin.sin_family      = AF_INET;
d539 4
a542 1
	 if (cp) strcpy(target,cp);
@


1.3
log
@Works OK
@
text
@d33 2
d261 2
a262 1
   sprintf(res,"EventName      :%s\n"
d270 1
a270 1
	       "cyclePayload   :0x%04X (%d)\n"
d275 1
d349 1
a349 1
   err = TimLibQueue(1,0);
d381 1
a381 1
   err = TimLibQueue(1,0);
d592 3
@


1.2
log
@Compiles OK
@
text
@d267 1
a267 1
	       "cycleUser      :%d\n"
d279 2
a280 1
	       (int) pkt->CycleUser,
d284 3
d400 1
a400 1
char          *cp;
d447 6
a452 2
      pkt->CycleUser = payload;
      cp = (char *) TgmGetLineName(TgmSPS,"USER",payload);
d455 1
a455 1
	 free(cp);
d523 2
a524 4
	 if (strlen(options[PORT]) < strlen(argv[i])) {
	    i++;
	    cp = argv[i];
	 } else cp = &(argv[i][strlen(options[PORT])]);
d530 2
a531 4
	 if (strlen(options[TARGET]) < strlen(argv[i])) {
	    i++;
	    cp = argv[i];
	 } else cp = &(argv[i][strlen(options[TARGET])]);
d537 2
a538 4
	 if (strlen(options[CTIM]) < strlen(argv[i])) {
	    i++;
	    cp = argv[i];
	 } else cp = &(argv[i][strlen(options[CTIM])]);
d547 2
a548 4
	 if (strlen(options[PTIM]) < strlen(argv[i])) {
	    i++;
	    cp = argv[i];
	 } else cp = &(argv[i][strlen(options[PTIM])]);
@


1.1
log
@Initial revision
@
text
@d23 1
a27 2
#define SinSIZE (sizeof(struct sockaddr_in))

d34 1
a34 10
typedef enum {
   HELP,
   PORT,
   TARGET,
   EVENT,
   DEBUG,
   OPTIONS
 } Options;

char *options[OPTIONS] = {"-h","-p","-t","-e","-d"};
d36 2
d72 10
a81 1
/* Convert time to string                                        */
d84 60
a143 1
char *TimeToStr(TimLibTime *t) {
d174 1
a174 1
   if ((t->Machine < MNAMES) && (t->CTrain > 0)) {
d176 1
a176 1
      strcat(tbuf,mnames[t->Machine]);
d185 50
d238 35
a272 16
char res[256];

   bzero((void *) res, 256);
   sprintf(res,"Event:    %d\n"
	       "Class:    %d\n"
	       "oCounter: %d\n"
	       "acqC:     %d\n"
	       "acqUTC:   %d\n"
	       "acqNano:  %d\n"
	       "cycleUTC: %d\n"
	       "cycleNano:%d\n"
	       "cycleName:%s\n"
	       "acqTime:  %s\n"
	       "cycleTime:%s\n",
	       (int) pkt->Equipment,
	       (int) pkt->Class,
d279 1
d287 2
d327 2
d359 2
d380 1
a380 1
   err = TimLibConnect(TimLibClassPTIM,ctim,0);
d391 2
d435 1
a435 1
      bcopy((void *) &cstamp,  (void *) &(pkt->StartCycle), sizeof(Time));
d438 1
a438 1
	 bcopy((void *) &trigger, (void *) &(pkt->Acquisition),sizeof(Time));
d440 1
a440 1
	 bcopy((void *) &output, (void *) &(pkt->Acquisition),sizeof(Time));
d443 1
d456 2
d469 2
d473 2
a474 3
int i;
char target[32], *cp, *ep;
unsigned long ctim;
a475 1
AcqPacket pkt;
d477 3
a479 1
   ErrSetHandler((ErrHandler) error_handler);
d481 25
a505 3
   port = PORT;
   strcpy(target,TARGET);
   ctim = CTIM;
d508 2
d512 1
a512 32
      if (strcmp(argv[i],options[HELP]) == 0) {
	 printf("\nOptions are:\n\n");
	 for (i=0; i<OPTIONS; i++) {
	    printf("%s ",options[i]);
	    switch ((Options) i) {
	       case HELP:
		  printf("[print this help text]\n");
	       break;

	       case PORT:
		  printf("<UDP Port number to be used. Default:%d>\n",PORT);
	       break;

	       case TARGET:
		  printf("<Target systems IP address. Default:%s>\n",TARGET);
	       break;

	       case CTIM:
		  printf("<SPS extraction CTIM event ID. Default:%d>\n",CTIM);
	       break;

	       case DEBUG:
		  printf("<Debug level: 0/None 1/Debug ON. Default:0>\n");
	       break;

	       default:
		  printf("For help type: SendSocket help\n");
	    }
	 }
	 printf("\n\n");
	 exit(0);
      }
d514 5
a518 3
      else if (strcmp(argv[i],options[PORT]) == 0) {
	 i++;
	 cp = argv[i];
d523 5
a527 3
      else if (strcmp(argv[i],options[TARGET]) == 0) {
	 i++;
	 cp = argv[i];
d532 9
a540 4
      else if (strcmp(argv[i],options[CTIM]) == 0) {
	 i++;
	 cp = argv[i];
	 if (cp) ctim = strtoul(cp,&ep,0);
d544 9
a552 4
      else if (strcmp(argv[i],options[DEBUG]) == 0) {
	 i++;
	 cp    = argv[i];
	 debug = strtoul(cp,&ep,0);
d556 3
a558 4
      else {
	 printf("No such option: %s\n",argv[i]);
	 printf("For help type: timtest %s\n",options[HELP]);
	 exit(1);
d560 3
d565 24
a588 5
   fprintf(stderr,
	  "SendSocket:Sartup parameters:Port:%d Target:%s Ctim:%d\n",
	   port,
	   target,
	   (int) ctim);
d590 1
a590 3
   if ( (OpenPort(port))
   &&   (ConnectToCtim(ctim))
   &&   (ConnectToCtim(SYNC)) ) {
d592 15
a606 1
      fprintf(stderr,"SendSocket: Up and running OK\n");
@
