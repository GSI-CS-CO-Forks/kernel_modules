head	1.17;
access;
symbols;
locks; strict;
comment	@ * @;


1.17
date	2009.09.09.07.47.53;	author baujc;	state Exp;
branches;
next	1.16;

1.16
date	2008.11.12.13.56.10;	author lewis;	state Exp;
branches;
next	1.15;

1.15
date	2007.12.17.15.25.00;	author lewis;	state Exp;
branches;
next	1.14;

1.14
date	2007.08.29.16.47.09;	author lewis;	state Exp;
branches;
next	1.13;

1.13
date	2007.08.14.15.57.28;	author lewis;	state Exp;
branches;
next	1.12;

1.12
date	2007.06.04.13.47.48;	author lewis;	state Exp;
branches;
next	1.11;

1.11
date	2006.05.02.14.01.31;	author lewis;	state Exp;
branches;
next	1.10;

1.10
date	2005.12.21.13.28.01;	author lewis;	state Exp;
branches;
next	1.9;

1.9
date	2005.12.20.09.08.03;	author lewis;	state Exp;
branches;
next	1.8;

1.8
date	2005.08.23.16.08.53;	author lewis;	state Exp;
branches;
next	1.7;

1.7
date	2005.05.18.09.22.59;	author lewis;	state Exp;
branches;
next	1.6;

1.6
date	2005.05.04.13.39.44;	author lewis;	state Exp;
branches;
next	1.5;

1.5
date	2005.04.28.08.39.30;	author lewis;	state Exp;
branches;
next	1.4;

1.4
date	2005.04.28.08.21.00;	author lewis;	state Exp;
branches;
next	1.3;

1.3
date	2005.02.09.17.47.56;	author lewis;	state Exp;
branches;
next	1.2;

1.2
date	2005.01.17.10.02.56;	author lewis;	state Exp;
branches;
next	1.1;

1.1
date	2005.01.17.09.33.36;	author lewis;	state Exp;
branches;
next	;


desc
@@


1.17
log
@Suppress sleep(1) in NetWrkLibWait. It causes lost of events.
@
text
@#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>

#include <tgv/tgv.h>

/*
 * ==================================================================== 
 * Do it for the DTM library 
 * Julian Lewis May 2004 
 * ==================================================================== 
 */

#include <tgm/tgm.h>

typedef struct {
   unsigned long mtype;
   unsigned char mtext[16];
} TimLibSimMesBuf;

extern TgmCompletion _TgmHisBuffAddElement(TgmHistoryBuffer * hm);

#define CONNECTIONS (TgmMACHINES * 2)

static int netwrk_timeout = 12;
static int netwrk_initialized = 0;
static int netwrk_connected = 0;
static int netwrk_connections[CONNECTIONS];

static int dtmskt = -1;		/* Incomming event DTM input socket */

/*
 * ==================================================================== 
 * Initialize DTM history mechanism 
 */

TimLibError NetWrkLibInitialize(TimLibDevice device)
{				/* Initialize hardware/software */

   int i;

   dtmskt = TgmDtmHisGetSocket();
   if (dtmskt == -1)
      return TimLibErrorOPEN;

   if (netwrk_initialized == 0) {
      netwrk_initialized = 1;
      netwrk_connected = 0;
      for (i = 0; i < CONNECTIONS; i++) {
	 netwrk_connections[i] = 0;
      }
   }
   return TimLibErrorSUCCESS;
}

/* ====== */

int NetWrkLibFdInitialize(TimLibDevice device) {
   return 0;
}

/*
 * ==================================================================== 
 * Connect to an interrupt.  
 * Only CTIMS in the list above are allowed 
 */


TimLibError NetWrkLibConnect(TimLibClass iclss,	/* Class of interrupt */
			     unsigned long equip,	/* Equipment or hardware mask */
			     unsigned long module)
{				/* For HARD or CTIM classes */

   int i;

   if (netwrk_initialized) {

      if (iclss == TimLibClassPTIM)
	 return TimLibErrorPTIM;
      if (iclss == TimLibClassHARDWARE)
	 return TimLibErrorHARDWARE;

      if (iclss == TimLibClassCTIM) {
	 for (i = 0; i < netwrk_connected; i++) {
	    if (netwrk_connections[i] == equip) {
	       return TimLibErrorSUCCESS;
	    }
	 }
	 i = netwrk_connected;
	 if (i < CONNECTIONS) {
	    netwrk_connections[i] = equip;
	    netwrk_connected++;
	    if (TgmAttach(TgvTgvToTgmMachine(TgvGetMachineForMember(equip)), TgmTELEGRAM) != TgmSUCCESS)
	       return TimLibErrorCTIM;
	    return TimLibErrorSUCCESS;
	 }
	 return TimLibErrorNOMEM;
      }
   }
   return TimLibErrorINIT;
}

/* ====== */

TimLibError NetWrkLibFdConnect(int fd,                 /* File descriptor */
			       TimLibClass iclss,      /* Class of interrupt */
			       unsigned long equip,    /* Equipment or hardware mask */
			       unsigned long module) { /* For HARD or CTIM classes */
   return TimLibErrorNOT_IMP;
}

/* ==================================================================== */
/* Disconnect from an interrupt                                         */

TimLibError NetWrkLibDisConnect(TimLibClass iclss,         /* Class of interrupt */
				unsigned long equip,       /* Equipment or hardware mask */
				unsigned long module) {
   return TimLibErrorINIT;
}

/*
 * ==================================================================== 
 * Set queueing On or Off, and the time out value in micro seconds.  
 * A timeout value of zero means no time out, you wait for ever.  
 */

TimLibError NetWrkLibQueue(unsigned long qflag,   /* 0=>Queue, 1=>NoQueue */
			   unsigned long tmout) { /* 0=>No time outs */
netwrk_timeout = tmout;

   return TimLibErrorSUCCESS;
}

/* ====== */

TimLibError NetWrkLibFdQueue(int           fd,      /* File descriptor */
			     unsigned long qflag,   /* 0=>Queue, 1=>NoQueue */
			     unsigned long tmout) { /* 0=>No time outs */
   return TimLibErrorNOT_IMP;
}

/* ==================================================================== */
/* To know if a call to wait will block, this call returns the Queue    */
/* size. If the size iz greater than zero a call to wait will not block */
/* and return without waiting. If the qflag is set to NoQueue, zero is  */
/* allways returned and all calls to wait will block.                   */

unsigned long NetWrkLibGetQueueSize() {

   return 0;
}

/*
 * ==================================================================== 
 * Wait for an interrupt. The parameters are all returned from the call 
 * so you can know which interrupt it was that came back. Note, when 
 * waiting for a hardware interrupt from either CTIM or from a counter, 
 * it is the CTIM or PTIM object that caused the interrupt returned.  
 * The telegram will have been read already by the high prioity task 
 * get_tgm_ctr/tg8, be aware of the race condition here, hence payload. 
 * This routine is a blocking call, it waits for interrupt or timeout.  
 * Any NULL argument is permitted, and no value will be returned.  
 *
 * Arguments: 
 * iclss: The class of the interrupt CTIM, PTIM, or hardware 
 * equip: The PTIM, CTIM equipment, or hardware mask 
 * plnum: If class is PTIM this is the PLS line number 
 * source: The hardware source of the interrupt 
 * onzero: The time of the interrupt 
 * trigger: The arrival time of the event that triggered the action 
 * start: The time the start of the counter occured 
 * ctim: The CTIM equipment number of the triggering event 
 * payload: The payload of the triggering event 
 * module: The module number 1..n of the timing receiver card 
 * missed: The number of missed events since the last wait 
 * qsize: The number of remaining interrupts on the queue 
 * mch: The Tgm machine of the trigger event 
 */

TimLibError NetWrkLibWait(TimLibClass * iclss,	/* Class of interrupt */
			  unsigned long *equip,	/* PTIM CTIM or hardware mask */
			  unsigned long *plnum,	/* Ptim line number 1..n or 0 */
			  TimLibHardware * source,	/* Hardware source of interrupt */
			  TimLibTime * onzero,	/* Time of interrupt/output */
			  TimLibTime * trigger,	/* Time of counters load */
			  TimLibTime * start,	/* Time of counters start */
			  unsigned long *ctim,	/* CTIM trigger equipment ID */
			  unsigned long *payload,	/* Payload of trigger event */
			  unsigned long *module,	/* Module that interrupted */
			  unsigned long *missed,	/* Number of missed interrupts */
			  unsigned long *qsize,	/* Remaining interrupts on queue */
			  unsigned long *mch)
{				/* Corresponding TgmMachine */

TgmHistoryBuffer *h;
unsigned long e, f, sime;
int tries, i, simkey, simskt;
TimLibTime t;
TimLibSimMesBuf mbf;
long *mlong;

   tries = TgmMACHINES << 1;	/* Number of packets to timeout */

   if (netwrk_initialized) {
      while (1) {
	 mbf.mtype = 1;
	 mlong = (long *) mbf.mtext;
	 sime = *mlong = 0;
	 simkey = TgmGetKey("TimLibSIM");
	 simskt = msgget(simkey, 0666 | IPC_CREAT);
	 if (msgrcv(simskt, &mbf, sizeof(long) +1, 1, IPC_NOWAIT) != -1) {
	    sime = *mlong;
	 }

	 if (TgmDtmHisWait()) {
	    h = TgmDtmHisRead();
	    if (h) {
	       if (sime)
		  TgmHisSetEventId(h, sime);
	       e = TgmHisGetEventId(h);
	       for (i = 0; i < netwrk_connected; i++) {
		  if (netwrk_connections[i] == e) {

		     if (iclss) *iclss = TimLibClassCTIM;
		     if (mch) *mch = TgmHisGetMachine(h);
		     if (ctim) *ctim = e;
		     if (equip) *equip = e;

		     if (plnum) *plnum = 0;
		     if (source) *source = 0;
		     if (module) *module = 0;
		     if (missed) *missed = 0;
		     if (qsize) *qsize = 0;

		     if (onzero) {
			t.Second = TgmHisGetEvtTimeSec(h);
			t.Nano = TgmHisGetEvtTimeMSc(h) * 1000000;
			t.Machine = TgmHisGetMachine(h);
			t.CTrain = TgmHisGetEvtTimeMSc(h) - TgmHisGetCycleTimeMSc(h);
			*onzero = t;
		     }
		     if (trigger) {
			t.Second = TgmHisGetAqnTimeSec(h);
			t.Nano = TgmHisGetAqnTimeMSc(h) * 1000000;
			t.Machine = TgmHisGetMachine(h);
			t.CTrain = TgmHisGetAqnTimeMSc(h) - TgmHisGetCycleTimeMSc(h);
			*trigger = t;
		     }
		     if (start) {
			t.Second = TgmHisGetCycleTimeSec(h);
			t.Nano = TgmHisGetCycleTimeMSc(h) * 1000000;
			t.Machine = TgmHisGetMachine(h);
			t.CTrain = 0;
			*start = t;
		     }
		     if (payload) {
			f = TgvGetFrameForMember(e);
			if (f & 0xFFFF)
			   *payload = TgmHisGetTelegram(h, 1);
			else
			   *payload = 0;
		     }

		     return TimLibErrorSUCCESS;

		  }		/* End_if (netwrk_connections[i] == e) */
	       }		/* End_for (i = 0; i < netwrk_connected; i++) */
	    } else {
	       return TimLibErrorIO;	/* End_if (h) */
	    }
	    if (netwrk_timeout) {
	       if (--tries <= 0)
		  return TimLibErrorTIMEOUT;
	    }
	 }			/* End_if TgmDtmHisWait() */
      }				/* End_while */
   }                            /* End_if (netwrk_initialized) */
   return TimLibErrorINIT;
}

/* ====== */

TimLibError NetWrkLibFdWait(int fd,                 /* File descriptor */
			    TimLibClass * iclss,    /* Class of interrupt */
			    unsigned long *equip,   /* PTIM CTIM or hardware mask */
			    unsigned long *plnum,   /* Ptim line number 1..n or 0 */
			    TimLibHardware * source,/* Hardware source of interrupt */
			    TimLibTime * onzero,    /* Time of interrupt/output */
			    TimLibTime * trigger,   /* Time of counters load */
			    TimLibTime * start,     /* Time of counters start */
			    unsigned long *ctim,    /* CTIM trigger equipment ID */
			    unsigned long *payload, /* Payload of trigger event */
			    unsigned long *module,  /* Module that interrupted */
			    unsigned long *missed,  /* Number of missed interrupts */
			    unsigned long *qsize,   /* Remaining interrupts on queue */
			    unsigned long *mch) {   /* Corresponding TgmMachine */
   return TimLibErrorNOT_IMP;
}

/*
 * ==================================================================== 
 * Set the Ccv of a PTIM equipment. Note neither the counter number nor 
 * the trigger condition can be changed.  
 */

TimLibError NetWrkLibSet(unsigned long ptim,	/* PTIM to write to */
			 unsigned long plnum,	/* Ptim line number 1..n or 0 */
			 unsigned long grnum,	/* Tgm group number or Zero */
			 unsigned long grval,	/* Group value if num not zero */
			 TimLibCcvMask ccvm,	/* Which values to write */
			 TimLibCcv * ccv)
{				/* Current control value */

   return TimLibErrorNOT_IMP;
}

/*
 * ==================================================================== 
 * Get the Ccv of a PTIM equipment.  
 */

TimLibError
NetWrkLibGet(unsigned long ptim,
	     unsigned long plnum, unsigned long grnum, unsigned long grval, TimLibCcvMask * ccvm, TimLibCcv * ccv)
{

   return TimLibErrorNOT_IMP;
}

/*
 * ==================================================================== 
 * By writing to the driver this call simulates an interrupt for the 
 * connected clients. Also it can be used as a way of synchronizing 
 * processes, this is especially important in Linux systems where the 
 * schedular is not preemptive.  
 *
 * Arguments: 
 * iclss: Class of interrupt to simulate, PTIM, CTIM or Hardware 
 * equip: Equipment number for PTIM or CTIM, hardware mask for Hardware 
 * module: When class is CTIM or Hardware, the module number is used 
 * machine: Telegram ID is used for PTIM interrupts if grnum is not zero 
 * grnum: If zero, no telegram checking, else the PTIM triggers group number 
 * grval: The telegram group value for the PTIM trigger 
 */

TimLibError
NetWrkLibSimulate(TimLibClass iclss,
		  unsigned long equip, unsigned long module, TgmMachine machine, unsigned long grnum, unsigned long grval)
{

TimLibSimMesBuf mbf;
int simkey, simskt;
long *mlong;

   switch (iclss) {
   case TimLibClassHARDWARE:	/* Class is direct hardware connection */
      return TimLibErrorNOT_IMP;

   case TimLibClassCTIM:	/* A Ctim timing object carried by an event on the cable */
      mlong = (long *) mbf.mtext;
      mbf.mtype = 1;
      *mlong = equip;
      simkey = TgmGetKey("TimLibSIM");
      simskt = msgget(simkey, 0666 | IPC_CREAT);
      if (msgsnd(simskt, &mbf, sizeof(long) +1, IPC_NOWAIT) != -1)
	 return TimLibErrorSUCCESS;
      perror("msgsnd in NetWrkLibSimulate:");
      break;

   case TimLibClassPTIM:	/* A PTIM timing object implemented on a counter */
      return TimLibErrorNOT_IMP;
   }

   return TimLibErrorCTIM;
}

/*
 * ==================================================================== 
 * Set a counter under full remote control (IE under DSC tasks control) 
 * This feature permits you to do what you like with counters even if 
 * there is no timing cable attached. With this you can drive stepper 
 * motors, wire scanners or whatever. No PTIM or CTIM is involved, the 
 * configuration is loaded directly by the application. Note that when 
 * the argument remflg is set to 1, the counter can not be written to 
 * by incomming triggers so all PTIM objects using the counter stop 
 * overwriting the counter configuration and are effectivley disabled.  
 * Setting the remflg 0 permits PTIM triggers to write to the counter 
 * configuration, the write block is removed. Also note that in some 
 * cases it is useful to perform remote actions, such as remoteSTOP, 
 * even if the remflg is set to zero. The remflg simply blocks PTIM 
 * overwrites, the counter configuration can still be accessed ! 
 */

TimLibError NetWrkLibRemoteControl(unsigned long remflg,	/* 0 = Normal, 1 = Remote */
				   unsigned long module,	/* Module or zero */
				   unsigned long cntr,	/* 1..8 counter number */
				   TimLibRemote rcmd,	/* Command */
				   TimLibCcvMask ccvm,	/* Fields to be set */
				   TimLibCcv * ccv)
{				/* Value to load in counter */

   return TimLibErrorNOT_IMP;
}

/* ==================================================================== */
/* Get a counters remote configuration                                  */

TimLibError NetWrkLibGetRemote(unsigned long module,
			       unsigned long cntr, unsigned long *remflg, TimLibCcvMask * ccvm, TimLibCcv * ccv)
{

   return TimLibErrorNOT_IMP;
}

/*
 * ==================================================================== 
 * Read the instantaneous value of the time in UTC. The module parameter
 * can be set to zero in which case the system decideds which module to 
 * read the time from, otherwise it can be set to a value between 1 and 
 * the number of installed modules.  
 */

TimLibError NetWrkLibGetTime(unsigned long module,	/* Module number to read from */
			     TimLibTime * utc)
{				/* Returned time value */


   TgmHistoryBuffer *h;
   TimLibTime t;

   if (netwrk_initialized) {
      while (TgmDtmHisWait()) {
	 h = TgmDtmHisRead();
	 if (h) {
	    t.Second = TgmHisGetEvtTimeSec(h);
	    t.Nano = TgmHisGetEvtTimeMSc(h) * 1000000;
	    t.Machine = TgmHisGetMachine(h);
	    t.CTrain = TgmHisGetEvtTimeMSc(h) - TgmHisGetCycleTimeMSc(h);
	    *utc = t;

	    return TimLibErrorSUCCESS;
	 } else
	    return TimLibErrorIO;
      }
   }
   return TimLibErrorINIT;
}

/*
 * ==================================================================== 
 * Read a machines telegram from a timing receiver. The module can be 
 * either zero, in which case the system decides which device to use, 
 * or it can be explicitly set between 1 and the number of installed 
 * modules. The telegram object returned has an opaque structure and 
 * can only be decoded through the Tgm library routine .....  
 *
 * unsigned long grval = TgmGetGroupValueFromTelegram(unsigned long grnum, 
 * TgmTelegram *telegram) 
 *
 * WARNING: The only task that should call this routine will be, get_tgm_lib, 
 * all other, LOWER PRIORITY tasks must NEVER call this routine, instead they 
 * should call the telegram library directly like this ...  
 *
 * TgmTelegram telegram; 
 * if (TgmGetTelegram(machine, index, offset, &telegram) == TgmSUCCESS) { ...  
 * For more information on this function see the Tgm library man pages.  
 */

TimLibError NetWrkLibGetTelegram(unsigned long module, TgmMachine machine, TgmPTelegram * telegram)
{

   TgmHistoryBuffer *h;
   long gv;
   unsigned long m, gn;

   if (netwrk_initialized) {
      while (TgmDtmHisWait()) {
	 h = TgmDtmHisRead();
	 if (h) {
	    m = TgmHisGetMachine(h);
	    if (m == machine) {
	       telegram->Size = TgmLastGroupNumber(m);
	       telegram->Machine = machine;
	       for (gn = 1; gn <= telegram->Size; gn++) {
		  gv = (long) TgmHisGetTelegram(h, gn);
		  TgmSetGroupValueInTelegram(gn, gv, (TgmTelegram *) telegram);
	       }
	       return TimLibErrorSUCCESS;
	    }
	 } else
	    return TimLibErrorIO;
      }
   }
   return TimLibErrorINIT;
}

/*
 * ==================================================================== 
 * Lets you know how many installed modules there are on this host.  
 */

unsigned long NetWrkLibGetInstalledModuleCount()
{

   return 0;
}

/*
 * ==================================================================== 
 * Get the description of a given PTIM equipment. The dimension returns 
 * the PPM dimension, counter and module are obvious.  
 */

TimLibError NetWrkLibGetPtimObject(unsigned long ptim,	/* PTIM equipment number */
				   unsigned long *module, unsigned long *counter, unsigned long *dimension)
{

   return TimLibErrorNOT_IMP;
}

/*
 * ==================================================================== 
 * Get the event code corresponding to a given CTIM equipment number.  
 */

TimLibError NetWrkLibGetCtimObject(unsigned long ctim,	/* CTIM equipment number */
				   unsigned long *eventcode)
{

   *eventcode = TgvGetFrameForMember(ctim);
   if (*eventcode)
      return TimLibErrorSUCCESS;
   return TimLibErrorCTIM;
}

/*
 * ==================================================================== 
 * In some cases when running a GUI under Linux, say, a file handle to 
 * put in a "select" is needed so that one can wait on multiple file 
 * handles simultaneously. This routine returns such a handle suitable 
 * to check for waiting interrupts. Do not read directly from it, but 
 * call the wait routine. The queue flag must be on for this to work !! 
 */

TimLibError NetWrkLibGetHandle(int *fd)
{

   if (netwrk_initialized) {
      *fd = TgmDtmHisGetSocket();
      return TimLibErrorSUCCESS;
   }
   return TimLibErrorINIT;
}

/*
 * ==================================================================== 
 * Create a new PTIM object, the CCV settings will be defaulted.  
 */


TimLibError NetWrkLibCreatePtimObject(unsigned long ptim,	/* PTIM equipment number */
				      unsigned long module, unsigned long counter, unsigned long dimension)
{
   return TimLibErrorNOT_IMP;
}

/*
 * ==================================================================== 
 * Create a new CTIM object. If a payload is to be used for this event 
 * be sure to set the low 16-Bits to 0xFFFF 
 */

TimLibError NetWrkLibCreateCtimObject(unsigned long ctim,	/* CTIM equipment number */
				      unsigned long eventcode)
{
   return TimLibErrorNOT_IMP;
}

/*
 * ==================================================================== 
 * Get the cable identifier to which a given module is attached so that
 * the correct module can be used to read telegrams. This function will
 * be used by the program get_tgm_tim only; it is of no interest to the
 * majority of clients because calls to ReadTelegram are diverted.
 */

TimLibError NetWrkLibGetCableId(unsigned long module,	/* The given module */
				unsigned long *cable)
{				/* The cable ID */

   return TimLibErrorNOT_IMP;
}


/* ==================================================================== */
/* Get the status of a module and its device type.                      */

TimLibStatus NetWrkLibGetStatus(unsigned long module, TimLibDevice * dev)
{

   if (dev)
      *dev = TimLibDevice_NETWORK;
   return TimLibStatusBITS;
}

/* ==================================================================== */
/* Get the list of all defined PTIM objects                             */

TimLibError NetWrkLibGetAllPtimObjects(unsigned long *ptimlist,	/* List of ptim equipments */
				       unsigned long *psize,	/* Number of ptims in list */
				       unsigned long size)
{				/* Max size of list */

   *psize = 0;
   return TimLibErrorSUCCESS;
}

/* ==================================================================== */
/* Get the list of all defined CTIM objects                             */

TimLibError NetWrkLibGetAllCtimObjects(unsigned long *ctimlist,	/* List of ctim equicments */
				       unsigned long *csize,	/* Number of ctims in list */
				       unsigned long size)
{				/* Max size of list */

   unsigned long equip, cnt;
   TgmNetworkId nid;

   nid = TgmGetDefaultNetworkId();
   equip = TgvFirstGMember();
   cnt = 0;
   while ((equip) && (cnt < size)) {
      ctimlist[cnt++] = equip;
      equip = TgvNextGMember();
   }
   *csize = cnt;
   return TimLibErrorSUCCESS;
}

/* ==================================================================== */
/* Get VHDL/Firmware version of all modules, and the correct version.   */

TimLibError NetWrkLibGetModuleVersion(TimLibModuleVersion *version) {

   return TimLibErrorNOT_IMP;

}

/* ==================================================================== */
/* Get specific information string                                      */
/* There is some very specific module dependent status information.     */
/* This routine returns a free format human readable string containing  */
/* specific status information that may help diagnosing problems for a  */
/* timing receiver module. A null pointer can be returned if the module */
/* is either dead or not installed.                                     */

char *NetWrkLibGetSpecificInfo(unsigned long module) { /* The given module */

   return NULL;
}

/* ==================================================================== */

TimLibError NetWrkLibConnectPayload(unsigned long ctim,        /* The CTIM ID you want to connect to */
				    unsigned long payload,     /* The 16 bit payload in a long */
				    unsigned long module) {    /* The module, or zero means don't care */
   return TimLibErrorNOT_IMP;
}
@


1.16
log
@Added routines to connect to C-time and get module for a CTIM
@
text
@a275 1
	 sleep(1);
@


1.15
log
@Added Thread support via File Descriptor FD extra parameter
@
text
@d663 7
@


1.14
log
@Added specific info routine
@
text
@d56 6
d103 9
d127 3
a129 3
TimLibError NetWrkLibQueue(unsigned long qflag,	/* 0=>Queue, 1=>NoQueue */
			   unsigned long tmout)
{				/* 0=>No time outs */
d131 4
a134 1
   netwrk_timeout = tmout;
d136 4
a139 1
   return TimLibErrorSUCCESS;
d282 19
@


1.13
log
@Added GetModuleVersion
@
text
@d610 13
@


1.12
log
@DisConnect
@
text
@d600 10
@


1.11
log
@Added GetQueueSize
@
text
@d97 9
@


1.10
log
@*** empty log message ***
@
text
@d112 11
@


1.9
log
@*** empty log message ***
@
text
@d1 4
d6 1
d16 6
a21 1
extern TgmCompletion _TgmHisBuffAddElement(TgmHistoryBuffer *hm);
d25 6
a30 4
static int      netwrk_timeout = 1;
static int      netwrk_initialized = 0;
static int      netwrk_connected = 0;
static int      netwrk_connections[CONNECTIONS];
d37 2
a38 2
TimLibError
NetWrkLibInitialize(TimLibDevice device) { /* Initialize hardware/software */
d40 1
a40 3
int i;
TgmMachine *mch, m;
TgmNetworkId nid;
d42 3
a44 10
   nid = TgmGetDefaultNetworkId();
   mch = TgmGetAllOperMachinesInNetwork(nid);
   if (mch) {
      for (i=0; i<TgmMACHINES; i++) {
	 m = mch[i];
	 if (m == TgmMACHINE_NONE) break;
	 if (TgmAttach(m,TgmTELEGRAM) != TgmSUCCESS) return TimLibErrorINIT;
      }
   }
   if (TgmDtmHisGetSocket() == -1) return TimLibErrorOPEN;
d63 3
a65 4
TimLibError
NetWrkLibConnect(TimLibClass iclss,     /* Class of interrupt */
		 unsigned long equip,	/* Equipment or hardware mask */
		 unsigned long module)
d68 1
a68 1
    int             i;
d70 1
a70 1
    if (netwrk_initialized) {
d72 9
a80 10
	if (iclss == TimLibClassPTIM)
	    return TimLibErrorPTIM;
	if (iclss == TimLibClassHARDWARE)
	    return TimLibErrorHARDWARE;

	if (iclss == TimLibClassCTIM) {
	    for (i = 0; i < netwrk_connected; i++) {
		if (netwrk_connections[i] == equip) {
		    return TimLibErrorSUCCESS;
		}
d82 13
a94 10
	    i = netwrk_connected;
	    if (i < CONNECTIONS) {
		netwrk_connections[i] = equip;
		netwrk_connected++;
		return TimLibErrorSUCCESS;
	    }
	    return TimLibErrorNOMEM;
	}
    }
    return TimLibErrorINIT;
d103 2
a104 3
TimLibError
NetWrkLibQueue(unsigned long qflag,     /* 0=>Queue, 1=>NoQueue */
	       unsigned long tmout)
d107 1
a107 1
    netwrk_timeout = tmout;
d109 1
a109 1
    return TimLibErrorSUCCESS;
d139 13
a151 14
TimLibError
NetWrkLibWait(TimLibClass * iclss,      /* Class of interrupt */
	      unsigned long *equip,	/* PTIM CTIM or hardware mask */
	      unsigned long *plnum,	/* Ptim line number 1..n or 0 */
	      TimLibHardware * source,	/* Hardware source of interrupt */
	      TimLibTime * onzero,	/* Time of interrupt/output */
	      TimLibTime * trigger,	/* Time of counters load */
	      TimLibTime * start,	/* Time of counters start */
	      unsigned long *ctim,	/* CTIM trigger equipment ID */
	      unsigned long *payload,	/* Payload of trigger event */
	      unsigned long *module,	/* Module that interrupted */
	      unsigned long *missed,	/* Number of missed interrupts */
	      unsigned long *qsize,	/* Remaining interrupts on queue */
	      unsigned long *mch)
a152 5
    TgmHistoryBuffer *h, hbuf;
    unsigned long   e, f;
    int             tries,
                    i;
    TimLibTime      t;
d154 19
a172 1
    tries = TgmMACHINES << 1;	/* Number of packets to timeout */
d174 1
a174 2
    if (netwrk_initialized) {
	while (TgmDtmHisWait()) {
d177 53
a229 49
		e = TgmHisGetEventId(h);
		for (i = 0; i < netwrk_connected; i++) {
		    if (netwrk_connections[i] == e) {

			if (iclss) *iclss = TimLibClassCTIM;
			if (mch)   *mch   = TgmHisGetMachine(h);
			if (ctim)  *ctim  = e;
			if (equip) *equip = e;

			if (plnum)  *plnum  = 0;
			if (source) *source = 0;
			if (module) *module = 0;
			if (missed) *missed = 0;
			if (qsize)  *qsize  = 0;

			if (onzero) {
			    t.Second = TgmHisGetEvtTimeSec(h);
			    t.Nano = TgmHisGetEvtTimeMSc(h) * 1000000;
			    t.Machine = TgmHisGetMachine(h);
			    t.CTrain = TgmHisGetEvtTimeMSc(h) - TgmHisGetCycleTimeMSc(h);
			    *onzero = t;
			}
			if (trigger) {
			    t.Second = TgmHisGetAqnTimeSec(h);
			    t.Nano = TgmHisGetAqnTimeMSc(h) * 1000000;
			    t.Machine = TgmHisGetMachine(h);
			    t.CTrain = TgmHisGetAqnTimeMSc(h) - TgmHisGetCycleTimeMSc(h);
			    *trigger = t;
			}
			if (start) {
			    t.Second = TgmHisGetCycleTimeSec(h);
			    t.Nano = TgmHisGetCycleTimeMSc(h) * 1000000;
			    t.Machine = TgmHisGetMachine(h);
			    t.CTrain = 0;
			    *start = t;
			}
			if (payload) {
			    f = TgvGetFrameForMember(e);
			    if (f & 0xFFFF) *payload = TgmHisGetTelegram(h,1);
			    else *payload = 0;
			}

			return TimLibErrorSUCCESS;

		    }
		}
	    } else
		return TimLibErrorIO;

d231 2
a232 2
		if (--tries <= 0)
		    return TimLibErrorTIMEOUT;
d234 5
a238 3
	}
    }
    return TimLibErrorINIT;
d247 6
a252 7
TimLibError
NetWrkLibSet(unsigned long ptim,        /* PTIM to write to */
	     unsigned long plnum,	/* Ptim line number 1..n or 0 */
	     unsigned long grnum,	/* Tgm group number or Zero */
	     unsigned long grval,	/* Group value if num not zero */
	     TimLibCcvMask ccvm,	/* Which values to write */
	     TimLibCcv * ccv)
d255 1
a255 1
    return TimLibErrorNOT_IMP;
d265 1
a265 5
	     unsigned long plnum,
	     unsigned long grnum,
	     unsigned long grval,
	     TimLibCcvMask * ccvm,
	     TimLibCcv * ccv)
d268 1
a268 1
    return TimLibErrorNOT_IMP;
d289 2
a290 5
		  unsigned long equip,
		  unsigned long module,
		  TgmMachine machine,
		  unsigned long grnum,
		  unsigned long grval) {
d292 3
a294 2
int mch;
TgmHistoryBuffer tbuf, hbuf, *phbuf=&hbuf;
d297 2
a298 2
      case TimLibClassHARDWARE:     /* Class is direct hardware connection */
	 return TimLibErrorNOT_IMP;
d300 10
a309 12
      case TimLibClassCTIM:         /* A Ctim timing object carried by an event on the cable */
	 mch = TgvTgvToTgmMachine(TgvGetMachineForMember(equip));
	 if (mch == TgvMACHINE_NONE) return TimLibErrorCTIM;
	 TgmHisClear(&tbuf);
	 TgmHisClear(phbuf);
	 TgmHisSetMachine(&tbuf,mch);
	 if (TgmHisGetHistory(&tbuf,1,&phbuf)) {
	    TgmHisSetEventId(phbuf,equip);
	    _TgmHisBuffAddElement(phbuf);
	    return TimLibErrorSUCCESS;
	 }
	 break;
d311 2
a312 2
      case TimLibClassPTIM:         /* A PTIM timing object implemented on a counter */
	 return TimLibErrorNOT_IMP;
d335 6
a340 7
TimLibError
NetWrkLibRemoteControl(unsigned long remflg,    /* 0 = Normal, 1 = Remote */
		       unsigned long module,	/* Module or zero */
		       unsigned long cntr,	/* 1..8 counter number */
		       TimLibRemote rcmd,	/* Command */
		       TimLibCcvMask ccvm,	/* Fields to be set */
		       TimLibCcv * ccv)
d343 1
a343 1
    return TimLibErrorNOT_IMP;
d350 2
a351 4
			       unsigned long cntr,
			       unsigned long *remflg,
			       TimLibCcvMask *ccvm,
			       TimLibCcv     *ccv) {
d364 2
a365 3
TimLibError
NetWrkLibGetTime(unsigned long module,  /* Module number to read from */
		 TimLibTime * utc)
d369 12
a380 2
    TgmHistoryBuffer *h;
    TimLibTime      t;
d382 6
a387 16
    if (netwrk_initialized) {
	while (TgmDtmHisWait()) {
	    h = TgmDtmHisRead();
	    if (h) {
		t.Second = TgmHisGetEvtTimeSec(h);
		t.Nano = TgmHisGetEvtTimeMSc(h) * 1000000;
		t.Machine = TgmHisGetMachine(h);
		t.CTrain = TgmHisGetEvtTimeMSc(h) - TgmHisGetCycleTimeMSc(h);
		*utc = t;

		return TimLibErrorSUCCESS;
	    } else
		return TimLibErrorIO;
	}
    }
    return TimLibErrorINIT;
d410 1
a410 2
TimLibError
NetWrkLibGetTelegram(unsigned long module, TgmMachine machine, TgmPTelegram *telegram)
d413 23
a435 24
    TgmHistoryBuffer *h;
    long            gv;
    unsigned long   m,
                    gn;

    if (netwrk_initialized) {
	while (TgmDtmHisWait()) {
	    h = TgmDtmHisRead();
	    if (h) {
		m = TgmHisGetMachine(h);
		if (m == machine) {
		    telegram->Size = TgmLastGroupNumber(m);
		    telegram->Machine = machine;
		    for (gn = 1; gn <= telegram->Size; gn++) {
			gv = (long) TgmHisGetTelegram(h, gn);
			TgmSetGroupValueInTelegram(gn, gv, (TgmTelegram *) telegram);
		    }
		    return TimLibErrorSUCCESS;
		}
	    } else
		return TimLibErrorIO;
	}
    }
    return TimLibErrorINIT;
d443 1
a443 2
unsigned long
NetWrkLibGetInstalledModuleCount()
d446 1
a446 1
    return 0;
d455 2
a456 3
TimLibError
NetWrkLibGetPtimObject(unsigned long ptim,      /* PTIM equipment number */
		       unsigned long *module, unsigned long *counter, unsigned long *dimension)
d459 1
a459 1
    return TimLibErrorNOT_IMP;
d467 2
a468 3
TimLibError
NetWrkLibGetCtimObject(unsigned long ctim,      /* CTIM equipment number */
		       unsigned long *eventcode)
d471 4
a474 3
    *eventcode = TgvGetFrameForMember(ctim);
    if (*eventcode) return TimLibErrorSUCCESS;
    return TimLibErrorCTIM;
d486 1
a486 2
TimLibError
NetWrkLibGetHandle(int *fd)
d489 5
a493 5
    if (netwrk_initialized) {
	*fd = TgmDtmHisGetSocket();
	return TimLibErrorSUCCESS;
    }
    return TimLibErrorINIT;
d502 2
a503 3
TimLibError
NetWrkLibCreatePtimObject(unsigned long ptim,   /* PTIM equipment number */
			  unsigned long module, unsigned long counter, unsigned long dimension)
d505 1
a505 1
    return TimLibErrorNOT_IMP;
d514 2
a515 3
TimLibError
NetWrkLibCreateCtimObject(unsigned long ctim,   /* CTIM equipment number */
			  unsigned long eventcode)
d517 1
a517 1
    return TimLibErrorNOT_IMP;
d528 3
a530 2
TimLibError NetWrkLibGetCableId(unsigned long module,   /* The given module */
				unsigned long *cable) { /* The cable ID */
d539 2
a540 2
TimLibStatus NetWrkLibGetStatus(unsigned long module,
				TimLibDevice *dev) {
d542 2
a543 1
   if (dev) *dev = TimLibDevice_NETWORK;
d550 4
a553 3
TimLibError NetWrkLibGetAllPtimObjects(unsigned long *ptimlist,  /* List of ptim equipments */
				       unsigned long *psize,     /* Number of ptims in list */
				       unsigned long size) {     /* Max size of list */
d562 4
a565 3
TimLibError NetWrkLibGetAllCtimObjects(unsigned long *ctimlist,  /* List of ctim equicments */
				       unsigned long *csize,     /* Number of ctims in list */
				       unsigned long size) {     /* Max size of list */
d567 2
a568 2
unsigned long equip, cnt;
TgmNetworkId nid;
d571 3
a573 2
   equip = TgvFirstGMember(); cnt = 0;
   while ((equip) && (cnt<size)) {
@


1.8
log
@Added GetAllCtims
@
text
@d1 1
d11 2
d26 1
a26 2
NetWrkLibInitialize(TimLibDevice device)
{				/* Initialize hardware/software */
d28 23
a50 13
    int             i;

    if (TgmDtmHisGetSocket() == -1)
	return TimLibErrorOPEN;

    if (netwrk_initialized == 0) {
	netwrk_initialized = 1;
	netwrk_connected = 0;
	for (i = 0; i < CONNECTIONS; i++) {
	    netwrk_connections[i] = 0;
	}
    }
    return TimLibErrorSUCCESS;
d151 2
a152 2
    TgmHistoryBuffer *h;
    unsigned long   e;
d166 12
a177 8
			if (iclss)
			    *iclss = TimLibClassCTIM;
			if (equip)
			    *equip = e;
			if (plnum)
			    *plnum = 0;
			if (source)
			    *source = 0;
d199 5
a203 12
			if (ctim)
			    *ctim = e;
			if (payload)
			    *payload = 0;
			if (module)
			    *module = 0;
			if (missed)
			    *missed = 0;
			if (qsize)
			    *qsize = 0;
			if (mch)
			    *mch = TgmHisGetMachine(h);
d274 29
a302 2
		  unsigned long equip, unsigned long module, TgmMachine machine, unsigned long grnum, unsigned long grval)
{
d304 1
a304 1
    return TimLibErrorNOT_IMP;
d469 3
a471 1
    return TimLibErrorNOT_IMP;
d563 11
a573 1
    return TimLibErrorNOT_IMP;
@


1.7
log
@*** empty log message ***
@
text
@d517 10
@


1.6
log
@Works correctly
@
text
@a57 2
	if (module != 0)
	    return TimLibErrorMODULE;
a91 2
    if (qflag == 0)
	return TimLibErrorNOT_IMP;
d141 1
a141 2
    int             concnt,
                    tries,
a199 2
		if (concnt == 0)
		    return TimLibErrorWAIT;
a376 2
	if (module != 0)
	    return TimLibErrorMODULE;
@


1.5
log
@*** empty log message ***
@
text
@d307 12
@


1.4
log
@*** empty log message ***
@
text
@a226 1
	     TgmMachine machine,	/* Telegram identifier */
a227 1
	     unsigned long ctim,	/* If plnum is not zero this is the ctim trigger */
a243 1
	     TgmMachine machine,
@


1.3
log
@*** empty log message ***
@
text
@d245 6
a250 3
NetWrkLibGet(unsigned long ptim, TgmMachine machine, unsigned long grnum, unsigned long grval, TimLibCcvMask * ccvm,    /* Valid
															 * fields
															 * in ccv */
d495 22
@


1.2
log
@*** empty log message ***
@
text
@d363 1
a363 1
NetWrkLibGetTelegram(unsigned long module, TgmMachine machine, TgmPTelegram * telegram)
d383 1
a383 1
			TgmSetGroupValueInTelegram(gn, gv, (TgmTelegram *) & telegram);
@


1.1
log
@Initial revision
@
text
@d12 4
a15 4
static int      dtmtim_timeout = 1;
static int      dtmtim_initialized = 0;
static int      dtmtim_connected = 0;
static int      dtmtim_connections[CONNECTIONS];
d23 1
a23 1
DtmTimLibInitialize(TimLibDevice device)
d31 3
a33 3
    if (dtmtim_initialized == 0) {
	dtmtim_initialized = 1;
	dtmtim_connected = 0;
d35 1
a35 1
	    dtmtim_connections[i] = 0;
d49 1
a49 1
DtmTimLibConnect(TimLibClass iclss,	/* Class of interrupt */
d56 1
a56 1
    if (dtmtim_initialized) {
d66 2
a67 2
	    for (i = 0; i < dtmtim_connected; i++) {
		if (dtmtim_connections[i] == equip) {
d71 1
a71 1
	    i = dtmtim_connected;
d73 2
a74 2
		dtmtim_connections[i] = equip;
		dtmtim_connected++;
d90 1
a90 1
DtmTimLibQueue(unsigned long qflag,	/* 0=>Queue, 1=>NoQueue */
d96 1
a96 1
    dtmtim_timeout = tmout;
d129 1
a129 1
DtmTimLibWait(TimLibClass * iclss,	/* Class of interrupt */
d152 1
a152 1
    if (dtmtim_initialized) {
d157 2
a158 2
		for (i = 0; i < dtmtim_connected; i++) {
		    if (dtmtim_connections[i] == e) {
d210 1
a210 1
	    if (dtmtim_timeout) {
d226 1
a226 1
DtmTimLibSet(unsigned long ptim,	/* PTIM to write to */
d245 1
a245 1
DtmTimLibGet(unsigned long ptim, TgmMachine machine, unsigned long grnum, unsigned long grval, TimLibCcvMask * ccvm,	/* Valid
d271 1
a271 1
DtmTimLibSimulate(TimLibClass iclss,
d296 1
a296 1
DtmTimLibRemoteControl(unsigned long remflg,	/* 0 = Normal, 1 = Remote */
d316 1
a316 1
DtmTimLibGetTime(unsigned long module,	/* Module number to read from */
d324 1
a324 1
    if (dtmtim_initialized) {
d363 1
a363 1
DtmTimLibGetTelegram(unsigned long module, TgmMachine machine, TgmPTelegram * telegram)
d371 1
a371 1
    if (dtmtim_initialized) {
d400 1
a400 1
DtmTimLibGetInstalledModuleCount()
d413 1
a413 1
DtmTimLibGetPtimObject(unsigned long ptim,	/* PTIM equipment number */
d426 1
a426 1
DtmTimLibGetCtimObject(unsigned long ctim,	/* CTIM equipment number */
d443 1
a443 1
DtmTimLibGetHandle(int *fd)
d446 1
a446 1
    if (dtmtim_initialized) {
d460 1
a460 1
DtmTimLibCreatePtimObject(unsigned long ptim,	/* PTIM equipment number */
a467 2
 */
/*
d473 1
a473 1
DtmTimLibCreateCtimObject(unsigned long ctim,	/* CTIM equipment number */
d478 14
@
