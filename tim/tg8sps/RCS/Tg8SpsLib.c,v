head	1.55;
access;
symbols;
locks; strict;
comment	@ * @;


1.55
date	2008.11.12.13.55.43;	author lewis;	state Exp;
branches;
next	1.54;

1.54
date	2008.03.28.09.51.04;	author lewis;	state Exp;
branches;
next	1.53;

1.53
date	2008.02.13.10.51.04;	author lewis;	state Exp;
branches;
next	1.52;

1.52
date	2007.12.17.15.24.36;	author lewis;	state Exp;
branches;
next	1.51;

1.51
date	2007.08.29.16.46.28;	author lewis;	state Exp;
branches;
next	1.50;

1.50
date	2007.08.14.15.56.14;	author lewis;	state Exp;
branches;
next	1.49;

1.49
date	2007.06.04.13.47.18;	author lewis;	state Exp;
branches;
next	1.48;

1.48
date	2006.12.20.13.42.40;	author lewis;	state Exp;
branches;
next	1.47;

1.47
date	2006.05.02.14.01.03;	author lewis;	state Exp;
branches;
next	1.46;

1.46
date	2006.03.17.14.52.51;	author lewis;	state Exp;
branches;
next	1.45;

1.45
date	2006.03.17.14.49.39;	author lewis;	state Exp;
branches;
next	1.44;

1.44
date	2006.03.16.14.12.47;	author lewis;	state Exp;
branches;
next	1.43;

1.43
date	2006.03.01.16.52.18;	author lewis;	state Exp;
branches;
next	1.42;

1.42
date	2006.01.25.09.51.01;	author lewis;	state Exp;
branches;
next	1.41;

1.41
date	2005.11.29.08.47.24;	author baujc;	state Exp;
branches;
next	1.40;

1.40
date	2005.11.10.09.42.12;	author lewis;	state Exp;
branches;
next	1.39;

1.39
date	2005.11.03.18.26.28;	author lewis;	state Exp;
branches;
next	1.38;

1.38
date	2005.11.02.17.22.59;	author lewis;	state Exp;
branches;
next	1.37;

1.37
date	2005.10.31.13.36.05;	author lewis;	state Exp;
branches;
next	1.36;

1.36
date	2005.10.21.15.50.20;	author lewis;	state Exp;
branches;
next	1.35;

1.35
date	2005.10.21.14.56.07;	author lewis;	state Exp;
branches;
next	1.34;

1.34
date	2005.10.18.08.40.43;	author lewis;	state Exp;
branches;
next	1.33;

1.33
date	2005.08.24.15.41.41;	author lewis;	state Exp;
branches;
next	1.32;

1.32
date	2005.08.23.16.07.40;	author lewis;	state Exp;
branches;
next	1.31;

1.31
date	2005.08.22.15.19.32;	author lewis;	state Exp;
branches;
next	1.30;

1.30
date	2005.08.01.13.22.34;	author lewis;	state Exp;
branches;
next	1.29;

1.29
date	2005.07.08.15.44.50;	author lewis;	state Exp;
branches;
next	1.28;

1.28
date	2005.07.04.11.47.26;	author lewis;	state Exp;
branches;
next	1.27;

1.27
date	2005.06.30.05.57.35;	author lewis;	state Exp;
branches;
next	1.26;

1.26
date	2005.06.21.14.10.20;	author lewis;	state Exp;
branches;
next	1.25;

1.25
date	2005.06.17.14.24.58;	author lewis;	state Exp;
branches;
next	1.24;

1.24
date	2005.06.16.07.34.39;	author lewis;	state Exp;
branches;
next	1.23;

1.23
date	2005.06.10.15.52.36;	author lewis;	state Exp;
branches;
next	1.22;

1.22
date	2005.06.10.15.20.52;	author lewis;	state Exp;
branches;
next	1.21;

1.21
date	2005.05.20.14.38.47;	author lewis;	state Exp;
branches;
next	1.20;

1.20
date	2005.05.20.14.26.56;	author lewis;	state Exp;
branches;
next	1.19;

1.19
date	2005.05.04.13.39.06;	author lewis;	state Exp;
branches;
next	1.18;

1.18
date	2005.04.27.16.52.58;	author lewis;	state Exp;
branches;
next	1.17;

1.17
date	2005.01.17.10.16.19;	author lewis;	state Exp;
branches;
next	1.16;

1.16
date	2005.01.12.17.25.25;	author lewis;	state Exp;
branches;
next	1.15;

1.15
date	2005.01.12.14.38.28;	author lewis;	state Exp;
branches;
next	1.14;

1.14
date	2004.12.01.18.37.33;	author lewis;	state Exp;
branches;
next	1.13;

1.13
date	2004.12.01.17.58.29;	author lewis;	state Exp;
branches;
next	1.12;

1.12
date	2004.12.01.17.51.57;	author lewis;	state Exp;
branches;
next	1.11;

1.11
date	2004.12.01.14.20.45;	author lewis;	state Exp;
branches;
next	1.10;

1.10
date	2004.11.26.16.33.54;	author lewis;	state Exp;
branches;
next	1.9;

1.9
date	2004.11.25.13.42.29;	author lewis;	state Exp;
branches;
next	1.8;

1.8
date	2004.11.25.10.49.04;	author lewis;	state Exp;
branches;
next	1.7;

1.7
date	2004.11.24.14.33.26;	author lewis;	state Exp;
branches;
next	1.6;

1.6
date	2004.11.24.13.51.28;	author lewis;	state Exp;
branches;
next	1.5;

1.5
date	2004.11.22.10.32.05;	author lewis;	state Exp;
branches;
next	1.4;

1.4
date	2004.11.19.18.04.18;	author lewis;	state Exp;
branches;
next	1.3;

1.3
date	2004.11.19.17.31.56;	author lewis;	state Exp;
branches;
next	1.2;

1.2
date	2004.07.29.15.34.08;	author lewis;	state Exp;
branches;
next	1.1;

1.1
date	2004.07.28.14.19.55;	author lewis;	state Exp;
branches;
next	;


desc
@@


1.55
log
@Added routines to connect to C-time and get module for a CTIM
@
text
@/*
 * ==================================================================== 
 * Implement the timing library over the SPS-TG8 timing receiver.  
 * Julian Lewis Nov 2004 
 * ==================================================================== 
 */

#include <sys/shm.h>		/* Shared memory */
#include <sys/ioctl.h>
#ifndef __68k__
#include <sys/select.h>
#endif
#include <sys/time.h>
#include <sys/types.h>
#include <unistd.h>

#include "../TimLib.h"
#include <tgm/tgm.h>

extern int timlib_debug;    /* 1/Print stuff, 2/Wipe memory */
extern int timlib_delay;    /* Input delay when not zero */
extern int timlib_enable;   /* Enable modules */
extern int timlib_real_utc; /* Do not adjust the UTC time */
/*
 * General note: I can't include the SPS TG8 driver definitions in the same 
 * compilation unit because they clash with those of the CPS TG8 driver. So 
 * I will define what I need here using symbols starting with SpsTg8.  
 */

#ifndef UBCD
#define UBCD(bcd) ((bcd&0xF)+10*(bcd>>4))
#endif

#define SpsTg8DrvrMODULES  4
#define SpsTg8DrvrCLIENTS_PER_MODULE 8
#define SpsTg8DrvrGROUPS 24
#define SpsTg8DrvrACTIONS 256

typedef enum {
   SpsTg8DrvrDEBUG_ON,
   SpsTg8DrvrDEBUG_OFF,
   SpsTg8DrvrGET_DRI_VERSION,
   SpsTg8DrvrGET_FIRMWARE_VERSION,
   SpsTg8DrvrSET_TIME_OUT,
   SpsTg8DrvrSET_SSC_HEADER,
   SpsTg8DrvrENABLE_SYNC,
   SpsTg8DrvrDISABLE_SYNC,
   SpsTg8DrvrENABLE_MODULE,
   SpsTg8DrvrDISABLE_MODULE,
   SpsTg8DrvrRESET_MODULE,
   SpsTg8DrvrINSTALL_MODULE,
   SpsTg8DrvrGET_CONFIGURATION,
   SpsTg8DrvrSIMULATE_PULSE,
   SpsTg8DrvrUSER_TABLE,
   SpsTg8DrvrRECORDING_TABLE,
   SpsTg8DrvrINTERRUPT_TABLE,
   SpsTg8DrvrHISTORY_TABLE,
   SpsTg8DrvrCLOCK_TABLE,
   SpsTg8DrvrAUX_TABLE,
   SpsTg8DrvrSC_INFO,
   SpsTg8DrvrTELEGRAM,
   SpsTg8DrvrTRACE_FIRMWARE,
   SpsTg8DrvrDATE_TIME,
   SpsTg8DrvrGET_RAW_STATUS,
   SpsTg8DrvrGET_STATUS,
   SpsTg8DrvrGET_DPRAM,
   SpsTg8DrvrRELOAD_FIRMWARE,
   SpsTg8DrvrRELOAD_ACTIONS,
   SpsTg8DrvrON_CLOSE,
   SpsTg8DrvrSET_SIGNAL,
   SpsTg8DrvrGET_SIGNAL,
   SpsTg8DrvrGET_QUEUE_LENGTH,
   SpsTg8DrvrPURGE_QUEUE,
   SpsTg8DrvrSET_ACTION_STATE,
   SpsTg8DrvrCLEAR_ACTION,
   SpsTg8DrvrWAIT_EVENT,
   SpsTg8DrvrFILTER_EVENT,
   SpsTg8DrvrGET_PPM_LINE,
   SpsTg8DrvrSET_OBJECT,
   SpsTg8DrvrREMOVE_OBJECT,
   SpsTg8DrvrGET_OBJECT,
   SpsTg8DrvrCONNECT,
   SpsTg8DrvrOBJECT_PARAM,
   SpsTg8DrvrOBJECTS_LIST,
   SpsTg8DrvrTEST_DPRAM,
   SpsTg8DrvrCARD_TEST,
} SpsTg8Drvr;

typedef struct {
   unsigned long Frame;
   unsigned short Control;
   unsigned short Delay;
} SpsTg8DrvrAction;

typedef struct {
   unsigned long Row;
   unsigned long Cnt;
} SpsTg8DrvrActionAddress;

typedef struct {
   unsigned long Row;
   unsigned long Cnt;
   SpsTg8DrvrAction Table[SpsTg8DrvrACTIONS];
} SpsTg8DrvrActionTable;

typedef struct {
   unsigned char RcvErr;	/* Value of the reception error register */
   unsigned char OvwrAct;	/* Which action was overwitten (if not 0x00) */
   unsigned char Act;		/* Which action was triggered and fired */
   unsigned char Sem;		/* Semaphore to solve the read/write conflicts */
} SpsTg8IntAction;

typedef struct {
   unsigned long Frame;		/* The trigger event frame */
   unsigned int Sc;		/* The Super Cycle number */
   unsigned int Occ;		/* Occurence time from the start of the last S-Cycle */
   unsigned int Out;		/* Output time from the start of the last S-Cycle */
   SpsTg8IntAction Ext;		/* Extra data concerning the interrupted action */
} SpsTg8Interrupt;

typedef struct {
   unsigned int Id;		/* Timing object identifier */
   unsigned long Frame;		/* Declared timing event (wildcards allowed) */
   SpsTg8Interrupt Inter;	/* Interrupt information */
   unsigned short Alarms;	/* The firmware alarms bit mask ORed with the driver alarms bit mask */
   unsigned char FwStat;	/* Firmware status */
   unsigned char DevMask;	/* Target devices bitmask */
} SpsTg8DrvrEvent;

typedef struct {
  unsigned int ScNumber;        /* The Super Cycle number */
  unsigned int ScLength;        /* The last completed S-Cycle length */
  unsigned int ScTime;          /* The current value of the S-Cycle time */
  unsigned int ScCounter;       /* Number of SC received since the last Reset */
} SpsTg8SuperCycleInfo;

typedef struct {
   int Machine;			/* Acc. machine number */
   unsigned short Data[SpsTg8DrvrGROUPS];	/* Telegram buffer */
} SpsTg8DrvrTelegram;		/* SPS driver telegram */

typedef struct {
  unsigned char  aYear,      /* The date */
		 aMonth,
		 aDay,
		 aSpare1;    /* 32-bits alignment is required */
  unsigned char  aRcvErr,    /* Value of the reception error register */
		 aHour,      /* The time */
		 aMinute,
		 aSecond;
  unsigned short aMilliSecond,
		 aMsDrift;   /* Drift between ms clock and second clock */
} SpsTg8DrvrDateTime;

typedef struct {
  SpsTg8DrvrDateTime Dt;     /* RcvErr, date, time */
  unsigned int       ScTime; /* Time in the S-Cycle */
  unsigned int       Epc;    /* Exception PC */
  unsigned short     Evo;    /* Exception Vector */
  unsigned short     Hw;     /* Hardware status */
  unsigned short     Fw;     /* Firmware status (RESERVED, NOT USED) */
  unsigned short     Cc;     /* Completion code */
  unsigned int       Am;     /* Alarms bitmask */
} SpsTg8DrvrStatusBlock;

typedef struct {
  int Status;
  int Alarms;
} SpsTg8Status;

typedef struct {
   unsigned long Event;
   unsigned long Matches;
} SpsTg8DrvrFilter;

/*
 * CTIM object bindings 
 */

#define SpsTg8DrvrCtimOBJECTS 1024

typedef struct {
   unsigned long EqpNum;
   unsigned long Frame;
} SpsTg8DrvrCtimBinding;

typedef struct {
   unsigned short Size;
   SpsTg8DrvrCtimBinding Objects[SpsTg8DrvrCtimOBJECTS];
} SpsTg8DrvrCtimObjects;

/*
 * PTIM object bindings 
 */

#define SpsTg8DrvrPtimOBJECTS 256

typedef struct {
   unsigned long EqpNum;
   unsigned char ModuleIndex;
   unsigned char Counter;
   unsigned short Size;
   unsigned short StartIndex;
} SpsTg8DrvrPtimBinding;

typedef struct {
   unsigned short Size;
   SpsTg8DrvrPtimBinding Objects[SpsTg8DrvrPtimOBJECTS];
} SpsTg8DrvrPtimObjects;

static SpsTg8DrvrCtimObjects *ctims = NULL;
static SpsTg8DrvrPtimObjects *ptims = NULL;
static int QFlag = 0;
static int TmOut = 20000000;
static SpsTg8DrvrActionTable *atabs = NULL;

/*
 * Control word bits Clock/CLK Disable/DIS Start/STR Counter/CNT Output/OUT Bus/BUS
 */

#define CW_BIT_MASK 0xC7C7

#define CW_CLK_MASK 0x0003
#define CW_DIS_MASK 0x0004
#define CW_STR_MASK 0x00C0
#define CW_CNT_MASK 0x0700
#define CW_OUT_MASK 0x4000
#define CW_BUS_MASK 0x8000

#define CW_CLK_BITN 0
#define CW_DIS_BITN 2
#define CW_STR_BITN 6
#define CW_CNT_BITN 8
#define CW_OUT_BITN 14
#define CW_BUS_BITN 15

#define CW_STR_CHAINED 0x0040
#define CW_STR_EXT1    0x0080
#define CW_CLK_EXT1    0x0002
#define CW_CLK_EXT2    0x0003

/*
 * ==================================================================== 
 * Keep copy of PTIM and CTIM equipments in shared memory so that all 
 * tasks can access them. Also keep the action tables here.  
 * ==================================================================== 
 */

TimLibError AttachMemory() {

   int shmkey, shmid;

   if (ctims == NULL) {
      shmkey = TgmGetKey("CTIMS");
      shmid = shmget(shmkey, sizeof(SpsTg8DrvrCtimObjects), IPC_CREAT | 0666);
      ctims = (SpsTg8DrvrCtimObjects *) shmat(shmid, NULL, 0);
      if ((int) ctims == -1) {
	 ctims = NULL;
	 return TimLibErrorNOMEM;
      }
   }
   if (timlib_debug)
      fprintf(stderr, "AttachMemory: CTIMS key:%d id:%d OK\n", shmkey, shmid);

   if (ptims == NULL) {
      shmkey = TgmGetKey("PTIMS");
      shmid = shmget(shmkey, sizeof(SpsTg8DrvrPtimObjects), IPC_CREAT | 0666);
      ptims = (SpsTg8DrvrPtimObjects *) shmat(shmid, NULL, 0);
      if ((int) ptims == -1) {
	 ptims = NULL;
	 return TimLibErrorNOMEM;
      }
   }
   if (timlib_debug)
      fprintf(stderr, "AttachMemory: PTIMS key:%d id:%d OK\n", shmkey, shmid);

   if (atabs == NULL) {
      shmkey = TgmGetKey("ATABS");
      shmid = shmget(shmkey, sizeof(SpsTg8DrvrActionTable) * SpsTg8DrvrMODULES, IPC_CREAT | 0666);
      atabs = (SpsTg8DrvrActionTable *) shmat(shmid, NULL, 0);
      if ((int) atabs == -1) {
	 atabs = NULL;
	 return TimLibErrorNOMEM;
      }
   }
   if (timlib_debug)
      fprintf(stderr, "AttachMemory: ATABS key:%d id:%d OK\n", shmkey, shmid);

   return TimLibErrorSUCCESS;
}

/*
 * ======================================================================== 
 * Open the SPS Tg8 driver for a module.  The SPS driver reserves sets 
 * of <CLIENTS_PER_MODULE> file nodes in /dev for up to <SpsTg8DrvrMODULES> 
 * Tg8 modules.  
 * ======================================================================== 
 */

static char fnm[32];

static int tg8s[SpsTg8DrvrMODULES] = { 0, 0, 0, 0 };	/* This global holds the SPS TG8 Driver file handle */

static int SpsTg8Open(int module) {

char *cp, *ep, ver[32];
unsigned long yr;
int i, m, fnum, fd;

   if ((module < 1) || (module > SpsTg8DrvrMODULES)) return 0;

   m = module - 1; if (tg8s[m] > 0) return tg8s[m];

   for (i = 0; i < SpsTg8DrvrCLIENTS_PER_MODULE; i++) {
      fnum = (m * SpsTg8DrvrCLIENTS_PER_MODULE) + i + 1;
      sprintf(fnm, "/dev/Tg8.%1d", fnum);
      fd = open(fnm, O_RDWR, 0);
      if (fd > 0) { tg8s[m] = fd;

	 if (timlib_debug)
	    fprintf(stderr,"SpsTg8Open: Opened driver file: %s Module: %d\n",fnm,m+1);

	 /*
	  * The CPS Tg8 driver returns a long version string <__DATE__ __TIME__> 
	  * while the SPS Tg8 driver returns a short version string <__DATE__> 
	  */

	 bzero((void *) ver, 32);
	 if (ioctl(tg8s[m], SpsTg8DrvrGET_FIRMWARE_VERSION, &ver) < 0) {
	    perror("SpsTg8Open");
	    ver[0] = 0;
	 }
	 if ((strlen(ver) > 0) && (strlen(ver) < (strlen(__DATE__) + 4))) {	/* Is it an SPS TG8 ? */
	    cp = &(ver[6]); /* Points to the year string */
	    yr = strtoul(cp,&ep,10);
	    if (yr < 2005) {
	       fprintf(stderr,"Found old SL_TG8 Firmware Version: %s Updating...\n",ver);
	       system("/usr/local/tim/reload_sl_tg8");
	       ioctl(tg8s[m], SpsTg8DrvrGET_FIRMWARE_VERSION, &ver);
	    }
	    fprintf(stderr,"Using SL_TG8 Firmware Version: %s\n",ver);
	    return tg8s[m];	/* Yes */
	 }
	 close(tg8s[m]);
	 tg8s[m] = 0;		/* No it a PS TG8 */
	 return 0;		/* No point in continuing */
      }
   }
   return 0;
}

/*
 * ======================================================================== 
 * Write an action to a module 
 * If anum is zero I make a new action if it dosn't exist already.  
 * Else anum is overwritten by clear and write.  
 * ======================================================================== 
 */

TimLibError SpsTg8WriteAction(SpsTg8DrvrAction * ap, int anum, int m) {

SpsTg8DrvrActionAddress ad;
int i, clear;

   ap->Control &= CW_BIT_MASK;  /* Remove spurious bits */

   if (anum) {			/* Clear action ? */
      clear = 1;
      atabs[m].Table[anum - 1] = *ap;
   } else {
      clear = 0;
      for (i = 0; i < SpsTg8DrvrACTIONS; i++) {
	 if (   (atabs[m].Table[i].Frame   == ap->Frame)
	     && (atabs[m].Table[i].Control == ap->Control)
	     && (atabs[m].Table[i].Delay   == ap->Delay)  ) {
	    anum = i + 1;
	    break;
	 }
      }
      if (anum == 0) {
	 for (i = 0; i < SpsTg8DrvrACTIONS; i++) {
	    if (atabs[m].Table[i].Frame == 0) {	/* Make a new action */
	       anum = i + 1;
	       atabs[m].Table[anum - 1] = *ap;
	       break;
	    }
	 }
      }
   }
   if (anum == 0) return TimLibErrorNOMEM;

   if (timlib_debug) {
      fprintf(stderr,
	      "SpsTg8WriteAction: Writing: Frame: 0x%08X Control: 0x%08X Delay: %d\n",
	      (int) ap->Frame, (int) ap->Control, (int) ap->Delay);
      fprintf(stderr, "SpsTg8WriteAction: To module: %d Action row: %d\n", (int) m + 1, (int) anum);
   }

   if (clear) {
      ad.Row = anum;
      ad.Cnt = 1;
      if (ioctl(tg8s[m], SpsTg8DrvrCLEAR_ACTION, &ad) < 0) {
	 perror("Tg8SpsLibInitialize");
	 return TimLibErrorIO;
      }
   }
   if (write(tg8s[m], ap, sizeof(SpsTg8DrvrAction)) <= 0) {
      perror("SpsTg8WriteAction");
      return TimLibErrorIO;
   }
   return TimLibErrorSUCCESS;
}

/*
 * ======================================================================== 
 * Force a write back of all actions to the Tg8s from shared memory.  
 * This can be usefull when other non TimLib application have done things 
 * to the user table, or you just want a reset.  
 * ======================================================================== 
 */

TimLibError SpsTg8WriteAllActions() {

int i, m;
TimLibError err;
SpsTg8DrvrActionAddress ad;

   ad.Row = 1;
   ad.Cnt = 255;

   for (m = 0; m < SpsTg8DrvrMODULES; m++) {
      if (tg8s[m] > 0) {
	 if (ioctl(tg8s[m], SpsTg8DrvrCLEAR_ACTION, &ad) < 0) {
	    perror("Tg8SpsLibInitialize");
	    return TimLibErrorIO;
	 }
	 for (i = 0; i < SpsTg8DrvrACTIONS; i++) {
	    if (atabs[m].Table[i].Frame == 0)
	       break;
	    err = SpsTg8WriteAction(&(atabs[m].Table[i]), i + 1, m);
	    if (err != TimLibErrorSUCCESS)
	       return err;
	 }
	 fprintf(stderr, "SpsTg8WriteAllActions: All written to Module:%d\n", m + 1);
      }
   }
   return TimLibErrorSUCCESS;
}

/*
 * ======================================================================== 
 * Wipe out all memory CTIMS/PTIMS/Actions 
 * Start with a clean slate, this can be usefull during debugging.  
 * ======================================================================== 
 */

TimLibError SpsTg8WipeMemory() {

int m;
SpsTg8DrvrActionAddress ad;

   ad.Row = 1;
   ad.Cnt = 255;

   bzero((void *) ctims, sizeof(SpsTg8DrvrCtimObjects));
   bzero((void *) ptims, sizeof(SpsTg8DrvrPtimObjects));

   for (m = 0; m < SpsTg8DrvrMODULES; m++) {
      bzero((void *) &atabs[m], sizeof(SpsTg8DrvrActionTable));
      if (tg8s[m] > 0) {
	 if (ioctl(tg8s[m], SpsTg8DrvrCLEAR_ACTION, &ad) < 0) {
	    perror("Tg8SpsLibInitialize");
	    return TimLibErrorIO;
	 }
	 fprintf(stderr, "SpsTg8WipeMemory: Module:%d Memory Wiped clean OK\n", m + 1);
      }
   }
   return TimLibErrorSUCCESS;
}

/*
 * ======================================================================== 
 * Read an action from shared memory, I never read back from the TG8 as it 
 * can return garbage in the control word. I need a real reference for what 
 * should be in the modules user table.  
 * ======================================================================== 
 */

TimLibError SpsTg8ReadAction(SpsTg8DrvrAction * ap, int anum, int m) {

   *ap = atabs[m].Table[anum - 1];
   if ((ap->Control & 0xF000) == 0) {
      if (timlib_debug) {
	 fprintf(stderr,
		 "SpsTg8ReadAction: Read: Frame: 0x%08X Control: 0x%08X Delay: %d\n",
		 (int) ap->Frame, (int) ap->Control, (int) ap->Delay);
	 fprintf(stderr, "SpsTg8ReadAction: From module: %d Action row: %d\n", (int) m + 1, (int) anum);
      }
   }
   return TimLibErrorSUCCESS;
}

/*
 * ==================================================================== 
 * This routine could have been hidden from the user of the Timing lib, 
 * however, in some circumstances, the initialization can take several 
 * minutes to complete. Hence I have decided to make an initialization 
 * routine publicly available, and force users to call it.  
 * This routine performs the following initialization functions...  
 * 1) Opens a connection to the driver 
 * 2) Checks the Firmware/VHDL version against the latest revision 
 * Some EProms/FPGAs may need updating, this takes a while.  
 * 3) Load all relavent CTIM and PTIM definitions if needed.  
 *
 * Special behaviour for the SPS TG8 version before calling this.  
 * The debug variable "timlib_debug" can be set from TimLibSetDebug 
 * When its not zero, error printing is turned on, so lots of messages. 
 * When its equal to 2, the Tg8 module is reinitialized from the shared 
 * memory segments to force its state to be as in the library.  
 * When its equal to 3, all memory is wiped clean, and all actions in 
 * the Tg8 modules are cleared.  
 */

TimLibError Tg8SpsLibInitialize(TimLibDevice device) { /* Initialize hardware/software */

int m, ok, module;
TimLibError err;

   if ((device == TimLibDevice_ANY) || (device == TimLibDevice_TG8_SPS)) {

      ok = 0;
      for (module = 1; module <= SpsTg8DrvrMODULES; module++) {
	 if (SpsTg8Open(module) != 0) {
	    ok = 1;
	    m = module - 1;
	    if ((timlib_enable) && (ioctl(tg8s[m], SpsTg8DrvrENABLE_MODULE, &timlib_enable) < 0)) {
	       close(tg8s[m]);
	       tg8s[m] = 0;
	       perror("SpsTg8LibInitialize");
	       return TimLibErrorIO;
	    }
	 }
      }
      if (ok) {
	 err = AttachMemory();
	 if (err != TimLibErrorSUCCESS) return err;
	 if (timlib_debug == 2) err = SpsTg8WriteAllActions();
	 if (err != TimLibErrorSUCCESS) return err;
	 if (timlib_debug == 3) err = SpsTg8WipeMemory();
	 return err;
      } else return TimLibErrorOPEN;
   }
   return TimLibErrorINIT;
}

/* ====== */

int Tg8SpsLibFdInitialize(TimLibDevice device) { /* Initialize hardware/software */

TimLibError er;

   if (tg8s[0] == 0) {
       er = Tg8SpsLibInitialize(device);
       if (er != TimLibErrorSUCCESS) return 0;
   }
   return tg8s[0];
}

/*
 * ==================================================================== 
 * The SL Tg8 driver returns all enabled interrupt to every client
 * so I need to throw away unwanted interrupts.
 * Get a connection made here
 */

#define MAX_CONNECTIONS 32

static unsigned long CtimCons[MAX_CONNECTIONS];
static unsigned long PtimCons[MAX_CONNECTIONS];

static int ClearConnect = 1;

int GetConnection(unsigned long equip, TimLibClass iclss) {
int i;
unsigned long *cons;

   if (ClearConnect) {

      ClearConnect = 0;

      bzero((void *) CtimCons, MAX_CONNECTIONS*sizeof(unsigned long));
      bzero((void *) PtimCons, MAX_CONNECTIONS*sizeof(unsigned long));
      return 0;
   }

   if      (iclss == TimLibClassCTIM) cons = CtimCons;
   else if (iclss == TimLibClassPTIM) cons = PtimCons;
   else    return 0;

   for (i=0; i<MAX_CONNECTIONS; i++) {
      if (cons[i] == 0) break;
      if (cons[i] == equip) return i+1;
   }
   return 0;
}

/*
 * ==================================================================== 
 * Remember the connection
 */

int SetConnection(unsigned long equip, TimLibClass iclss) {
int idx, i;
unsigned long *cons;

   if      (iclss == TimLibClassCTIM) cons = CtimCons;
   else if (iclss == TimLibClassPTIM) cons = PtimCons;
   else    return 0;

   if (equip == 0) ClearConnect = 1;

   idx = GetConnection(equip,iclss);
   if (idx != 0) return idx;            /* Already connected */

   for (i=0; i<MAX_CONNECTIONS; i++) {
      if (cons[i] == 0) {
	 cons[i] = equip;
	 return i+1;
      }
   }
   return 0;
}

/*
 * ==================================================================== 
 * Connect to an interrupt. If you are connecting to either a CTIM 
 * interrupt or to a hardware interrupt, you may need to specify on 
 * which device the interrupt should be connected. This is achieved by 
 * the module parameter. If the module is zero, the system will decide 
 * which device to use, otherwise module contains a value between 1 and 
 * the number of installed timing receiver cards. For PTIM objects the 
 * module parameter must be set to zero or the real module on which the 
 * PTIM object is implemented. On PTIM objects the module is implicit.  
 */

TimLibError Tg8SpsLibConnect(TimLibClass iclss,      /* Class of interrupt */
			     unsigned long equip,    /* Equipment or hardware mask */
			     unsigned long module) { /* For HARD or CTIM classes */
int i, m;
SpsTg8DrvrCtimBinding *ctimp;
SpsTg8DrvrPtimBinding *ptimp;
SpsTg8DrvrAction act;
SpsTg8DrvrFilter ftr;
TimLibError err;

   if (module > SpsTg8DrvrMODULES) return TimLibErrorMODULE;
   m = 0; if (module) m = module - 1;

   if (tg8s[m] <= 0) return TimLibErrorMODULE;

   if (iclss == TimLibClassCTIM) {

      if (timlib_debug)
	 fprintf(stderr, "Tg8SpsLibConnect: To Ctim:%d on Module:%d\n", (int) equip, (int) m + 1);

      for (i = 0; i < ctims->Size; i++) {
	 ctimp = &(ctims->Objects[i]);
	 if (ctimp->EqpNum == equip) {
	    act.Frame = ctimp->Frame;
	    act.Control = CW_BUS_MASK;
	    act.Delay = 0;
	    SetConnection(ctimp->EqpNum,TimLibClassCTIM);
	    err = SpsTg8WriteAction(&act, 0, m);
	    if (err != TimLibErrorSUCCESS) return err;
	    ftr.Event = act.Frame | 0x00FFFFFF;
	    if (ioctl(tg8s[m],SpsTg8DrvrFILTER_EVENT,&ftr) < 0) {
	       perror("Tg8SpsLibConnect");
	       return TimLibErrorIO;
	    }
	    return TimLibErrorSUCCESS;
	 }
      }
      return TimLibErrorCTIM;
   }

   else if (iclss == TimLibClassPTIM) {
      for (i = 0; i < ptims->Size; i++) {
	 ptimp = &(ptims->Objects[i]);
	 if (ptimp->EqpNum == equip) {
	    if (!module) m = ptimp->ModuleIndex;

	    if (timlib_debug) fprintf(stderr,
				      "Tg8SpsLibConnect: To Ptim:%d on Module:%d\n",
				      (int) equip,
				      (int) m + 1);

	    if (ptimp->ModuleIndex != m) return TimLibErrorMODULE;
	    err = SpsTg8ReadAction(&act, ptimp->StartIndex + 1, m);
	    if (err != TimLibErrorSUCCESS) return err;
	    SetConnection(ptimp->EqpNum,TimLibClassPTIM);
	    if (!(act.Control & CW_BUS_MASK)) {
	       act.Control |= CW_BUS_MASK;
	       err = SpsTg8WriteAction(&act, ptimp->StartIndex + 1, m);
	       if (err != TimLibErrorSUCCESS) return err;
	    }
	    ftr.Event = act.Frame | 0x00FFFFFF;
	    if (ioctl(tg8s[m],SpsTg8DrvrFILTER_EVENT,&ftr) < 0) {
	       perror("Tg8SpsLibConnect");
	       return TimLibErrorIO;
	    }
	    if (ftr.Matches == 0) return TimLibErrorCONNECT;
	    return TimLibErrorSUCCESS;
	 }
      }
      return TimLibErrorPTIM;
   }
   return TimLibErrorNOT_IMP;
}

/* ====== */

TimLibError Tg8SpsLibFdConnect(int         fd,         /* File descriptor */
			       TimLibClass iclss,      /* Class of interrupt */
			       unsigned long equip,    /* Equipment or hardware mask */
			       unsigned long module) { /* For HARD or CTIM classes */

   return Tg8SpsLibConnect(iclss,equip,module);
}

/* ==================================================================== */
/* Disconnect from an interrupt                                         */

TimLibError Tg8SpsLibDisConnect(TimLibClass iclss,      /* Class of interrupt */
				unsigned long equip,    /* Equipment or hardware mask */
				unsigned long module) { /* For HARD or CTIM classes */

   return TimLibErrorNOT_IMP;
}

/*
 * ==================================================================== 
 * Set queueing On or Off, and the time out value in micro seconds.  
 * A timeout value of zero means no time out, you wait for ever.  
 */

TimLibError Tg8SpsLibQueue(unsigned long qflag,   /* 0=>Queue, 1=>NoQueue */
			   unsigned long tmout) { /* 0=>No time outs */

   QFlag = qflag;
   TmOut = tmout;

   return TimLibErrorSUCCESS;
}

/* ====== */

TimLibError Tg8SpsLibFdQueue(int           fd,      /* File descriptor */
			     unsigned long qflag,   /* 0=>Queue, 1=>NoQueue */
			     unsigned long tmout) { /* 0=>No time outs */
   return Tg8SpsLibQueue(qflag,tmout);
}

/*
 * ====================================================================
 * To know if a call to wait will block, this call returns the Queue
 * size. If the size iz greater than zero a call to wait will not block
 * and return without waiting. If the qflag is set to NoQueue, zero is
 * allways returned and all calls to wait will block.
 */

unsigned long Tg8SpsLibGetQueueSize() {

unsigned long qsize;

   if (ioctl(tg8s[0], SpsTg8DrvrGET_QUEUE_LENGTH, &qsize) < 0) return 0;
   return qsize;
}

/*
 * ==================================================================== 
 * Wait for an interrupt. The parameters are all returned from the call 
 * so you can know which interrupt it was that came back. Note, when 
 * waiting for a hardware interrupt from either CTIM or from a counter, 
 * it is the CTIM or PTIM object that caused the interrupt returned.  
 * The telegram will have been read already by the high prioity task 
 * get_tgm_tg8/tg8, be aware of the race condition here, hence payload. 
 * This routine is a blocking call, it waits for interrupt or timeout.  
 * Any NULL argument is permitted, and no value will be returned.  
 *
 * Arguments: 
 * iclss: The class of the interrupt CTIM, PTIM, or hardware 
 * equip: The PTIM, CTIM equipment, or hardware mask 
 * plnum: If class is PTIM this is the PLS line number 
 * source: The hardware source of the interrupt 
 * onzero: The time of the interrupt 
 * trigger: The arrival time of the event that triggered the action 
 * start: The time the start of the counter occured 
 * ctim: The CTIM equipment number of the triggering event 
 * payload: The payload of the triggering event 
 * module: The module number 1..n of the timing receiver card 
 * missed: The number of missed events since the last wait 
 * qsize: The number of remaining interrupts on the queue 
 */

TimLibError Tg8SpsLibWait(TimLibClass * iclass,     /* Class of interrupt */
			  unsigned long *equip,     /* PTIM CTIM or hardware mask */
			  unsigned long *plnum,     /* Ptim line number 1..n or 0 */
			  TimLibHardware * source,  /* Hardware source of interrupt */
			  TimLibTime * onzero,      /* Time of interrupt/output */
			  TimLibTime * trigger,     /* Time of counters load */
			  TimLibTime * start,       /* Time of counters start */
			  unsigned long *ctim,      /* CTIM trigger equipment ID */
			  unsigned long *payload,   /* Payload of trigger event */
			  unsigned long *module,    /* Module that interrupted */
			  unsigned long *missed,    /* Number of missed interrupts */
			  unsigned long *qsize,     /* Remaining interrupts on queue */
			  unsigned long *machine) { /* Tgm Machine */

SpsTg8DrvrEvent rbuf, orbuf;
SpsTg8DrvrAction *actp;
SpsTg8DrvrActionTable atab;
SpsTg8DrvrPtimBinding *ptimp;
SpsTg8DrvrCtimBinding *ctimp;

fd_set rdset;
struct timeval tv;
struct timeval *ptv;
struct timezone tz;
int i, m, cnt, cc, found;

TimLibClass xclass = TimLibClassHARDWARE;
unsigned long xequip = 0;
unsigned long xplnum = 0;
TimLibHardware xsource = TimLibHardwareCTIM;
TimLibTime xonzero = { 0, 0, 0, TgmMACHINE_NONE };
TimLibTime xtrigger = { 0, 0, 0, TgmMACHINE_NONE };
TimLibTime xstart = { 0, 0, 0, TgmMACHINE_NONE };
unsigned long xctim = 0;
unsigned long xpayload = 0;
unsigned long xmodule = 0;
unsigned long xmissed = 0;
unsigned long xqsize = 0;
unsigned long xmachine = 0;
TimLibError err;

   cnt = 0;
   FD_ZERO(&rdset);
   for (m = 0; m < SpsTg8DrvrMODULES; m++) {
      if (tg8s[m] > 0) {
	 if (QFlag) ioctl(tg8s[m], SpsTg8DrvrPURGE_QUEUE, NULL);
	 FD_SET(tg8s[m], &rdset);
	 cnt++;
      }
   }
   if (cnt == 0) return TimLibErrorINIT;

   if (TmOut) {
      ptv = &tv;
      tv.tv_sec = TmOut / 1000000;
      tv.tv_usec = TmOut % 1000000;
   } else
      ptv = NULL;

   tz.tz_minuteswest = 0;
   tz.tz_dsttime = 0;

   while(1) {

      cc  = select(cnt, &rdset, NULL, NULL, ptv);
      if (cc  == 0) return TimLibErrorTIMEOUT;

      xmodule = 0;
      for (m = 0; m < SpsTg8DrvrMODULES; m++) {
	 if ((tg8s[m] > 0) && (FD_ISSET(tg8s[m], &rdset))) {
	    xmodule = m + 1;
	    if (timlib_debug) fprintf(stderr,"Tg8SpsLibWait: Select data on module: %d\n",m+1);
	 }
	 break;
      }
      if (xmodule == 0) return TimLibErrorTIMEOUT;

      bcopy((void *) &rbuf, (void *) &orbuf, sizeof(SpsTg8DrvrEvent));
      bzero((void *) &rbuf, sizeof(SpsTg8DrvrEvent));
      cc = read(tg8s[m], &rbuf, sizeof(SpsTg8DrvrEvent));
      err = TimLibGetTime(1,&xonzero);
      if (cc <= 0) {
	 perror("Tg8SpsLibWait");
	 return TimLibErrorIO;

      } else {

	 if (timlib_debug) {
	    fprintf(stderr,"Tg8SpsLibWait: Testing: Frm:0x%08X Out:%05d Occ:%05d\n",
		    (int) rbuf.Inter.Frame,
		    (int) rbuf.Inter.Out,
		    (int) rbuf.Inter.Occ);
	 }

#ifdef THROW_AWAY_REPEATS
	 if ((rbuf.Inter.Frame == orbuf.Inter.Frame)
	 &&  (rbuf.Inter.Out   == orbuf.Inter.Out)
	 &&  (rbuf.Inter.Occ   == orbuf.Inter.Occ)) continue;
#endif
	 ioctl(tg8s[m], SpsTg8DrvrGET_QUEUE_LENGTH, &xqsize);
	 xmissed = 0;
	 if (xqsize >= 128) xmissed = 1;

	 bzero((void *) &atab, sizeof(SpsTg8DrvrActionTable));
	 atab.Row = rbuf.Inter.Ext.Act;
	 atab.Cnt = 1;
	 actp = &(atab.Table[0]);
	 if (ioctl(tg8s[m], SpsTg8DrvrUSER_TABLE, &atab) < 0) {
	    perror("Tg8SpsLibWait");
	    return TimLibErrorIO;
	 }
	 actp->Control &= CW_BIT_MASK;
	 if (actp->Control == CW_BUS_MASK) xclass = TimLibClassCTIM;
	 else                              xclass = TimLibClassPTIM;

	 if (timlib_debug) {
	    fprintf(stderr,"Tg8SpsLibWait: Control Word:0x%08X: Hence class:%d\n",
		   (int) actp->Control,
		   (int) xclass);
	 }

	 xmachine = (rbuf.Inter.Frame & 0xF0000000) >> 28;
	 xmachine = TgvTgvToTgmMachine(xmachine);

	 xpayload = rbuf.Inter.Frame & 0xFFFF;

	 xonzero.CTrain = rbuf.Inter.Out;
	 xonzero.Machine = xmachine;

	 xstart = xtrigger = xonzero;
	 xtrigger.CTrain = rbuf.Inter.Occ;

	 found = 0;
	 for (i = 0; i < ctims->Size; i++) {
	    ctimp = &(ctims->Objects[i]);
	    if ((ctimp->Frame     & 0xFFFF0000)
	    ==  (rbuf.Inter.Frame & 0xFFFF0000)) {
	       xequip = xctim = ctimp->EqpNum;
	       xsource = TimLibHardwareCTIM;
	       found = 1;
	       break;
	    }
	 }
	 if (!found) continue;

	 if (xclass == TimLibClassCTIM) {
	    if (!GetConnection(ctimp->EqpNum,TimLibClassCTIM)) {
	       continue;
	    }
	 } else if (xclass == TimLibClassPTIM) {
	    found = 0;
	    for (i = 0; i < ptims->Size; i++) {
	       ptimp = &(ptims->Objects[i]);
	       if ((atab.Row >= ptimp->StartIndex) && (atab.Row < ptimp->StartIndex + ptimp->Size + 1)) {
		  found = 1;
		  xequip = ptimp->EqpNum;
		  xmodule = ptimp->ModuleIndex + 1;
		  xplnum = 1;
		  xsource = ptimp->Counter;
		  break;
	       }
	    }
	    if (!found) continue;
	    if (!GetConnection(ptimp->EqpNum,TimLibClassPTIM)) continue; /* Not for me discard interrupt */
	 }
      }
      break;
   }

   if (iclass)  *iclass  = xclass;
   if (equip)   *equip   = xequip;
   if (plnum)   *plnum   = xplnum;
   if (source)  *source  = xsource;
   if (onzero)  *onzero  = xonzero;
   if (trigger) *trigger = xtrigger;
   if (start)   *start   = xstart;
   if (ctim)    *ctim    = xctim;
   if (payload) *payload = xpayload;
   if (module)  *module  = xmodule;
   if (missed)  *missed  = xmissed;
   if (qsize)   *qsize   = xqsize;
   if (machine) *machine = xmachine;

   return TimLibErrorSUCCESS;
}

/* ====== */

TimLibError Tg8SpsLibFdWait(int fd,                   /* File descriptor */
			    TimLibClass * iclass,     /* Class of interrupt */
			    unsigned long *equip,     /* PTIM CTIM or hardware mask */
			    unsigned long *plnum,     /* Ptim line number 1..n or 0 */
			    TimLibHardware * source,  /* Hardware source of interrupt */
			    TimLibTime * onzero,      /* Time of interrupt/output */
			    TimLibTime * trigger,     /* Time of counters load */
			    TimLibTime * start,       /* Time of counters start */
			    unsigned long *ctim,      /* CTIM trigger equipment ID */
			    unsigned long *payload,   /* Payload of trigger event */
			    unsigned long *module,    /* Module that interrupted */
			    unsigned long *missed,    /* Number of missed interrupts */
			    unsigned long *qsize,     /* Remaining interrupts on queue */
			    unsigned long *machine) { /* Tgm Machine */

   return Tg8SpsLibWait(iclass,equip,plnum,source,onzero,trigger,start,ctim,payload,module,missed,qsize,machine);
}

/*
 * ==================================================================== 
 * Set the Ccv of a PTIM equipment. Note neither the counter number nor 
 * the trigger condition can be changed.  
 */

TimLibError Tg8SpsLibSet(unsigned long ptim,	/* PTIM to write to */
			 unsigned long plnum,	/* Ptim line number 1..n or 0 */
			 unsigned long grnum,	/* Tgm group number or Zero */
			 unsigned long grval,	/* Group value if num not zero */
			 TimLibCcvMask ccvm,	/* Which values to write */
			 TimLibCcv * ccv) {     /* Current control value */

int i, m, msk, cntr, found;
SpsTg8DrvrPtimBinding *ptimp;
SpsTg8DrvrAction act;
TimLibError err;

   found = 0;
   for (i = 0; i < ptims->Size; i++) {
      ptimp = &(ptims->Objects[i]);
      if (ptimp->EqpNum == ptim) {
	 m = ptimp->ModuleIndex;
	 if (tg8s[m] <= 0) return TimLibErrorMODULE;
	 cntr = ptimp->Counter & 0x7;
	 err = SpsTg8ReadAction(&act, ptimp->StartIndex + 1, m);
	 if (err != TimLibErrorSUCCESS) return err;
	 found = 1;
	 break;
      }
   }
   if (!found) return TimLibErrorPTIM;

   if ((grnum) || (plnum > 1)) return TimLibErrorPPM;    /* No PPM allowed */

   msk = 1;
   do {
      if (ccvm & msk) {
	 act.Control &= ~CW_CNT_MASK;
	 act.Control |= cntr << CW_CNT_BITN;
	 switch ((TimLibCcvMask) msk) {
	 case TimLibCcvMaskENABLE:
	    if (ccv->Enable & TimLibEnableOUT) {
	       act.Control |=  CW_OUT_MASK;
	       act.Control &= ~CW_DIS_MASK;
	    } else
	       act.Control |=  CW_DIS_MASK;
	    break;

	 case TimLibCcvMaskSTART:
	    if (ccv->Start == TimLibStartNORMAL) {
	       act.Control &= ~CW_STR_MASK;
	    } else if (ccv->Start == TimLibStartCHAINED) {
	       act.Control &= ~CW_STR_MASK;
	       act.Control |=  CW_STR_CHAINED;
	    } else if (ccv->Start == TimLibStartEXT1) {
	       act.Control &= ~CW_STR_MASK;
	       act.Control |=  CW_STR_EXT1;
	    } else {
	       return TimLibErrorSTART;
	    }
	    break;

	 case TimLibCcvMaskCLOCK:
	    if (ccv->Clock == TimLibClock1KHZ) {
	       act.Control &= ~CW_CLK_MASK;
	    } else if (ccv->Clock == TimLibClockEXT1) {
	       act.Control &= ~CW_CLK_MASK;
	       act.Control |=  CW_CLK_EXT1;
	    } else if (ccv->Clock == TimLibClockEXT2) {
	       act.Control &= ~CW_CLK_MASK;
	       act.Control |=  CW_CLK_EXT2;
	    } else
	       return TimLibErrorCLOCK;
	    break;

	 case TimLibCcvMaskCTIM:
	    found = 0;
	    if (ccv->Ctim == 0) ccv->Ctim = ctims->Objects[0].EqpNum;
	    for (i = 0; i < ctims->Size; i++) {
	       if (ctims->Objects[i].EqpNum == ccv->Ctim) {
		  act.Frame = ctims->Objects[i].Frame;
		  act.Control = CW_OUT_MASK | (cntr << CW_CNT_BITN);
		  act.Delay = 1;
		  found = 1;
		  break;
	       }
	    }
	    if (!found)
	       return TimLibErrorCTIM;
	    break;

	 case TimLibCcvMaskPAYLOAD:
	    act.Frame &= 0xFFFF0000;
	    act.Frame |= (ccv->Payload & 0xFFFF);
	    break;

	 case TimLibCcvMaskDELAY:
	    act.Delay = ccv->Delay;
	    break;

	 case TimLibCcvMaskMODE:
	 case TimLibCcvMaskOMASK:
	 case TimLibCcvMaskPWIDTH:
	 case TimLibCcvMaskPOLARITY:
	    return TimLibErrorNOT_IMP;

	 case TimLibCcvMaskMACHINE:
	 case TimLibCcvMaskGRNUM:
	 case TimLibCcvMaskGRVAL:
	    return TimLibErrorPPM;

	 default:
	    break;
	 }
      }
      msk <<= 1;
   }
   while (msk & TimLibCcvMaskBITS);

   return SpsTg8WriteAction(&act, ptimp->StartIndex + 1, m);
}

/*
 * ==================================================================== 
 * Get the Ccv of a PTIM equipment.  
 */

TimLibError Tg8SpsLibGet(unsigned long ptim,
			 unsigned long plnum, /* Ptim line number 1..n or 0 */
			 unsigned long grnum,
			 unsigned long grval,
			 TimLibCcvMask *ccvm, /* Valid fields in ccv */
			 TimLibCcv *ccv) {

int i, m, found;
SpsTg8DrvrPtimBinding *ptimp;
SpsTg8DrvrAction act;
TimLibError err;

   bzero((void *) ccv, sizeof(TimLibCcv));
   if ((grnum) || (plnum > 1))
      return TimLibErrorPPM;

   found = 0;
   for (i = 0; i < ptims->Size; i++) {
      ptimp = &(ptims->Objects[i]);
      if (ptimp->EqpNum == ptim) {
	 m = ptimp->ModuleIndex;
	 if (tg8s[m] <= 0) return TimLibErrorMODULE;
	 err = SpsTg8ReadAction(&act, ptimp->StartIndex + 1, m);
	 if (err != TimLibErrorSUCCESS)
	    return err;
	 found = 1;
	 break;
      }
   }
   if (!found)
      return TimLibErrorPTIM;

   *ccvm = TimLibCcvMaskENABLE
	 | TimLibCcvMaskSTART
	 | TimLibCcvMaskCLOCK
	 | TimLibCcvMaskDELAY
	 | TimLibCcvMaskCTIM
	 | TimLibCcvMaskPAYLOAD;

						   ccv->Enable  = TimLibEnableNOOUT;
   if ((act.Control & CW_DIS_MASK) == 0)           ccv->Enable |= TimLibEnableOUT;
   if  (act.Control & CW_BUS_MASK)                 ccv->Enable |= TimLibEnableBUS;

   if (act.Control & CW_STR_CHAINED)               ccv->Start   = TimLibStartCHAINED;
   if (act.Control & CW_STR_EXT1)                  ccv->Start   = TimLibStartEXT1;

   if ((act.Control & CW_CLK_MASK) == 0)           ccv->Clock   = TimLibClock1KHZ;
   if ((act.Control & CW_CLK_MASK) == CW_CLK_EXT1) ccv->Clock   = TimLibClockEXT1;
   if ((act.Control & CW_CLK_MASK) == CW_CLK_EXT2) ccv->Clock   = TimLibClockEXT2;

   ccv->Delay = act.Delay;
   ccv->Payload = act.Frame & 0xFFFF;

   found = 0;
   for (i = 0; i < ctims->Size; i++) {
      if ((0xFFFF0000 & ctims->Objects[i].Frame) == (0xFFFF0000 & act.Frame)) {
	 ccv->Ctim = ctims->Objects[i].EqpNum;
	 found = 1;
	 break;
      }
   }
   if (!found) return TimLibErrorCTIM;

   return TimLibErrorSUCCESS;
}

/*
 * ==================================================================== 
 * By writing to the driver this call simulates an interrupt for the 
 * connected clients. Also it can be used as a way of synchronizing 
 * processes, this is especially important in Linux systems where the 
 * schedular is not preemptive.  
 *
 * Arguments: 
 * xclass: Class of interrupt to simulate, PTIM, CTIM or Hardware 
 * equip: Equipment number for PTIM or CTIM, hardware mask for Hardware 
 * module: When class is CTIM or Hardware, the module number is used 
 * machine: Telegram ID is used for PTIM interrupts if grnum is not zero 
 * grnum: If zero, no telegram checking, else the PTIM triggers group number 
 * grval: The telegram group value for the PTIM trigger 
 */

TimLibError Tg8SpsLibSimulate(TimLibClass xclass,
		  unsigned long equip,
		  unsigned long module,
		  TgmMachine machine,
		  unsigned long grnum,
		  unsigned long grval) {

   return TimLibErrorNOT_IMP;
}

/*
 * ==================================================================== 
 * On the SPS Tg8 I can at least output a pulse.  
 */

TimLibError Tg8SpsLibRemoteControl(unsigned long remflg, /* 0 = Normal, 1 = Remote */
				   unsigned long module, /* Module or zero */
				   unsigned long cntr,   /* 1..8 counter number */
				   TimLibRemote rcmd,    /* Command */
				   TimLibCcvMask ccvm,   /* Fields to be set */
				   TimLibCcv * ccv) {    /* Value to load in counter */

int msk, m;

   if (rcmd == TimLibRemoteOUT) {
      msk = (1 << cntr) & 0xFF;
      m = 0;
      if (module)
	 m = module - 1;
      if (tg8s[m] > 0) {
	 if (ioctl(tg8s[m], SpsTg8DrvrSIMULATE_PULSE, &msk) < 0) {
	    perror("Tg8SpsLibRemoteControl");
	    return TimLibErrorIO;
	 }
	 if (timlib_debug)
	    fprintf(stderr, "Tg8SpsLibRemoteControl: Output pulse on Counter:%d Module:%d\n", (int) cntr, (int) module);
      }
   }
   return TimLibErrorNO_REMOTE;
}

/*
 * ====================================================================
 * Get a counters remote configuration
 */

TimLibError Tg8SpsLibGetRemote(unsigned long module,
			       unsigned long cntr,
			       unsigned long *remflg,
			       TimLibCcvMask *ccvm,
			       TimLibCcv     *ccv) {

   return TimLibErrorNOT_IMP;
}

/*
 * ==================================================================== 
 * As the SPS TG8 is unable for the present to respond to the UTC time 
 * event codes B5 & B6, I will just read the system time.  
 */

#define Tg8NS_IN_SEC 1000000000    /* Ns in one second 10^9 */
#define Tg8NS_ONE_MS 1000000       /* Ns in two millisecond 1 x 10^6 */

TimLibError Tg8SpsLibGetTime(unsigned long module,	/* Module number to read from */
			     TimLibTime * utc) {        /* Returned time value */

SpsTg8DrvrDateTime dt;
SpsTg8SuperCycleInfo sc;
struct tm mtm;
time_t tod;
int m;

   m = 0; if (module) m = module - 1;
   if (tg8s[m] <= 0) return TimLibErrorMODULE;
   if (ioctl(tg8s[m],SpsTg8DrvrDATE_TIME,&dt) < 0) return TimLibErrorIO;

   mtm.tm_sec   = UBCD(dt.aSecond);
   mtm.tm_min   = UBCD(dt.aMinute);
   mtm.tm_hour  = UBCD(dt.aHour);
   mtm.tm_mday  = UBCD(dt.aDay);
   mtm.tm_mon   = UBCD(dt.aMonth) - 1;
   mtm.tm_year  = UBCD(dt.aYear) + 100;
   mtm.tm_isdst = 0;

   tod = TgmMkGmtTime(&mtm);

   utc->Second  = (unsigned long) tod;
   utc->Nano    = dt.aMilliSecond * Tg8NS_ONE_MS;
   utc->CTrain  = 0;
   utc->Machine = TgmSPS;

   if (ioctl(tg8s[m],SpsTg8DrvrSC_INFO,&sc) >=0) utc->CTrain = sc.ScTime;

#ifdef CTR_TIME_ADJUST_TG8

   if (!timlib_real_utc) return TimLibErrorSUCCESS;

   if (utc->Nano >= Tg8NS_ONE_MS) utc->Nano -= Tg8NS_ONE_MS;
   else {
      utc->Second--;
      utc->Nano += (Tg8NS_IN_SEC - Tg8NS_ONE_MS);
   }

#endif

   return TimLibErrorSUCCESS;
}

/*
 * ==================================================================== 
 * Read a machines telegram from a timing receiver. The module can be 
 * either zero, in which case the system decides which device to use, 
 * or it can be explicitly set between 1 and the number of installed 
 * modules. The telegram object returned has an opaque structure and 
 * can only be decoded through the Tgm library routine .....  
 *
 * unsigned long grval = TgmGetGroupValueFromTelegram(TgmMachine machine, 
 * unsigned long grnum, 
 * TgmTelegram *telegram) 
 *
 * WARNING: The only task that should call this routine will be, get_tgm_lib, 
 * all other, LOWER PRIORITY tasks must NEVER call this routine, instead they 
 * should call the telegram library directly like this ...  
 *
 * TgmTelegram telegram; 
 * if (TgmGetTelegram(machine, index, offset, &telegram) == TgmNOT_IMP) { ...  
 * For more information on this function see the Tgm library man pages.  
 */

TimLibError Tg8SpsLibGetTelegram(unsigned long module,
				 TgmMachine machine,
				 TgmPTelegram * telegram) {

SpsTg8DrvrTelegram spstgm;
int i, m;

   m = 0;
   if (module) m = module - 1;
   if (tg8s[m] <= 0) return TimLibErrorMODULE;

   spstgm.Machine = TgvTgmToTgvMachine(machine);
   if (ioctl(tg8s[m], SpsTg8DrvrTELEGRAM, &spstgm) < 0) {
      perror("Tg8SpsLibGetTelegram");
      return TimLibErrorIO;
   }
   bzero((void *) telegram, sizeof(TgmTelegram));
   telegram->Machine = machine;
   telegram->Size = TgmLastGroupNumber(machine);
   for (i = 0; i < telegram->Size; i++)
      telegram->Groups[i] = spstgm.Data[i];

   return TimLibErrorSUCCESS;
}

/*
 * ==================================================================== 
 * Lets you know how many installed modules there are on this host.  
 */

unsigned long Tg8SpsLibGetInstalledModuleCount() {

unsigned long cnt = 0;
int m;

   for (m = 0; m < SpsTg8DrvrMODULES; m++) if (tg8s[m] > 0) cnt++;
   return cnt;
}

/*
 * ==================================================================== 
 * Get the description of a given PTIM equipment. The dimension returns 
 * the PPM dimension, counter and module are obvious.  
 */

TimLibError Tg8SpsLibGetPtimObject(unsigned long ptim,	/* PTIM equipment number */
				   unsigned long *module,
				   unsigned long *counter,
				   unsigned long *dimension) {
int i;

   for (i = 0; i < ptims->Size; i++) {
      if (ptims->Objects[i].EqpNum == ptim) {
	 *module = ptims->Objects[i].ModuleIndex + 1;
	 *counter = ptims->Objects[i].Counter;
	 *dimension = ptims->Objects[i].Size;
	 return TimLibErrorSUCCESS;
      }
   }
   return TimLibErrorPTIM;
}

/*
 * ==================================================================== 
 * Get the event code corresponding to a given CTIM equipment number.  
 */

TimLibError Tg8SpsLibGetCtimObject(unsigned long ctim,	/* CTIM equipment number */
				   unsigned long *eventcode) {

int i;

   for (i = 0; i < ctims->Size; i++) {
      if (ctims->Objects[i].EqpNum == ctim) {
	 *eventcode = ctims->Objects[i].Frame;
	 return TimLibErrorSUCCESS;
      }
   }
   return TimLibErrorCTIM;
}

/*
 * ==================================================================== 
 * In some cases when running a GUI under Linux, say, a file handle to 
 * put in a "select" is needed so that one can wait on multiple file 
 * handles simultaneously. This routine returns such a handle suitable 
 * to check for waiting interrupts. Do not read directly from it, but 
 * call the wait routine. The queue flag must be on for this to work !! 
 */

TimLibError Tg8SpsLibGetHandle(int *fd) {

   if (tg8s[0] <= 0) return TimLibErrorINIT;
   *fd = tg8s[0];
   return TimLibErrorSUCCESS;
}

/*
 * ==================================================================== 
 * Create a new PTIM object, the CCV settings will be defaulted.  
 */

TimLibError Tg8SpsLibCreatePtimObject(unsigned long ptim,	/* PTIM equipment number */
				      unsigned long module,
				      unsigned long counter,
				      unsigned long dimension) {
SpsTg8DrvrAction act;
int m, i, anum, cntr;

   if ((module < 1) || (module > SpsTg8DrvrMODULES)) return TimLibErrorMODULE;
   m = module - 1;
   if (tg8s[m] <= 0) return TimLibErrorMODULE;
   if ((counter < 1) || (counter > 8)) return TimLibErrorCOUNTER;

   if (dimension != 1) return TimLibErrorPPM;

   for (i = 0; i < ptims->Size; i++) {
      if (ptims->Objects[i].EqpNum == ptim) {
	 return TimLibErrorEXISTS;
      }
   }
   anum = 0;
   for (i = 0; i < SpsTg8DrvrACTIONS; i++) {
      if (atabs[m].Table[i].Frame == 0) {
	 anum = i + 1;
	 break;
      }
   }
   if (anum == 0) return TimLibErrorNOMEM;

   i = ptims->Size;
   if (i < SpsTg8DrvrPtimOBJECTS) {
      ptims->Objects[i].EqpNum = ptim;
      ptims->Objects[i].ModuleIndex = m;
      ptims->Objects[i].Counter = counter;
      ptims->Objects[i].Size = 1;
      ptims->Objects[i].StartIndex = anum - 1;
      ptims->Size++;
   }

   /*
    * Need to do this next step to be sure that space is reserved in the atab 
    */

   for (i = 0; i < dimension; i++) {
      cntr = counter & 0x7;
      act.Frame = 0x240AFFFF;   /* SPS Start Basic Period */
      act.Control = (cntr << 8) | 0x4000;
      act.Delay = 1;
   }

   return SpsTg8WriteAction(&act, anum, m);
}

/*
 * ==================================================================== 
 * Create a new CTIM object. If a payload is to be used for this event 
 * be sure to set the low 16-Bits to 0xFFFF 
 */

TimLibError Tg8SpsLibCreateCtimObject(unsigned long ctim,	/* CTIM equipment number */
				      unsigned long eventcode) {
int i;

   for (i = 0; i < ctims->Size; i++) {
      if (ctims->Objects[i].EqpNum == ctim) {
	 if (ctims->Objects[i].Frame  == eventcode) {
	    return TimLibErrorEXISTS;
	 } else {
	    ctims->Objects[i].Frame = eventcode;
	    return TimLibErrorSUCCESS;
	 }
      }
   }
   i = ctims->Size;
   if (ctims->Size < SpsTg8DrvrCtimOBJECTS) {
      ctims->Objects[i].EqpNum = ctim;
      ctims->Objects[i].Frame = eventcode;
      ctims->Size++;
      return TimLibErrorSUCCESS;
   }
   return TimLibErrorNOMEM;
}

/*
 * ==================================================================== 
 * Get the cable identifier to which a given module is attached so that
 * the correct module can be used to read telegrams. This function will
 * be used by the program get_tgm_tim only; it is of no interest to the
 * majority of clients because calls to ReadTelegram are diverted.
 */

TimLibError Tg8SpsLibGetCableId(unsigned long module,   /* The given module */
				unsigned long *cable) { /* The cable ID */

   *cable = TgvFirstCableIdForMember(500);    /* SPS Cable */
   return TimLibErrorSUCCESS;
}

/*
 * ==================================================================== 
 * Get Status from module.
 * See SPS version of tg8Hardw.h if you need to understand this code
 */

TimLibStatus Tg8SpsLibGetStatus(unsigned long module,
				TimLibDevice *dev)    {

TimLibStatus res;
int m, stat;
SpsTg8DrvrStatusBlock *sb;
SpsTg8Status st;
unsigned char iob[512];

   sb = (SpsTg8DrvrStatusBlock *) iob;
   *dev = TimLibDevice_TG8_SPS;
   m = 0;
   if (module) m = module - 1;

   res = TimLibStatusENABLED
       | TimLibStatusSELF_OK
       | TimLibStatusBUS_OK
       | TimLibStatusPLL_OK;

   ioctl(tg8s[m],SpsTg8DrvrGET_STATUS,&st);

   if  ((st.Status & 1     ) == 0)  res &= ~TimLibStatusENABLED;
   if (((st.Status & 0x60  ) != 0)
   ||  ((st.Status & 0x10  ) == 0)) res &= ~TimLibStatusSELF_OK;
   if  ((st.Status & 0x400 ) != 0)  res &= ~TimLibStatusPLL_OK;
   if  ((st.Alarms & 0x1803) != 0)  res &= ~TimLibStatusBUS_OK;

   ioctl(tg8s[m],SpsTg8DrvrGET_RAW_STATUS,sb);
   stat = sb->Dt.aRcvErr;
   stat &= ~0x20; stat &= 0xFF;
   if (stat == 0) res |= TimLibStatusGMT_OK;

   return res;
}

/*
 * ==================================================================== 
 * Get the list of all defined PTIMS
 */

TimLibError Tg8SpsLibGetAllPtimObjects(unsigned long *ptimlist,  /* List of ptim equipments */
				       unsigned long *psize,     /* Number of ptims in list */
				       unsigned long size) {     /* Max size of list */
SpsTg8DrvrPtimBinding *pb;
int i;

   if (ptims) {
      for (i=0; i<ptims->Size; i++) {
	 if (i>=size) break;
	 pb = &(ptims->Objects[i]);
	 ptimlist[i] = pb->EqpNum;
	 *psize = i+1;
      }
   } else *psize = 0;
   return TimLibErrorSUCCESS;
}

/*
 * ==================================================================== 
 * Get the list of all defined CTIMS
 */

TimLibError Tg8SpsLibGetAllCtimObjects(unsigned long *ctimlist,  /* List of ctim equipments */
				       unsigned long *csize,     /* Number of ctims in list */
				       unsigned long size) {     /* Max size of list */
int i;

   if (ctims) {
      for (i=0; i<ctims->Size; i++) {
	 if (i>=size) break;
	 ctimlist[i] = ctims->Objects[i].EqpNum;
	 *csize = i+1;
      }
   } else *csize = 0;
   return TimLibErrorSUCCESS;
}

/* ==================================================================== */
/* Get VHDL/Firmware version of all modules, and the correct version.   */

TimLibError Tg8SpsLibGetModuleVersion(TimLibModuleVersion *version) {

   return TimLibErrorNOT_IMP;

}

/* ==================================================================== */
/* Get specific information string                                      */
/* There is some very specific module dependent status information.     */
/* This routine returns a free format human readable string containing  */
/* specific status information that may help diagnosing problems for a  */
/* timing receiver module. A null pointer can be returned if the module */
/* is either dead or not installed.                                     */

char *Tg8SpsLibGetSpecificInfo(unsigned long module) { /* The given module */

   return NULL;
}

/* ==================================================================== */
/* Get the module statistics for the given module                       */

TimLibError Tg8SpsLibGetModuleStats(unsigned long module,
				    TimLibModuleStats *stats) {
   return TimLibErrorNOT_IMP;
}

/* ==================================================================== */
/* Control how the PLL locks after synchronization loss                 */

TimLibError Tg8SpsLibSetPllLocking(unsigned long module,
				   unsigned long lockflag) { /* 0=> Brutal, else Slow */
   return TimLibErrorNOT_IMP;
}

/* ==================================================================== */

TimLibError Tg8SpsLibConnectPayload(unsigned long ctim,        /* The CTIM ID you want to connect to */
				    unsigned long payload,     /* The 16 bit payload in a long */
				    unsigned long module) {    /* The module, or zero means don't care */
   return TimLibErrorNOT_IMP;
}

@


1.54
log
@Added PLL lock control entries as unimplemented
@
text
@d1670 9
@


1.53
log
@*** empty log message ***
@
text
@a1641 1

d1655 15
@


1.52
log
@Added Thread support via File Descriptor FD extra parameter
@
text
@d559 8
a566 1
   return 0;
d726 2
a727 1
   return TimLibErrorNOT_IMP;
d760 1
a760 1
   return TimLibErrorNOT_IMP;
d1007 2
a1008 1
   return TimLibErrorNOT_IMP;
@


1.51
log
@Added specific status info string routine
@
text
@d556 6
d713 9
d747 8
d983 19
@


1.50
log
@Added GetModuleVersion
@
text
@d1591 14
@


1.49
log
@DisConnect
@
text
@d1581 10
@


1.48
log
@Removed time adjustment
Removed FESA2.6 support
@
text
@d707 10
@


1.47
log
@Added GetQueueSize
@
text
@a804 5
#ifndef FESA2p7
unsigned long cytag, ncytag, us, bp;
TgmBeamState bs;
#endif

a889 6
#ifndef FESA2p7
	 TimLibGetTgmInfo(xonzero,NULL,&cytag,&ncytag);
	 TgmDecodeTag(cytag,&bs, (Cardinal *) &us, (Cardinal *) &bp);
	 if (us == xpayload) xpayload = cytag; else xpayload = ncytag;
#endif

d1254 3
a1256 1
   if (timlib_real_utc) return TimLibErrorSUCCESS;
d1264 2
@


1.46
log
@Bug corrected
@
text
@d723 16
@


1.45
log
@\Added CTime in GetTim
@
text
@d1247 1
a1247 1
   if (ioctl(tg8s[m],Tg8DrvrSC_INFO,&sc) >=0) utc->CTrain = sc.ScTime;
@


1.44
log
@Return correct cable ID for the SPS
@
text
@d131 7
d1223 1
d1247 2
@


1.43
log
@Optional adjustment of UTC
@
text
@d1466 1
a1466 1
   *cable = 203;    /* SPS Dev */
@


1.42
log
@Added ifdef FESA2p7 to suppress frigging CYTAG payloads
@
text
@d20 4
a23 4
extern int timlib_debug;  /* 1/Print stuff, 2/Wipe memory */
extern int timlib_delay;  /* Input delay when not zero */
extern int timlib_enable; /* Enable modules */

d1209 3
d1235 1
a1235 1
   utc->Nano    = dt.aMilliSecond * 1000000;
d1239 8
@


1.41
log
@Remove include of select.h for 68k target.
@
text
@d782 1
d785 1
d872 1
d876 1
@


1.40
log
@Cable ID for SPS returned is 203
@
text
@d10 1
d12 1
@


1.39
log
@Frig the payload for the SPS
@
text
@d1449 2
a1450 1
   return TimLibErrorNOT_IMP;
@


1.38
log
@Small bugs, and 21 default header suppressed
@
text
@d780 3
d868 4
@


1.37
log
@*** empty log message ***
@
text
@d1298 1
a1298 1
   for (i = 0; i < ctims->Size; i++) {
d1393 1
a1393 1
      act.Frame = 0x2101FFFF;	/* OX.NSSC-MTG */
@


1.36
log
@Filter needs the machine
@
text
@d651 8
a658 1
	    return SpsTg8WriteAction(&act, 0, m);
@


1.35
log
@Use 24FFFFFF filter wildcard
@
text
@d677 1
a677 1
	    ftr.Event = 0x24FFFFFF; /* act.Frame; */
@


1.34
log
@Changed the PTIM connect behaviour to get over driver bug that disconnects clients
when the action is written. No I use the FILTER event mechanism for multiple
connections to the same PTIM interrupt.
@
text
@d674 7
a680 8
	       return SpsTg8WriteAction(&act, ptimp->StartIndex + 1, m);
	    } else {
	       ftr.Event = act.Frame;
	       if (ioctl(tg8s[m],SpsTg8DrvrFILTER_EVENT,&ftr) < 0) {
		  perror("Tg8SpsLibConnect");
		  return TimLibErrorIO;
	       }
	       if (ftr.Matches == 0) return TimLibErrorCONNECT;
d682 1
@


1.33
log
@Added CTIM frame edit
@
text
@d162 5
d631 1
a670 1
	    act.Control |= CW_BUS_MASK;
d672 12
a683 1
	    return SpsTg8WriteAction(&act, ptimp->StartIndex + 1, m);
@


1.32
log
@Added GetAllCtims
@
text
@d1390 6
a1395 1
	 return TimLibErrorEXISTS;
d1398 1
@


1.31
log
@Bug in interrupt time, select returns imiediatley
so moved time reading to after thr call to read.
@
text
@d1478 20
@


1.30
log
@Read Status modifications
@
text
@a780 1
      err = TimLibGetTime(1,&xonzero);
d796 1
@


1.29
log
@*** empty log message ***
@
text
@d157 5
d810 1
d814 1
a814 1

d1428 1
a1434 1
   ioctl(tg8s[m],SpsTg8DrvrGET_RAW_STATUS,sb);
d1436 12
a1447 1
   res = TimLibStatusSELF_OK | TimLibStatusBUS_OK | TimLibStatusPLL_OK;
d1449 1
a1450 1
   if ((stat & 0x20) == 0) res |= TimLibStatusENABLED;
@


1.28
log
@*** empty log message ***
@
text
@d243 1
a243 1
   if (timlib_debug == 1)
d255 1
a255 1
   if (timlib_debug == 1)
d267 1
a267 1
   if (timlib_debug == 1)
d301 1
a301 1
	 if (timlib_debug == 1)
d373 1
a373 1
   if (timlib_debug == 1) {
d474 1
a474 1
      if (timlib_debug == 1) {
d517 1
a517 1
	    if ((timlib_enable) && (ioctl(tg8s[m], SpsTg8DrvrENABLE_MODULE, NULL) < 0)) {
d630 1
a630 1
      if (timlib_debug == 1)
d652 4
a655 4
	    if (timlib_debug == 1) fprintf(stderr,
					  "Tg8SpsLibConnect: To Ptim:%d on Module:%d\n",
					   (int) equip,
					   (int) m + 1);
d783 1
a783 1
	    if (timlib_debug == 1) fprintf(stderr,"Tg8SpsLibWait: Select data on module: %d\n",m+1);
d798 1
a798 1
	 if (timlib_debug == 1) {
d825 1
a825 1
	 if (timlib_debug == 1) {
d1140 1
a1140 1
	 if (timlib_debug == 1)
@


1.27
log
@Tempary fix of duplicate event bug
@
text
@d18 4
d517 1
a517 1
	    if (ioctl(tg8s[m], SpsTg8DrvrENABLE_MODULE, NULL) < 0) {
d789 1
a789 1
      orbuf = rbuf;
d798 7
d825 6
d878 1
@


1.26
log
@Corrected a bug in wait. I moved the select into the wait loop
and read the UTC time after the select instead of the read.
@
text
@d285 1
a285 1
int i, m, fnum;
d289 1
a289 1
   m = module - 1; if (tg8s[m]) return tg8s[m];
d294 5
a298 1
      if ((tg8s[m] = open(fnm, O_RDWR, 0)) > 0) {
a325 1
   tg8s[m] = 0;
d409 1
a409 1
      if (tg8s[m]) {
d447 1
a447 1
      if (tg8s[m]) {
a521 5
	 if (timlib_debug == 1)
	    fprintf(stderr,
		    "Tg8SpsLibInitialize: Found SPS TG8 module: %d on file descriptor: %d %s OK\n",
		    (int) module, (int) tg8s[m], fnm);

d622 1
a622 1
   if (!(tg8s[m])) return TimLibErrorMODULE;
d721 1
a721 1
SpsTg8DrvrEvent rbuf;
d748 1
a748 1
   cnt = 1;
d751 2
a752 3
      if (tg8s[m]) {
	 if (QFlag)
	    ioctl(tg8s[m], SpsTg8DrvrPURGE_QUEUE, NULL);
d757 1
d770 1
d773 1
a773 1
      if (cc  == 0)                  return TimLibErrorTIMEOUT;
d777 1
a777 1
	 if ((tg8s[m]) && (FD_ISSET(tg8s[m], &rdset))) {
d779 1
a779 1
	    break;
d781 1
d785 2
d794 4
d901 1
a901 1
	 if (!tg8s[m]) return TimLibErrorMODULE;
d1027 1
a1027 2
	 if (!tg8s[m])
	    return TimLibErrorMODULE;
d1117 1
a1117 1
      if (tg8s[m]) {
d1158 1
a1158 1
   if (tg8s[m] == 0) return TimLibErrorMODULE;
d1209 1
a1209 1
   if (tg8s[m] == 0) return TimLibErrorMODULE;
d1235 1
a1235 1
   for (m = 0; m < SpsTg8DrvrMODULES; m++) if (tg8s[m]) cnt++;
d1292 1
a1292 1
   if (tg8s[0] == 0) return TimLibErrorINIT;
d1311 1
a1311 1
   if (!tg8s[m]) return TimLibErrorMODULE;
@


1.25
log
@Addede spurious interrupt filter so that unwanted events are discarded.[D[D[D[D[D[D[D[D
@
text
@d748 1
d771 11
a781 10
   cc = select(cnt, &rdset, NULL, NULL, ptv);
   gettimeofday(&tv, &tz);
   if (cc == 0)
      return TimLibErrorTIMEOUT;

   xmodule = 0;
   for (m = 0; m < SpsTg8DrvrMODULES; m++) {
      if ((tg8s[m]) && (FD_ISSET(tg8s[m], &rdset))) {
	 xmodule = m + 1;
	 break;
d783 1
a783 5
   }
   if (xmodule == 0)
      return TimLibErrorTIMEOUT;

   while(1) {
a812 2
	 xonzero.Second = tv.tv_sec;
	 xonzero.Nano = tv.tv_usec * 1000;
@


1.24
log
@Prints out SL TG8 version in use
@
text
@d537 65
d637 1
d659 1
d785 4
a788 15
   cc = read(tg8s[m], &rbuf, sizeof(SpsTg8DrvrEvent));
   if (cc <= 0) {
      perror("Tg8SpsLibWait");
      return TimLibErrorIO;
   } else {
      ioctl(tg8s[m], SpsTg8DrvrGET_QUEUE_LENGTH, &xqsize);
      xmissed = 0;
      if (xqsize >= 128)
	 xmissed = 1;

      bzero((void *) &atab, sizeof(SpsTg8DrvrActionTable));
      atab.Row = rbuf.Inter.Ext.Act;
      atab.Cnt = 1;
      actp = &(atab.Table[0]);
      if (ioctl(tg8s[m], SpsTg8DrvrUSER_TABLE, &atab) < 0) {
a790 16
      }
      actp->Control &= CW_BIT_MASK;
      if (actp->Control == CW_BUS_MASK)
	 xclass = TimLibClassCTIM;
      else
	 xclass = TimLibClassPTIM;

      xmachine = (rbuf.Inter.Frame & 0xF0000000) >> 28;
      xmachine = TgvTgvToTgmMachine(xmachine);

      xpayload = rbuf.Inter.Frame & 0xFFFF;

      xonzero.Second = tv.tv_sec;
      xonzero.Nano = tv.tv_usec * 1000;
      xonzero.CTrain = rbuf.Inter.Out;
      xonzero.Machine = xmachine;
d792 1
a792 2
      xstart = xtrigger = xonzero;
      xtrigger.CTrain = rbuf.Inter.Occ;
d794 11
a804 8
      found = 0;
      for (i = 0; i < ctims->Size; i++) {
	 ctimp = &(ctims->Objects[i]);
	 if (ctimp->Frame == rbuf.Frame) {
	    xequip = xctim = ctimp->EqpNum;
	    xsource = TimLibHardwareCTIM;
	    found = 1;
	    break;
d806 16
a821 3
      }
      if (!found)
	 return TimLibErrorCTIM;
a822 1
      if (xclass == TimLibClassPTIM) {
d824 6
a829 3
	 for (i = 0; i < ptims->Size; i++) {
	    ptimp = &(ptims->Objects[i]);
	    if ((atab.Row >= ptimp->StartIndex) && (atab.Row < ptimp->StartIndex + ptimp->Size + 1)) {
a830 4
	       xequip = ptimp->EqpNum;
	       xmodule = ptimp->ModuleIndex + 1;
	       xplnum = 1;
	       xsource = ptimp->Counter;
d834 22
a855 2
	 if (!found)
	    return TimLibErrorPTIM;
d857 1
a858 1

@


1.23
log
@Reads DataTime from hardware
@
text
@d310 1
a310 1
	       fprintf(stderr,"Found old SL_TG8 Firmware: %s Updating...\n",ver);
a312 1
	       fprintf(stderr,"Version is now: %s\n",ver);
d314 1
@


1.22
log
@Added firmware version check and download in tim lib init
@
text
@d24 4
a504 2
      TimLibClient = 0; /* Can't read telegrams from SPS TG8 */

d1078 4
a1081 2
   struct timeval tv;
   struct timezone tz;
d1083 3
a1085 4
   tz.tz_minuteswest = 0;
   tz.tz_dsttime = 0;

   gettimeofday(&tv, &tz);
d1087 14
a1100 4
   utc->Second = tv.tv_sec;
   utc->Nano = tv.tv_usec * 1000;
   utc->CTrain = 0;
   utc->Machine = TgmMACHINE_NONE;
@


1.21
log
@Corrected error when creating PTIM. Set the CTIM to first when zero.
@
text
@d279 2
a280 1
char ver[32];
d303 8
@


1.20
log
@Seems to work correctly from timtest
@
text
@d870 1
d874 1
a874 1
		  act.Control = CW_OUT_MASK | (cntr << CW_CNT_BITN);  /* DO_OUTPUT */
@


1.19
log
@Works Correctly
@
text
@a26 1
#define SpsTg8DrvrCONTROL_BITS 0xC7C3
d191 25
d222 1
a222 2
TimLibError AttachMemory()
{
d277 1
a277 2
static int SpsTg8Open(int module)
{
d279 2
a280 2
   char ver[32];
   int i, m, fnum;
d282 1
a282 2
   if ((module < 1) || (module > SpsTg8DrvrMODULES))
      return 0;
d284 1
a284 3
   m = module - 1;
   if (tg8s[m])
      return tg8s[m];
d321 4
a324 2
TimLibError SpsTg8WriteAction(SpsTg8DrvrAction * ap, int anum, int m)
{
d326 1
a326 2
   SpsTg8DrvrActionAddress ad;
   int i, clear;
d334 3
a336 2
	 if ((atabs[m].Table[i].Frame == ap->Frame)
	     && (atabs[m].Table[i].Control == ap->Control) && (atabs[m].Table[i].Delay == ap->Delay)) {	/* Already exists ? */
d351 1
a351 2
   if (anum == 0)
      return TimLibErrorNOMEM;
d383 1
a383 2
TimLibError SpsTg8WriteAllActions()
{
d385 3
a387 3
   int i, m;
   TimLibError err;
   SpsTg8DrvrActionAddress ad;
d418 1
a418 2
TimLibError SpsTg8WipeMemory()
{
d420 2
a421 2
   int m;
   SpsTg8DrvrActionAddress ad;
d450 1
a450 2
TimLibError SpsTg8ReadAction(SpsTg8DrvrAction * ap, int anum, int m)
{
d485 1
a485 2
TimLibError Tg8SpsLibInitialize(TimLibDevice device)
{				/* Initialize hardware/software */
d487 2
a488 2
   int m, ok, module;
   TimLibError err;
d492 2
d514 4
a517 10
	 if (err != TimLibErrorSUCCESS)
	    return err;

	 if (timlib_debug == 2)
	    err = SpsTg8WriteAllActions();
	 if (err != TimLibErrorSUCCESS)
	    return err;

	 if (timlib_debug == 3)
	    err = SpsTg8WipeMemory();
d519 1
a519 3

      } else
	 return TimLibErrorOPEN;
d536 8
a543 9
TimLibError Tg8SpsLibConnect(TimLibClass iclss,	/* Class of interrupt */
			     unsigned long equip,	/* Equipment or hardware mask */
			     unsigned long module)
{				/* For HARD or CTIM classes */
   int i, m;
   SpsTg8DrvrCtimBinding *ctimp;
   SpsTg8DrvrPtimBinding *ptimp;
   SpsTg8DrvrAction act;
   TimLibError err;
d545 2
a546 5
   if (module > SpsTg8DrvrMODULES)
      return TimLibErrorMODULE;
   m = 0;
   if (module)
      m = module - 1;
d548 1
a548 2
   if (!(tg8s[m]))
      return TimLibErrorMODULE;
d559 1
a559 1
	    act.Control = 0x8000;
d571 1
a571 2
	    if (!module)
	       m = ptimp->ModuleIndex;
d573 4
a576 2
	    if (timlib_debug == 1)
	       fprintf(stderr, "Tg8SpsLibConnect: To Ptim:%d on Module:%d\n", (int) equip, (int) m + 1);
d578 1
a578 2
	    if (ptimp->ModuleIndex != m)
	       return TimLibErrorMODULE;
d580 2
a581 3
	    if (err != TimLibErrorSUCCESS)
	       return err;
	    act.Control |= 0xC000;
d596 2
a597 3
TimLibError Tg8SpsLibQueue(unsigned long qflag,	/* 0=>Queue, 1=>NoQueue */
			   unsigned long tmout)
{				/* 0=>No time outs */
d631 19
a649 26
TimLibError Tg8SpsLibWait(TimLibClass * iclass,	/* Class of interrupt */
			  unsigned long *equip,	/* PTIM CTIM or hardware mask */
			  unsigned long *plnum,	/* Ptim line number 1..n or 0 */
			  TimLibHardware * source,	/* Hardware source of interrupt */
			  TimLibTime * onzero,	/* Time of interrupt/output */
			  TimLibTime * trigger,	/* Time of counters load */
			  TimLibTime * start,	/* Time of counters start */
			  unsigned long *ctim,	/* CTIM trigger equipment ID */
			  unsigned long *payload,	/* Payload of trigger event */
			  unsigned long *module,	/* Module that interrupted */
			  unsigned long *missed,	/* Number of missed interrupts */
			  unsigned long *qsize,	/* Remaining interrupts on queue */
			  unsigned long *machine)
{				/* Tgm Machine */

   SpsTg8DrvrEvent rbuf;
   SpsTg8DrvrAction *actp;
   SpsTg8DrvrActionTable atab;
   SpsTg8DrvrPtimBinding *ptimp;
   SpsTg8DrvrCtimBinding *ctimp;

   fd_set rdset;
   struct timeval tv;
   struct timeval *ptv;
   struct timezone tz;
   int i, m, cnt, cc, found;
d651 19
a669 13
   TimLibClass xclass = TimLibClassHARDWARE;
   unsigned long xequip = 0;
   unsigned long xplnum = 0;
   TimLibHardware xsource = TimLibHardwareCTIM;
   TimLibTime xonzero = { 0, 0, 0, TgmMACHINE_NONE };
   TimLibTime xtrigger = { 0, 0, 0, TgmMACHINE_NONE };
   TimLibTime xstart = { 0, 0, 0, TgmMACHINE_NONE };
   unsigned long xctim = 0;
   unsigned long xpayload = 0;
   unsigned long xmodule = 0;
   unsigned long xmissed = 0;
   unsigned long xqsize = 0;
   unsigned long xmachine = 0;
d725 2
a726 2
      actp->Control &= SpsTg8DrvrCONTROL_BITS;
      if (actp->Control == 0x8000)
d775 13
a787 26
   if (iclass)
      *iclass = xclass;
   if (equip)
      *equip = xequip;
   if (plnum)
      *plnum = xplnum;
   if (source)
      *source = xsource;
   if (onzero)
      *onzero = xonzero;
   if (trigger)
      *trigger = xtrigger;
   if (start)
      *start = xstart;
   if (ctim)
      *ctim = xctim;
   if (payload)
      *payload = xpayload;
   if (module)
      *module = xmodule;
   if (missed)
      *missed = xmissed;
   if (qsize)
      *qsize = xqsize;
   if (machine)
      *machine = xmachine;
d803 1
a803 2
			 TimLibCcv * ccv)
{				/* Current control value */
d805 4
a808 4
   int i, m, msk, cntr, found;
   SpsTg8DrvrPtimBinding *ptimp;
   SpsTg8DrvrAction act;
   TimLibError err;
d815 1
a815 2
	 if (!tg8s[m])
	    return TimLibErrorMODULE;
d818 1
a818 2
	 if (err != TimLibErrorSUCCESS)
	    return err;
d823 1
a823 2
   if (!found)
      return TimLibErrorPTIM;
d825 1
a825 2
   if ((grnum) || (plnum > 1))
      return TimLibErrorPPM;	/* No PPM allowed */
d830 2
d834 5
a838 4
	    if (ccv->Enable)
	       act.Control |= 0x4000;
	    else
	       act.Control &= ~0x4000;
a841 2
	    if (ccv->Start >= TimLibSTARTS)
	       return TimLibErrorSTART;
d843 1
a843 1
	       act.Control &= 0xFF0F;
d845 2
a846 2
	       act.Control &= 0xFF0F;
	       act.Control |= 0x0040;
d848 3
a850 3
	       act.Control &= 0xFF0F;
	       act.Control |= 0x0080;
	    } else
d852 1
a855 2
	    if (ccv->Clock >= TimLibCLOCKS)
	       return TimLibErrorCLOCK;
d857 1
a857 4
	       act.Control &= 0xFFF0;
	    } else if (ccv->Clock == TimLibClock10MHZ) {
	       act.Control &= 0xFFF0;
	       act.Control |= 0x0001;
d859 2
a860 2
	       act.Control &= 0xFFF0;
	       act.Control |= 0x0002;
d862 2
a863 2
	       act.Control &= 0xFFF0;
	       act.Control |= 0x0003;
d873 1
a873 1
		  act.Control = 0x4000 | (cntr << 8);
d953 16
a968 13
       | TimLibCcvMaskSTART | TimLibCcvMaskCLOCK | TimLibCcvMaskDELAY | TimLibCcvMaskCTIM | TimLibCcvMaskPAYLOAD;

   if (act.Control & 0x4000)
      ccv->Enable = 1;
   if (act.Control & 0x0040)
      ccv->Start = TimLibStartCHAINED;
   if (act.Control & 0x0080)
      ccv->Start = TimLibStartEXT1;

   if ((act.Control & 0x0003) == 3)
      ccv->Clock = TimLibClockEXT2;
   if ((act.Control & 0x0002) == 2)
      ccv->Clock = TimLibClockEXT2;
d981 1
a981 2
   if (!found)
      return TimLibErrorCTIM;
d1002 6
a1007 4
TimLibError
Tg8SpsLibSimulate(TimLibClass xclass,
		  unsigned long equip, unsigned long module, TgmMachine machine, unsigned long grnum, unsigned long grval)
{
d1017 6
a1022 7
TimLibError Tg8SpsLibRemoteControl(unsigned long remflg,	/* 0 = Normal, 1 = Remote */
				   unsigned long module,	/* Module or zero */
				   unsigned long cntr,	/* 1..8 counter number */
				   TimLibRemote rcmd,	/* Command */
				   TimLibCcvMask ccvm,	/* Fields to be set */
				   TimLibCcv * ccv)
{				/* Value to load in counter */
d1024 1
a1024 1
   int msk, m;
d1064 1
a1064 2
			     TimLibTime * utc)
{				/* Returned time value */
d1103 6
a1108 4
TimLibError Tg8SpsLibGetTelegram(unsigned long module, TgmMachine machine, TgmPTelegram * telegram)
{
   SpsTg8DrvrTelegram spstgm;
   int i, m;
d1111 2
a1112 4
   if (module)
      m = module - 1;
   if (tg8s[m] == 0)
      return TimLibErrorMODULE;
d1133 1
a1133 2
unsigned long Tg8SpsLibGetInstalledModuleCount()
{
d1135 2
a1136 2
   unsigned long cnt = 0;
   int m;
d1138 1
a1138 3
   for (m = 0; m < SpsTg8DrvrMODULES; m++)
      if (tg8s[m])
	 cnt++;
d1149 4
a1152 4
				   unsigned long *module, unsigned long *counter, unsigned long *dimension)
{

   int i;
d1171 1
a1171 2
				   unsigned long *eventcode)
{
d1173 1
a1173 1
   int i;
d1193 1
a1193 2
TimLibError Tg8SpsLibGetHandle(int *fd)
{
d1195 1
a1195 2
   if (tg8s[0] == 0)
      return TimLibErrorINIT;
d1206 5
a1210 4
				      unsigned long module, unsigned long counter, unsigned long dimension)
{
   SpsTg8DrvrAction act;
   int m, i, anum, cntr;
d1212 1
a1212 2
   if ((module < 1) || (module > SpsTg8DrvrMODULES))
      return TimLibErrorMODULE;
d1214 2
a1215 4
   if (!tg8s[m])
      return TimLibErrorMODULE;
   if ((counter < 1) || (counter > 8))
      return TimLibErrorCOUNTER;
d1217 1
a1217 2
   if (dimension != 1)
      return TimLibErrorPPM;
d1231 1
a1231 2
   if (anum == 0)
      return TimLibErrorNOMEM;
d1264 2
a1265 3
				      unsigned long eventcode)
{
   int i;
d1301 2
a1302 1
TimLibStatus Tg8SpsLibGetStatus(unsigned long module, TimLibDevice *dev) {
@


1.18
log
@Added GetStatus and GetAllPtimObjects
Added plnum parameter to Get
@
text
@d1060 14
@


1.17
log
@*** empty log message ***
@
text
@d126 24
d938 11
a948 8
TimLibError Tg8SpsLibGet(unsigned long ptim, unsigned long grnum, unsigned long grval, TimLibCcvMask * ccvm,	/* Valid fields in ccv */
			 TimLibCcv * ccv)
{

   int i, m, found;
   SpsTg8DrvrPtimBinding *ptimp;
   SpsTg8DrvrAction act;
   TimLibError err;
d951 1
a951 1
   if (grnum)
d1308 51
@


1.16
log
@*** empty log message ***
@
text
@d1267 14
@


1.15
log
@*** empty log message ***
@
text
@d31 47
a77 47
    SpsTg8DrvrDEBUG_ON,
    SpsTg8DrvrDEBUG_OFF,
    SpsTg8DrvrGET_DRI_VERSION,
    SpsTg8DrvrGET_FIRMWARE_VERSION,
    SpsTg8DrvrSET_TIME_OUT,
    SpsTg8DrvrSET_SSC_HEADER,
    SpsTg8DrvrENABLE_SYNC,
    SpsTg8DrvrDISABLE_SYNC,
    SpsTg8DrvrENABLE_MODULE,
    SpsTg8DrvrDISABLE_MODULE,
    SpsTg8DrvrRESET_MODULE,
    SpsTg8DrvrINSTALL_MODULE,
    SpsTg8DrvrGET_CONFIGURATION,
    SpsTg8DrvrSIMULATE_PULSE,
    SpsTg8DrvrUSER_TABLE,
    SpsTg8DrvrRECORDING_TABLE,
    SpsTg8DrvrINTERRUPT_TABLE,
    SpsTg8DrvrHISTORY_TABLE,
    SpsTg8DrvrCLOCK_TABLE,
    SpsTg8DrvrAUX_TABLE,
    SpsTg8DrvrSC_INFO,
    SpsTg8DrvrTELEGRAM,
    SpsTg8DrvrTRACE_FIRMWARE,
    SpsTg8DrvrDATE_TIME,
    SpsTg8DrvrGET_RAW_STATUS,
    SpsTg8DrvrGET_STATUS,
    SpsTg8DrvrGET_DPRAM,
    SpsTg8DrvrRELOAD_FIRMWARE,
    SpsTg8DrvrRELOAD_ACTIONS,
    SpsTg8DrvrON_CLOSE,
    SpsTg8DrvrSET_SIGNAL,
    SpsTg8DrvrGET_SIGNAL,
    SpsTg8DrvrGET_QUEUE_LENGTH,
    SpsTg8DrvrPURGE_QUEUE,
    SpsTg8DrvrSET_ACTION_STATE,
    SpsTg8DrvrCLEAR_ACTION,
    SpsTg8DrvrWAIT_EVENT,
    SpsTg8DrvrFILTER_EVENT,
    SpsTg8DrvrGET_PPM_LINE,
    SpsTg8DrvrSET_OBJECT,
    SpsTg8DrvrREMOVE_OBJECT,
    SpsTg8DrvrGET_OBJECT,
    SpsTg8DrvrCONNECT,
    SpsTg8DrvrOBJECT_PARAM,
    SpsTg8DrvrOBJECTS_LIST,
    SpsTg8DrvrTEST_DPRAM,
    SpsTg8DrvrCARD_TEST,
d81 3
a83 3
    unsigned long   Frame;
    unsigned short  Control;
    unsigned short  Delay;
d87 2
a88 2
    unsigned long   Row;
    unsigned long   Cnt;
d92 3
a94 3
    unsigned long   Row;
    unsigned long   Cnt;
    SpsTg8DrvrAction Table[SpsTg8DrvrACTIONS];
d98 4
a101 4
    unsigned char   RcvErr;	/* Value of the reception error register */
    unsigned char   OvwrAct;	/* Which action was overwitten (if not 0x00) */
    unsigned char   Act;	/* Which action was triggered and fired */
    unsigned char   Sem;	/* Semaphore to solve the read/write conflicts */
d105 5
a109 5
    unsigned long   Frame;	/* The trigger event frame */
    unsigned int    Sc;		/* The Super Cycle number */
    unsigned int    Occ;	/* Occurence time from the start of the last S-Cycle */
    unsigned int    Out;	/* Output time from the start of the last S-Cycle */
    SpsTg8IntAction Ext;	/* Extra data concerning the interrupted action */
d113 6
a118 6
    unsigned int    Id;		/* Timing object identifier */
    unsigned long   Frame;	/* Declared timing event (wildcards allowed) */
    SpsTg8Interrupt Inter;	/* Interrupt information */
    unsigned short  Alarms;	/* The firmware alarms bit mask ORed with the driver alarms bit mask */
    unsigned char   FwStat;	/* Firmware status */
    unsigned char   DevMask;	/* Target devices bitmask */
d122 2
a123 2
    int             Machine;	/* Acc. machine number */
    unsigned short  Data[SpsTg8DrvrGROUPS];	/* Telegram buffer */
d133 2
a134 2
    unsigned long   EqpNum;
    unsigned long   Frame;
d138 2
a139 2
    unsigned short  Size;
    SpsTg8DrvrCtimBinding Objects[SpsTg8DrvrCtimOBJECTS];
d149 5
a153 5
    unsigned long   EqpNum;
    unsigned char   ModuleIndex;
    unsigned char   Counter;
    unsigned short  Size;
    unsigned short  StartIndex;
d157 2
a158 2
    unsigned short  Size;
    SpsTg8DrvrPtimBinding Objects[SpsTg8DrvrPtimOBJECTS];
d163 2
a164 2
static int      QFlag = 0;
static int      TmOut = 20000000;
d174 1
a174 2
TimLibError
AttachMemory()
d177 1
a177 2
    int             shmkey,
                    shmid;
d179 35
a213 35
    if (ctims == NULL) {
	shmkey = TgmGetKey("CTIMS");
	shmid = shmget(shmkey, sizeof(SpsTg8DrvrCtimObjects), IPC_CREAT | 0666);
	ctims = (SpsTg8DrvrCtimObjects *) shmat(shmid, NULL, 0);
	if ((int) ctims == -1) {
	    ctims = NULL;
	    return TimLibErrorNOMEM;
	}
    }
    if (timlib_debug == 1)
	fprintf(stderr, "AttachMemory: CTIMS key:%d id:%d OK\n", shmkey, shmid);

    if (ptims == NULL) {
	shmkey = TgmGetKey("PTIMS");
	shmid = shmget(shmkey, sizeof(SpsTg8DrvrPtimObjects), IPC_CREAT | 0666);
	ptims = (SpsTg8DrvrPtimObjects *) shmat(shmid, NULL, 0);
	if ((int) ptims == -1) {
	    ptims = NULL;
	    return TimLibErrorNOMEM;
	}
    }
    if (timlib_debug == 1)
	fprintf(stderr, "AttachMemory: PTIMS key:%d id:%d OK\n", shmkey, shmid);

    if (atabs == NULL) {
	shmkey = TgmGetKey("ATABS");
	shmid = shmget(shmkey, sizeof(SpsTg8DrvrActionTable) * SpsTg8DrvrMODULES, IPC_CREAT | 0666);
	atabs = (SpsTg8DrvrActionTable *) shmat(shmid, NULL, 0);
	if ((int) atabs == -1) {
	    atabs = NULL;
	    return TimLibErrorNOMEM;
	}
    }
    if (timlib_debug == 1)
	fprintf(stderr, "AttachMemory: ATABS key:%d id:%d OK\n", shmkey, shmid);
d215 1
a215 1
    return TimLibErrorSUCCESS;
d226 1
a226 1
static char     fnm[32];
d228 1
a228 1
static int      tg8s[SpsTg8DrvrMODULES] = { 0, 0, 0, 0 };	/* This global holds the SPS TG8 Driver file handle */
d230 1
a230 2
static int
SpsTg8Open(int module)
d233 35
a267 38
    char            ver[32];
    int             i,
                    m,
                    fnum;

    if ((module < 1) || (module > SpsTg8DrvrMODULES))
	return 0;

    m = module - 1;
    if (tg8s[m])
	return tg8s[m];

    for (i = 0; i < SpsTg8DrvrCLIENTS_PER_MODULE; i++) {
	fnum = (m * SpsTg8DrvrCLIENTS_PER_MODULE) + i + 1;
	sprintf(fnm, "/dev/Tg8.%1d", fnum);
	if ((tg8s[m] = open(fnm, O_RDWR, 0)) > 0) {

	    /*
	     * The CPS Tg8 driver returns a long version string <__DATE__ __TIME__> 
	     * while the SPS Tg8 driver returns a short version string <__DATE__> 
	     */

	    bzero((void *) ver, 32);
	    if (ioctl(tg8s[m], SpsTg8DrvrGET_FIRMWARE_VERSION, &ver) < 0) {
		perror("SpsTg8Open");
		ver[0] = 0;
	    }
	    if ((strlen(ver) > 0)
		&& (strlen(ver) < (strlen(__DATE__) + 4))) {	/* Is it an SPS TG8 ? */
		return tg8s[m];	/* Yes */
	    }
	    close(tg8s[m]);
	    tg8s[m] = 0;	/* No it a PS TG8 */
	    return 0;		/* No point in continuing */
	}
    }
    tg8s[m] = 0;
    return 0;
d278 1
a278 2
TimLibError
SpsTg8WriteAction(SpsTg8DrvrAction * ap, int anum, int m)
d281 21
a301 15
    SpsTg8DrvrActionAddress ad;
    int             i,
                    clear;

    if (anum) {			/* Clear action ? */
	clear = 1;
	atabs[m].Table[anum - 1] = *ap;
    } else {
	clear = 0;
	for (i = 0; i < SpsTg8DrvrACTIONS; i++) {
	    if ((atabs[m].Table[i].Frame == ap->Frame)
		&& (atabs[m].Table[i].Control == ap->Control)
		&& (atabs[m].Table[i].Delay == ap->Delay)) {	/* Already exists ? */
		anum = i + 1;
		break;
d303 26
a328 34
	}
	if (anum == 0) {
	    for (i = 0; i < SpsTg8DrvrACTIONS; i++) {
		if (atabs[m].Table[i].Frame == 0) {	/* Make a new action */
		    anum = i + 1;
		    atabs[m].Table[anum - 1] = *ap;
		    break;
		}
	    }
	}
    }
    if (anum == 0)
	return TimLibErrorNOMEM;

    if (timlib_debug == 1) {
	fprintf(stderr,
		"SpsTg8WriteAction: Writing: Frame: 0x%08X Control: 0x%08X Delay: %d\n",
		(int) ap->Frame, (int) ap->Control, (int) ap->Delay);
	fprintf(stderr, "SpsTg8WriteAction: To module: %d Action row: %d\n", (int) m + 1, (int) anum);
    }

    if (clear) {
	ad.Row = anum;
	ad.Cnt = 1;
	if (ioctl(tg8s[m], SpsTg8DrvrCLEAR_ACTION, &ad) < 0) {
	    perror("Tg8SpsLibInitialize");
	    return TimLibErrorIO;
	}
    }
    if (write(tg8s[m], ap, sizeof(SpsTg8DrvrAction)) <= 0) {
	perror("SpsTg8WriteAction");
	return TimLibErrorIO;
    }
    return TimLibErrorSUCCESS;
d339 1
a339 2
TimLibError
SpsTg8WriteAllActions()
d342 24
a365 25
    int             i,
                    m;
    TimLibError     err;
    SpsTg8DrvrActionAddress ad;

    ad.Row = 1;
    ad.Cnt = 255;

    for (m = 0; m < SpsTg8DrvrMODULES; m++) {
	if (tg8s[m]) {
	    if (ioctl(tg8s[m], SpsTg8DrvrCLEAR_ACTION, &ad) < 0) {
		perror("Tg8SpsLibInitialize");
		return TimLibErrorIO;
	    }
	    for (i = 0; i < SpsTg8DrvrACTIONS; i++) {
		if (atabs[m].Table[i].Frame == 0)
		    break;
		err = SpsTg8WriteAction(&(atabs[m].Table[i]), i + 1, m);
		if (err != TimLibErrorSUCCESS)
		    return err;
	    }
	    fprintf(stderr, "SpsTg8WriteAllActions: All written to Module:%d\n", m + 1);
	}
    }
    return TimLibErrorSUCCESS;
d375 1
a375 2
TimLibError
SpsTg8WipeMemory()
d378 2
a379 2
    int             m;
    SpsTg8DrvrActionAddress ad;
d381 2
a382 2
    ad.Row = 1;
    ad.Cnt = 255;
d384 2
a385 2
    bzero((void *) ctims, sizeof(SpsTg8DrvrCtimObjects));
    bzero((void *) ptims, sizeof(SpsTg8DrvrPtimObjects));
d387 11
a397 11
    for (m = 0; m < SpsTg8DrvrMODULES; m++) {
	bzero((void *) &atabs[m], sizeof(SpsTg8DrvrActionTable));
	if (tg8s[m]) {
	    if (ioctl(tg8s[m], SpsTg8DrvrCLEAR_ACTION, &ad) < 0) {
		perror("Tg8SpsLibInitialize");
		return TimLibErrorIO;
	    }
	    fprintf(stderr, "SpsTg8WipeMemory: Module:%d Memory Wiped clean OK\n", m + 1);
	}
    }
    return TimLibErrorSUCCESS;
d408 1
a408 2
TimLibError
SpsTg8ReadAction(SpsTg8DrvrAction * ap, int anum, int m)
d411 10
a420 10
    *ap = atabs[m].Table[anum - 1];
    if ((ap->Control & 0xF000) == 0) {
	if (timlib_debug == 1) {
	    fprintf(stderr,
		    "SpsTg8ReadAction: Read: Frame: 0x%08X Control: 0x%08X Delay: %d\n",
		    (int) ap->Frame, (int) ap->Control, (int) ap->Delay);
	    fprintf(stderr, "SpsTg8ReadAction: From module: %d Action row: %d\n", (int) m + 1, (int) anum);
	}
    }
    return TimLibErrorSUCCESS;
d444 1
a444 2
TimLibError
Tg8SpsLibInitialize(TimLibDevice device)
d447 15
a461 19
    int             m,
                    ok,
                    module;
    TimLibError     err;

    if ((device == TimLibDevice_ANY)
	|| (device == TimLibDevice_TG8_SPS)) {

	ok = 0;
	for (module = 1; module <= SpsTg8DrvrMODULES; module++) {
	    if (SpsTg8Open(module) != 0) {
		ok = 1;
		m = module - 1;
		if (ioctl(tg8s[m], SpsTg8DrvrENABLE_MODULE, NULL) < 0) {
		    close(tg8s[m]);
		    tg8s[m] = 0;
		    perror("SpsTg8LibInitialize");
		    return TimLibErrorIO;
		}
d463 7
a469 6
	}
	if (ok) {
	    if (timlib_debug == 1)
		fprintf(stderr,
			"Tg8SpsLibInitialize: Found SPS TG8 module: %d on file descriptor: %d %s OK\n",
			(int) module, (int) tg8s[m], fnm);
d471 3
a473 8
	    err = AttachMemory();
	    if (err != TimLibErrorSUCCESS)
		return err;

	    if (timlib_debug == 2)
		err = SpsTg8WriteAllActions();
	    if (err != TimLibErrorSUCCESS)
		return err;
d475 3
a477 2
	    if (timlib_debug == 3)
		err = SpsTg8WipeMemory();
d480 8
a487 4
	} else
	    return TimLibErrorOPEN;
    }
    return TimLibErrorINIT;
d502 3
a504 4
TimLibError
Tg8SpsLibConnect(TimLibClass iclss,	/* Class of interrupt */
		 unsigned long equip,	/* Equipment or hardware mask */
		 unsigned long module)
d506 41
a546 32
    int             i,
                    m;
    SpsTg8DrvrCtimBinding *ctimp;
    SpsTg8DrvrPtimBinding *ptimp;
    SpsTg8DrvrAction act;
    TimLibError     err;

    if (module > SpsTg8DrvrMODULES)
	return TimLibErrorMODULE;
    m = 0;
    if (module)
	m = module - 1;

    if (!(tg8s[m]))
	return TimLibErrorMODULE;

    if (iclss == TimLibClassCTIM) {

	if (timlib_debug == 1)
	    fprintf(stderr, "Tg8SpsLibConnect: To Ctim:%d on Module:%d\n", (int) equip, (int) m + 1);

	for (i = 0; i < ctims->Size; i++) {
	    ctimp = &(ctims->Objects[i]);
	    if (ctimp->EqpNum == equip) {
		act.Frame = ctimp->Frame;
		act.Control = 0x8000;
		act.Delay = 0;
		return SpsTg8WriteAction(&act, 0, m);
	    }
	}
	return TimLibErrorCTIM;
    }
d548 12
a559 22
    else if (iclss == TimLibClassPTIM) {
	for (i = 0; i < ptims->Size; i++) {
	    ptimp = &(ptims->Objects[i]);
	    if (ptimp->EqpNum == equip) {
		if (!module)
		    m = ptimp->ModuleIndex;

		if (timlib_debug == 1)
		    fprintf(stderr, "Tg8SpsLibConnect: To Ptim:%d on Module:%d\n", (int) equip, (int) m + 1);

		if (ptimp->ModuleIndex != m)
		    return TimLibErrorMODULE;
		err = SpsTg8ReadAction(&act, ptimp->StartIndex + 1, m);
		if (err != TimLibErrorSUCCESS)
		    return err;
		act.Control |= 0xC000;
		return SpsTg8WriteAction(&act, ptimp->StartIndex + 1, m);
	    }
	}
	return TimLibErrorPTIM;
    }
    return TimLibErrorNOT_IMP;
d568 2
a569 3
TimLibError
Tg8SpsLibQueue(unsigned long qflag,	/* 0=>Queue, 1=>NoQueue */
	       unsigned long tmout)
d572 2
a573 2
    QFlag = qflag;
    TmOut = tmout;
d575 1
a575 1
    return TimLibErrorSUCCESS;
d604 13
a616 14
TimLibError
Tg8SpsLibWait(TimLibClass * iclass,	/* Class of interrupt */
	      unsigned long *equip,	/* PTIM CTIM or hardware mask */
	      unsigned long *plnum,	/* Ptim line number 1..n or 0 */
	      TimLibHardware * source,	/* Hardware source of interrupt */
	      TimLibTime * onzero,	/* Time of interrupt/output */
	      TimLibTime * trigger,	/* Time of counters load */
	      TimLibTime * start,	/* Time of counters start */
	      unsigned long *ctim,	/* CTIM trigger equipment ID */
	      unsigned long *payload,	/* Payload of trigger event */
	      unsigned long *module,	/* Module that interrupted */
	      unsigned long *missed,	/* Number of missed interrupts */
	      unsigned long *qsize,	/* Remaining interrupts on queue */
	      unsigned long *machine)
d619 106
a724 60
    SpsTg8DrvrEvent rbuf;
    SpsTg8DrvrAction *actp;
    SpsTg8DrvrActionTable atab;
    SpsTg8DrvrPtimBinding *ptimp;
    SpsTg8DrvrCtimBinding *ctimp;

    fd_set          rdset;
    struct timeval  tv;
    struct timeval *ptv;
    struct timezone tz;
    int             i,
                    m,
                    cnt,
                    cc,
                    found;

    TimLibClass     xclass = TimLibClassHARDWARE;
    unsigned long   xequip = 0;
    unsigned long   xplnum = 0;
    TimLibHardware  xsource = TimLibHardwareCTIM;
    TimLibTime      xonzero = { 0, 0, 0, TgmMACHINE_NONE };
    TimLibTime      xtrigger = { 0, 0, 0, TgmMACHINE_NONE };
    TimLibTime      xstart = { 0, 0, 0, TgmMACHINE_NONE };
    unsigned long   xctim = 0;
    unsigned long   xpayload = 0;
    unsigned long   xmodule = 0;
    unsigned long   xmissed = 0;
    unsigned long   xqsize = 0;
    unsigned long   xmachine = 0;

    cnt = 1;
    FD_ZERO(&rdset);
    for (m = 0; m < SpsTg8DrvrMODULES; m++) {
	if (tg8s[m]) {
	    if (QFlag)
		ioctl(tg8s[m], SpsTg8DrvrPURGE_QUEUE, NULL);
	    FD_SET(tg8s[m], &rdset);
	    cnt++;
	}
    }

    if (TmOut) {
	ptv = &tv;
	tv.tv_sec = TmOut / 1000000;
	tv.tv_usec = TmOut % 1000000;
    } else
	ptv = NULL;

    tz.tz_minuteswest = 0;
    tz.tz_dsttime = 0;

    cc = select(cnt, &rdset, NULL, NULL, ptv);
    gettimeofday(&tv, &tz);
    if (cc == 0)
	return TimLibErrorTIMEOUT;

    xmodule = 0;
    for (m = 0; m < SpsTg8DrvrMODULES; m++) {
	if ((tg8s[m]) && (FD_ISSET(tg8s[m], &rdset))) {
	    xmodule = m + 1;
d726 16
a741 50
	}
    }
    if (xmodule == 0)
	return TimLibErrorTIMEOUT;

    cc = read(tg8s[m], &rbuf, sizeof(SpsTg8DrvrEvent));
    if (cc <= 0) {
	perror("Tg8SpsLibWait");
	return TimLibErrorIO;
    } else {
	ioctl(tg8s[m], SpsTg8DrvrGET_QUEUE_LENGTH, &xqsize);
	xmissed = 0;
	if (xqsize >= 128)
	    xmissed = 1;

	bzero((void *) &atab, sizeof(SpsTg8DrvrActionTable));
	atab.Row = rbuf.Inter.Ext.Act;
	atab.Cnt = 1;
	actp = &(atab.Table[0]);
	if (ioctl(tg8s[m], SpsTg8DrvrUSER_TABLE, &atab) < 0) {
	    perror("Tg8SpsLibWait");
	    return TimLibErrorIO;
	}
	actp->Control &= SpsTg8DrvrCONTROL_BITS;
	if (actp->Control == 0x8000)
	    xclass = TimLibClassCTIM;
	else
	    xclass = TimLibClassPTIM;

	xmachine = (rbuf.Inter.Frame & 0xF0000000) >> 28;
	xmachine = TgvTgvToTgmMachine(xmachine);

	xpayload = rbuf.Inter.Frame & 0xFFFF;

	xonzero.Second = tv.tv_sec;
	xonzero.Nano = tv.tv_usec * 1000;
	xonzero.CTrain = rbuf.Inter.Out;
	xonzero.Machine = xmachine;

	xstart = xtrigger = xonzero;
	xtrigger.CTrain = rbuf.Inter.Occ;

	found = 0;
	for (i = 0; i < ctims->Size; i++) {
	    ctimp = &(ctims->Objects[i]);
	    if (ctimp->Frame == rbuf.Frame) {
		xequip = xctim = ctimp->EqpNum;
		xsource = TimLibHardwareCTIM;
		found = 1;
		break;
d743 32
a774 3
	}
	if (!found)
	    return TimLibErrorCTIM;
d776 1
a776 47
	if (xclass == TimLibClassPTIM) {
	    found = 0;
	    for (i = 0; i < ptims->Size; i++) {
		ptimp = &(ptims->Objects[i]);
		if ((atab.Row >= ptimp->StartIndex)
		    && (atab.Row < ptimp->StartIndex + ptimp->Size + 1)) {
		    found = 1;
		    xequip = ptimp->EqpNum;
		    xmodule = ptimp->ModuleIndex + 1;
		    xplnum = 1;
		    xsource = ptimp->Counter;
		    break;
		}
	    }
	    if (!found)
		return TimLibErrorPTIM;
	}
    }

    if (iclass)
	*iclass = xclass;
    if (equip)
	*equip = xequip;
    if (plnum)
	*plnum = xplnum;
    if (source)
	*source = xsource;
    if (onzero)
	*onzero = xonzero;
    if (trigger)
	*trigger = xtrigger;
    if (start)
	*start = xstart;
    if (ctim)
	*ctim = xctim;
    if (payload)
	*payload = xpayload;
    if (module)
	*module = xmodule;
    if (missed)
	*missed = xmissed;
    if (qsize)
	*qsize = xqsize;
    if (machine)
	*machine = xmachine;

    return TimLibErrorSUCCESS;
d785 6
a790 7
TimLibError
Tg8SpsLibSet(unsigned long ptim,	/* PTIM to write to */
	     unsigned long plnum,	/* Ptim line number 1..n or 0 */
	     unsigned long grnum,	/* Tgm group number or Zero */
	     unsigned long grval,	/* Group value if num not zero */
	     TimLibCcvMask ccvm,	/* Which values to write */
	     TimLibCcv * ccv)
d793 68
a860 21
    int             i,
                    m,
                    msk,
                    cntr,
                    found;
    SpsTg8DrvrPtimBinding *ptimp;
    SpsTg8DrvrAction act;
    TimLibError     err;

    found = 0;
    for (i = 0; i < ptims->Size; i++) {
	ptimp = &(ptims->Objects[i]);
	if (ptimp->EqpNum == ptim) {
	    m = ptimp->ModuleIndex;
	    if (!tg8s[m])
		return TimLibErrorMODULE;
	    cntr = ptimp->Counter & 0x7;
	    err = SpsTg8ReadAction(&act, ptimp->StartIndex + 1, m);
	    if (err != TimLibErrorSUCCESS)
		return err;
	    found = 1;
a861 86
	}
    }
    if (!found)
	return TimLibErrorPTIM;

    if ((grnum) || (plnum > 1))
	return TimLibErrorPPM;	/* No PPM allowed */

    msk = 1;
    do {
	if (ccvm & msk) {
	    switch ((TimLibCcvMask) msk) {
	    case TimLibCcvMaskENABLE:
		if (ccv->Enable)
		    act.Control |= 0x4000;
		else
		    act.Control &= ~0x4000;
		break;

	    case TimLibCcvMaskSTART:
		if (ccv->Start >= TimLibSTARTS)
		    return TimLibErrorSTART;
		if (ccv->Start == TimLibStartNORMAL) {
		    act.Control &= 0xFF0F;
		} else if (ccv->Start == TimLibStartCHAINED) {
		    act.Control &= 0xFF0F;
		    act.Control |= 0x0040;
		} else if (ccv->Start == TimLibStartEXT1) {
		    act.Control &= 0xFF0F;
		    act.Control |= 0x0080;
		} else
		    return TimLibErrorSTART;
		break;

	    case TimLibCcvMaskCLOCK:
		if (ccv->Clock >= TimLibCLOCKS)
		    return TimLibErrorCLOCK;
		if (ccv->Clock == TimLibClock1KHZ) {
		    act.Control &= 0xFFF0;
		} else if (ccv->Clock == TimLibClock10MHZ) {
		    act.Control &= 0xFFF0;
		    act.Control |= 0x0001;
		} else if (ccv->Clock == TimLibClockEXT1) {
		    act.Control &= 0xFFF0;
		    act.Control |= 0x0002;
		} else if (ccv->Clock == TimLibClockEXT2) {
		    act.Control &= 0xFFF0;
		    act.Control |= 0x0003;
		} else
		    return TimLibErrorCLOCK;
		break;

	    case TimLibCcvMaskCTIM:
		found = 0;
		for (i = 0; i < ctims->Size; i++) {
		    if (ctims->Objects[i].EqpNum == ccv->Ctim) {
			act.Frame = ctims->Objects[i].Frame;
			act.Control = 0x4000 | (cntr << 8);
			act.Delay = 1;
			found = 1;
			break;
		    }
		}
		if (!found)
		    return TimLibErrorCTIM;
		break;

	    case TimLibCcvMaskPAYLOAD:
		act.Frame &= 0xFFFF0000;
		act.Frame |= (ccv->Payload & 0xFFFF);
		break;

	    case TimLibCcvMaskDELAY:
		act.Delay = ccv->Delay;
		break;

	    case TimLibCcvMaskMODE:
	    case TimLibCcvMaskOMASK:
	    case TimLibCcvMaskPWIDTH:
	    case TimLibCcvMaskPOLARITY:
		return TimLibErrorNOT_IMP;

	    case TimLibCcvMaskMACHINE:
	    case TimLibCcvMaskGRNUM:
	    case TimLibCcvMaskGRVAL:
		return TimLibErrorPPM;
d863 10
a872 2
	    default:
		break;
d874 8
a881 3
	}
	msk <<= 1;
    } while (msk & TimLibCcvMaskBITS);
d883 24
a906 1
    return SpsTg8WriteAction(&act, ptimp->StartIndex + 1, m);
d914 2
a915 3
TimLibError
Tg8SpsLibGet(unsigned long ptim, unsigned long grnum, unsigned long grval, TimLibCcvMask * ccvm,	/* Valid fields in ccv */
	     TimLibCcv * ccv)
d918 54
a971 56
    int             i,
                    m,
                    found;
    SpsTg8DrvrPtimBinding *ptimp;
    SpsTg8DrvrAction act;
    TimLibError     err;

    bzero((void *) ccv, sizeof(TimLibCcv));
    if (grnum)
	return TimLibErrorPPM;

    found = 0;
    for (i = 0; i < ptims->Size; i++) {
	ptimp = &(ptims->Objects[i]);
	if (ptimp->EqpNum == ptim) {
	    m = ptimp->ModuleIndex;
	    if (!tg8s[m])
		return TimLibErrorMODULE;
	    err = SpsTg8ReadAction(&act, ptimp->StartIndex + 1, m);
	    if (err != TimLibErrorSUCCESS)
		return err;
	    found = 1;
	    break;
	}
    }
    if (!found)
	return TimLibErrorPTIM;

    *ccvm = TimLibCcvMaskENABLE
	| TimLibCcvMaskSTART | TimLibCcvMaskCLOCK | TimLibCcvMaskDELAY | TimLibCcvMaskCTIM | TimLibCcvMaskPAYLOAD;

    if (act.Control & 0x4000)
	ccv->Enable = 1;
    if (act.Control & 0x0040)
	ccv->Start = TimLibStartCHAINED;
    if (act.Control & 0x0080)
	ccv->Start = TimLibStartEXT1;

    if ((act.Control & 0x0003) == 3)
	ccv->Clock = TimLibClockEXT2;
    if ((act.Control & 0x0002) == 2)
	ccv->Clock = TimLibClockEXT2;

    ccv->Delay = act.Delay;
    ccv->Payload = act.Frame & 0xFFFF;

    found = 0;
    for (i = 0; i < ctims->Size; i++) {
	if ((0xFFFF0000 & ctims->Objects[i].Frame) == (0xFFFF0000 & act.Frame)) {
	    ccv->Ctim = ctims->Objects[i].EqpNum;
	    found = 1;
	    break;
	}
    }
    if (!found)
	return TimLibErrorCTIM;
d973 1
a973 1
    return TimLibErrorSUCCESS;
d997 1
a997 1
    return TimLibErrorNOT_IMP;
d1005 6
a1010 7
TimLibError
Tg8SpsLibRemoteControl(unsigned long remflg,	/* 0 = Normal, 1 = Remote */
		       unsigned long module,	/* Module or zero */
		       unsigned long cntr,	/* 1..8 counter number */
		       TimLibRemote rcmd,	/* Command */
		       TimLibCcvMask ccvm,	/* Fields to be set */
		       TimLibCcv * ccv)
d1013 1
a1013 2
    int             msk,
                    m;
d1015 15
a1029 15
    if (rcmd == TimLibRemoteOUT) {
	msk = (1 << cntr) & 0xFF;
	m = 0;
	if (module)
	    m = module - 1;
	if (tg8s[m]) {
	    if (ioctl(tg8s[m], SpsTg8DrvrSIMULATE_PULSE, &msk) < 0) {
		perror("Tg8SpsLibRemoteControl");
		return TimLibErrorIO;
	    }
	    if (timlib_debug == 1)
		fprintf(stderr, "Tg8SpsLibRemoteControl: Output pulse on Counter:%d Module:%d\n", (int) cntr, (int) module);
	}
    }
    return TimLibErrorNO_REMOTE;
d1038 2
a1039 3
TimLibError
Tg8SpsLibGetTime(unsigned long module,	/* Module number to read from */
		 TimLibTime * utc)
d1042 2
a1043 2
    struct timeval  tv;
    struct timezone tz;
d1045 2
a1046 2
    tz.tz_minuteswest = 0;
    tz.tz_dsttime = 0;
d1048 1
a1048 1
    gettimeofday(&tv, &tz);
d1050 4
a1053 4
    utc->Second = tv.tv_sec;
    utc->Nano = tv.tv_usec * 1000;
    utc->CTrain = 0;
    utc->Machine = TgmMACHINE_NONE;
d1055 1
a1055 1
    return TimLibErrorSUCCESS;
d1079 1
a1079 2
TimLibError
Tg8SpsLibGetTelegram(unsigned long module, TgmMachine machine, TgmPTelegram * telegram)
d1081 19
a1099 20
    SpsTg8DrvrTelegram spstgm;
    int             i,
                    m;

    m = 0;
    if (module)
	m = module - 1;
    if (tg8s[m] == 0)
	return TimLibErrorMODULE;

    spstgm.Machine = TgvTgmToTgvMachine(machine);
    if (ioctl(tg8s[m], SpsTg8DrvrTELEGRAM, &spstgm) < 0) {
	perror("Tg8SpsLibGetTelegram");
	return TimLibErrorIO;
    }
    bzero((void *) telegram, sizeof(TgmTelegram));
    telegram->Machine = machine;
    telegram->Size = TgmLastGroupNumber(machine);
    for (i = 0; i < telegram->Size; i++)
	telegram->Groups[i] = spstgm.Data[i];
d1101 1
a1101 1
    return TimLibErrorSUCCESS;
d1109 1
a1109 2
unsigned long
Tg8SpsLibGetInstalledModuleCount()
d1112 2
a1113 2
    unsigned long   cnt = 0;
    int             m;
d1115 4
a1118 4
    for (m = 0; m < SpsTg8DrvrMODULES; m++)
	if (tg8s[m])
	    cnt++;
    return cnt;
d1127 2
a1128 3
TimLibError
Tg8SpsLibGetPtimObject(unsigned long ptim,	/* PTIM equipment number */
		       unsigned long *module, unsigned long *counter, unsigned long *dimension)
d1131 1
a1131 1
    int             i;
d1133 9
a1141 9
    for (i = 0; i < ctims->Size; i++) {
	if (ptims->Objects[i].EqpNum == ptim) {
	    *module = ptims->Objects[i].ModuleIndex + 1;
	    *counter = ptims->Objects[i].Counter;
	    *dimension = ptims->Objects[i].Size;
	    return TimLibErrorSUCCESS;
	}
    }
    return TimLibErrorPTIM;
d1149 2
a1150 3
TimLibError
Tg8SpsLibGetCtimObject(unsigned long ctim,	/* CTIM equipment number */
		       unsigned long *eventcode)
d1153 1
a1153 1
    int             i;
d1155 7
a1161 7
    for (i = 0; i < ctims->Size; i++) {
	if (ctims->Objects[i].EqpNum == ctim) {
	    *eventcode = ctims->Objects[i].Frame;
	    return TimLibErrorSUCCESS;
	}
    }
    return TimLibErrorCTIM;
d1173 1
a1173 2
TimLibError
Tg8SpsLibGetHandle(int *fd)
d1176 4
a1179 4
    if (tg8s[0] == 0)
	return TimLibErrorINIT;
    *fd = tg8s[0];
    return TimLibErrorSUCCESS;
d1187 2
a1188 3
TimLibError
Tg8SpsLibCreatePtimObject(unsigned long ptim,	/* PTIM equipment number */
			  unsigned long module, unsigned long counter, unsigned long dimension)
d1190 49
a1238 52
    SpsTg8DrvrAction act;
    int             m,
                    i,
                    anum,
                    cntr;

    if ((module < 1) || (module > SpsTg8DrvrMODULES))
	return TimLibErrorMODULE;
    m = module - 1;
    if (!tg8s[m])
	return TimLibErrorMODULE;
    if ((counter < 1) || (counter > 8))
	return TimLibErrorCOUNTER;

    if (dimension != 1)
	return TimLibErrorPPM;

    for (i = 0; i < ptims->Size; i++) {
	if (ptims->Objects[i].EqpNum == ptim) {
	    return TimLibErrorEXISTS;
	}
    }
    anum = 0;
    for (i = 0; i < SpsTg8DrvrACTIONS; i++) {
	if (atabs[m].Table[i].Frame == 0) {
	    anum = i + 1;
	    break;
	}
    }
    if (anum == 0)
	return TimLibErrorNOMEM;

    i = ptims->Size;
    if (i < SpsTg8DrvrPtimOBJECTS) {
	ptims->Objects[i].EqpNum = ptim;
	ptims->Objects[i].ModuleIndex = m;
	ptims->Objects[i].Counter = counter;
	ptims->Objects[i].Size = 1;
	ptims->Objects[i].StartIndex = anum - 1;
	ptims->Size++;
    }

    /*
     * Need to do this next step to be sure that space is reserved in the atab 
     */

    for (i = 0; i < dimension; i++) {
	cntr = counter & 0x7;
	act.Frame = 0x2101FFFF;	/* OX.NSSC-MTG */
	act.Control = (cntr << 8) | 0x4000;
	act.Delay = 1;
    }
d1240 1
a1240 1
    return SpsTg8WriteAction(&act, anum, m);
d1249 2
a1250 3
TimLibError
Tg8SpsLibCreateCtimObject(unsigned long ctim,	/* CTIM equipment number */
			  unsigned long eventcode)
d1252 1
a1252 1
    int             i;
d1254 12
a1265 12
    for (i = 0; i < ctims->Size; i++) {
	if (ctims->Objects[i].EqpNum == ctim) {
	    return TimLibErrorEXISTS;
	}
    }
    if (ctims->Size < SpsTg8DrvrCtimOBJECTS) {
	ctims->Objects[i].EqpNum = ctim;
	ctims->Objects[i].Frame = eventcode;
	ctims->Size++;
	return TimLibErrorSUCCESS;
    }
    return TimLibErrorNOMEM;
@


1.14
log
@*** empty log message ***
@
text
@d1 8
a8 9
/* ==================================================================== */
/* Implement the timing library over the SPS-TG8 timing receiver.        */
/* Julian Lewis Nov 2004                                                */
/* ==================================================================== */

#include <dtm.h>                /* Distributed shared memory Table Manager */
#include <tgm.h>
#include <TimLib.h>
#include <sys/shm.h>            /* Shared memory */
d15 8
a22 3
/* General note: I can't include the SPS TG8 driver definitions in the same */
/* compilation unit because they clash with those of the CPS TG8 driver. So */
/* I will define what I need here using symbols starting with SpsTg8.       */
d31 48
a78 48
   SpsTg8DrvrDEBUG_ON,
   SpsTg8DrvrDEBUG_OFF,
   SpsTg8DrvrGET_DRI_VERSION,
   SpsTg8DrvrGET_FIRMWARE_VERSION,
   SpsTg8DrvrSET_TIME_OUT,
   SpsTg8DrvrSET_SSC_HEADER,
   SpsTg8DrvrENABLE_SYNC,
   SpsTg8DrvrDISABLE_SYNC,
   SpsTg8DrvrENABLE_MODULE,
   SpsTg8DrvrDISABLE_MODULE,
   SpsTg8DrvrRESET_MODULE,
   SpsTg8DrvrINSTALL_MODULE,
   SpsTg8DrvrGET_CONFIGURATION,
   SpsTg8DrvrSIMULATE_PULSE,
   SpsTg8DrvrUSER_TABLE,
   SpsTg8DrvrRECORDING_TABLE,
   SpsTg8DrvrINTERRUPT_TABLE,
   SpsTg8DrvrHISTORY_TABLE,
   SpsTg8DrvrCLOCK_TABLE,
   SpsTg8DrvrAUX_TABLE,
   SpsTg8DrvrSC_INFO,
   SpsTg8DrvrTELEGRAM,
   SpsTg8DrvrTRACE_FIRMWARE,
   SpsTg8DrvrDATE_TIME,
   SpsTg8DrvrGET_RAW_STATUS,
   SpsTg8DrvrGET_STATUS,
   SpsTg8DrvrGET_DPRAM,
   SpsTg8DrvrRELOAD_FIRMWARE,
   SpsTg8DrvrRELOAD_ACTIONS,
   SpsTg8DrvrON_CLOSE,
   SpsTg8DrvrSET_SIGNAL,
   SpsTg8DrvrGET_SIGNAL,
   SpsTg8DrvrGET_QUEUE_LENGTH,
   SpsTg8DrvrPURGE_QUEUE,
   SpsTg8DrvrSET_ACTION_STATE,
   SpsTg8DrvrCLEAR_ACTION,
   SpsTg8DrvrWAIT_EVENT,
   SpsTg8DrvrFILTER_EVENT,
   SpsTg8DrvrGET_PPM_LINE,
   SpsTg8DrvrSET_OBJECT,
   SpsTg8DrvrREMOVE_OBJECT,
   SpsTg8DrvrGET_OBJECT,
   SpsTg8DrvrCONNECT,
   SpsTg8DrvrOBJECT_PARAM,
   SpsTg8DrvrOBJECTS_LIST,
   SpsTg8DrvrTEST_DPRAM,
   SpsTg8DrvrCARD_TEST,
 } SpsTg8Drvr;
d81 4
a84 4
   unsigned long  Frame;
   unsigned short Control;
   unsigned short Delay;
 } SpsTg8DrvrAction;
d87 3
a89 3
   unsigned long Row;
   unsigned long Cnt;
 } SpsTg8DrvrActionAddress;
d92 4
a95 4
   unsigned long Row;
   unsigned long Cnt;
   SpsTg8DrvrAction Table[SpsTg8DrvrACTIONS];
 } SpsTg8DrvrActionTable;
d98 4
a101 4
  unsigned char RcvErr;  /* Value of the reception error register */
  unsigned char OvwrAct; /* Which action was overwitten (if not 0x00) */
  unsigned char Act;     /* Which action was triggered and fired */
  unsigned char Sem;     /* Semaphore to solve the read/write conflicts */
d105 5
a109 5
  unsigned long   Frame;  /* The trigger event frame */
  unsigned int    Sc;     /* The Super Cycle number */
  unsigned int    Occ;    /* Occurence time from the start of the last S-Cycle */
  unsigned int    Out;    /* Output time from the start of the last S-Cycle */
  SpsTg8IntAction Ext;    /* Extra data concerning the interrupted action */
d113 6
a118 6
   unsigned int    Id;      /* Timing object identifier */
   unsigned long   Frame;   /* Declared timing event (wildcards allowed) */
   SpsTg8Interrupt Inter;   /* Interrupt information */
   unsigned short  Alarms;  /* The firmware alarms bit mask ORed with the driver alarms bit mask */
   unsigned char   FwStat;  /* Firmware status */
   unsigned char   DevMask; /* Target devices bitmask */
d122 7
a128 5
    int            Machine;                /* Acc. machine number */
    unsigned short Data[SpsTg8DrvrGROUPS]; /* Telegram buffer */
  } SpsTg8DrvrTelegram;                    /* SPS driver telegram */

/* CTIM object bindings */
d133 3
a135 3
   unsigned long EqpNum;
   unsigned long Frame;
 } SpsTg8DrvrCtimBinding;
d138 7
a144 5
   unsigned short        Size;
   SpsTg8DrvrCtimBinding Objects[SpsTg8DrvrCtimOBJECTS];
 } SpsTg8DrvrCtimObjects;

/* PTIM object bindings */
d149 6
a154 6
   unsigned long  EqpNum;
   unsigned char  ModuleIndex;
   unsigned char  Counter;
   unsigned short Size;
   unsigned short StartIndex;
 } SpsTg8DrvrPtimBinding;
d157 3
a159 3
   unsigned short        Size;
   SpsTg8DrvrPtimBinding Objects[SpsTg8DrvrPtimOBJECTS];
 } SpsTg8DrvrPtimObjects;
d163 2
a164 2
static int QFlag = 0;
static int TmOut = 20000000;
d167 145
a311 121
/* ==================================================================== */
/* Keep copy of PTIM and CTIM equipments in shared memory so that all   */
/* tasks can access them. Also keep the action tables here.             */
/* ==================================================================== */

TimLibError AttachMemory() {

int shmkey, shmid;

   if (ctims == NULL) {
      shmkey = DtmGetKey("CTIMS");
      shmid  = shmget(shmkey, sizeof(SpsTg8DrvrCtimObjects), IPC_CREAT | 0666);
      ctims  = (SpsTg8DrvrCtimObjects *) shmat(shmid, NULL, 0);
      if ((int) ctims == -1) {
	 ctims = NULL;
	 return TimLibErrorNOMEM;
      }
   }
   if (timlib_debug) fprintf(stderr,"AttachMemory: CTIMS key:%d id:%d OK\n",shmkey,shmid);

   if (ptims == NULL) {
      shmkey = DtmGetKey("PTIMS");
      shmid  = shmget(shmkey, sizeof(SpsTg8DrvrPtimObjects), IPC_CREAT | 0666);
      ptims  = (SpsTg8DrvrPtimObjects *) shmat(shmid, NULL, 0);
      if ((int) ptims == -1) {
	 ptims = NULL;
	 return TimLibErrorNOMEM;
      }
   }
   if (timlib_debug) fprintf(stderr,"AttachMemory: PTIMS key:%d id:%d OK\n",shmkey,shmid);

   if (atabs == NULL) {
      shmkey = DtmGetKey("ATABS");
      shmid  = shmget(shmkey, sizeof(SpsTg8DrvrActionTable) * SpsTg8DrvrMODULES, IPC_CREAT | 0666);
      atabs  = (SpsTg8DrvrActionTable *) shmat(shmid, NULL, 0);
      if ((int) atabs == -1) {
	 atabs = NULL;
	 return TimLibErrorNOMEM;
      }
   }
   if (timlib_debug) fprintf(stderr,"AttachMemory: ATABS key:%d id:%d OK\n",shmkey,shmid);

   return TimLibErrorSUCCESS;
}

/* ======================================================================== */
/* Open the SPS Tg8 driver for a module.  The SPS driver reserves sets      */
/* of <CLIENTS_PER_MODULE> file nodes in /dev for up to <SpsTg8DrvrMODULES> */
/* Tg8 modules.                                                             */
/* ======================================================================== */

static char fnm[32];

static int tg8s[SpsTg8DrvrMODULES] = {0,0,0,0}; /* This global holds the SPS TG8 Driver file handle */

static int SpsTg8Open(int module) {

char ver[32];
int  i, m, fnum;

   if ((module < 1) || (module > SpsTg8DrvrMODULES)) return 0;

   m = module -1;
   if (tg8s[m]) return tg8s[m];

   for (i=0; i<SpsTg8DrvrCLIENTS_PER_MODULE; i++) {
      fnum = (m * SpsTg8DrvrCLIENTS_PER_MODULE) + i + 1;
      sprintf(fnm,"/dev/Tg8.%1d",fnum);
      if ((tg8s[m] = open(fnm,O_RDWR,0)) > 0) {

	 /* The CPS Tg8 driver returns a long version string <__DATE__ __TIME__> */
	 /* while the SPS Tg8 driver returns a short version string <__DATE__>   */

	 bzero((void *) ver, 32);
	 if (ioctl(tg8s[m],SpsTg8DrvrGET_FIRMWARE_VERSION,&ver) < 0) {
	    perror("SpsTg8Open");
	    ver[0] = 0;
	 }
	 if ((strlen(ver) > 0)
	 &&  (strlen(ver) < (strlen(__DATE__) + 4))) { /* Is it an SPS TG8 ? */
	    return tg8s[m];                            /* Yes */
	 }
	 close(tg8s[m]);
	 tg8s[m] = 0;                                  /* No it a PS TG8 */
	 return 0;                                     /* No point in continuing */
      }
   }
   tg8s[m] = 0;
   return 0;
}

/* ======================================================================== */
/* Write an action to a module                                              */
/* If anum is zero I make a new action if it dosn't exist already.          */
/* Else anum is overwritten by clear and write.                             */
/* ======================================================================== */

TimLibError SpsTg8WriteAction(SpsTg8DrvrAction *ap, int anum, int m) {

SpsTg8DrvrActionAddress ad;
int i, clear;

   if (anum) {                                  /* Clear action ? */
      clear = 1;
      atabs[m].Table[anum -1] = *ap;
   } else {
      clear = 0;
      for (i=0; i<SpsTg8DrvrACTIONS; i++) {
	 if ((atabs[m].Table[i].Frame   == ap->Frame)
	 &&  (atabs[m].Table[i].Control == ap->Control)
	 &&  (atabs[m].Table[i].Delay   == ap->Delay)) { /* Already exists ?*/
	    anum = i +1;
	    break;
	 }
      }
      if (anum == 0) {
	 for (i=0; i<SpsTg8DrvrACTIONS; i++) {
	    if (atabs[m].Table[i].Frame == 0) { /* Make a new action */
	       anum = i +1;
	       atabs[m].Table[anum -1] = *ap;
	       break;
d313 16
a328 50
	 }
      }
   }
   if (anum == 0) return TimLibErrorNOMEM;

   if (timlib_debug) {
      fprintf(stderr,
	      "SpsTg8WriteAction: Writing: Frame: 0x%08X Control: 0x%08X Delay: %d\n",
	      (int) ap->Frame,
	      (int) ap->Control,
	      (int) ap->Delay);
      fprintf(stderr,
	      "SpsTg8WriteAction: To module: %d Action row: %d\n",
	      (int) m+1,
	      (int) anum);
   }

   if (clear) {
      ad.Row = anum;
      ad.Cnt = 1;
      if (ioctl(tg8s[m],SpsTg8DrvrCLEAR_ACTION,&ad) < 0)  {
	 perror("Tg8SpsLibInitialize");
	 return TimLibErrorIO;
      }
   }
   if (write(tg8s[m],ap,sizeof(SpsTg8DrvrAction)) <= 0) {
      perror("SpsTg8WriteAction");
      return TimLibErrorIO;
   }
   return TimLibErrorSUCCESS;
}

/* ======================================================================== */
/* Force a write back of all actions to the Tg8s from shared memory.        */
/* This can be usefull when other non TimLib application have done things   */
/* to the user table, or you just want a reset.                             */
/* ======================================================================== */

TimLibError SpsTg8WriteAllActions() {

int i, m;
TimLibError err;
SpsTg8DrvrActionAddress ad;

   ad.Row = 1;
   ad.Cnt = 255;

   for (m=0; m<SpsTg8DrvrMODULES; m++) {
      if (tg8s[m]) {
	 if (ioctl(tg8s[m],SpsTg8DrvrCLEAR_ACTION,&ad) < 0)  {
d331 74
a404 102
	 }
	 for (i=0; i<SpsTg8DrvrACTIONS; i++) {
	    if (atabs[m].Table[i].Frame == 0) break;
	    err = SpsTg8WriteAction(&(atabs[m].Table[i]), i+1, m);
	    if (err != TimLibErrorSUCCESS) return err;
	 }
	 fprintf(stderr,"SpsTg8WriteAllActions: All written to Module:%d\n",m+1);
      }
   }
   return TimLibErrorSUCCESS;
}

/* ======================================================================== */
/* Wipe out all memory CTIMS/PTIMS/Actions                                  */
/* Start with a clean slate, this can be usefull during debugging.          */
/* ======================================================================== */

TimLibError SpsTg8WipeMemory() {

int m;
SpsTg8DrvrActionAddress ad;

   ad.Row = 1;
   ad.Cnt = 255;

   bzero((void *) ctims, sizeof(SpsTg8DrvrCtimObjects));
   bzero((void *) ptims, sizeof(SpsTg8DrvrPtimObjects));

   for (m=0; m<SpsTg8DrvrMODULES; m++) {
      bzero((void *) &atabs[m], sizeof(SpsTg8DrvrActionTable));
      if (tg8s[m]) {
	 if (ioctl(tg8s[m],SpsTg8DrvrCLEAR_ACTION,&ad) < 0)  {
	    perror("Tg8SpsLibInitialize");
	    return TimLibErrorIO;
	 }
	 fprintf(stderr,"SpsTg8WipeMemory: Module:%d Memory Wiped clean OK\n",m+1);
      }
   }
   return TimLibErrorSUCCESS;
}

/* ======================================================================== */
/* Read an action from shared memory, I never read back from the TG8 as it  */
/* can return garbage in the control word. I need a real reference for what */
/* should be in the modules user table.                                     */
/* ======================================================================== */

TimLibError SpsTg8ReadAction(SpsTg8DrvrAction *ap, int anum, int m) {

   *ap = atabs[m].Table[anum -1];
   if ((ap->Control & 0xF000) == 0) {
      if (timlib_debug) {
	 fprintf(stderr,
		 "SpsTg8ReadAction: Read: Frame: 0x%08X Control: 0x%08X Delay: %d\n",
		 (int) ap->Frame,
		 (int) ap->Control,
		 (int) ap->Delay);
	 fprintf(stderr,
		 "SpsTg8ReadAction: From module: %d Action row: %d\n",
		 (int) m+1,
		 (int) anum);
      }
   }
   return TimLibErrorSUCCESS;
}

/* ==================================================================== */
/* This routine could have been hidden from the user of the Timing lib, */
/* however, in some circumstances, the initialization can take several  */
/* minutes to complete. Hence I have decided to make an initialization  */
/* routine publicly available, and force users to call it.              */
/* This routine performs the following initialization functions...      */
/*    1) Opens a connection to the driver                               */
/*    2) Checks the Firmware/VHDL version against the latest revision   */
/*       Some EProms/FPGAs may need updating, this takes a while.       */
/*    3) Load all relavent CTIM and PTIM definitions if needed.         */

/* Special behaviour for the SPS TG8 version before calling this.       */
/* The debug variable "timlib_debug" can be set from TimLibSetDebug     */
/* When its not zero, error printing is turned on, so lots of messages. */
/* When its equal to 2, the Tg8 module is reinitialized from the shared */
/*   memory segments to force its state to be as in the library.        */
/* When its equal to 3, all memory is wiped clean, and all actions in   */
/*   the Tg8 modules are cleared.                                       */

TimLibError Tg8SpsLibInitialize(TimLibDevice device) { /* Initialize hardware/software */

int m, ok, module;
TimLibError err;

   if ((device == TimLibDevice_ANY)
   ||  (device == TimLibDevice_TG8_SPS)) {

      ok = 0;
      for (module=1; module<=SpsTg8DrvrMODULES; module++) {
	 if (SpsTg8Open(module) != 0) {
	    ok = 1;
	    m = module -1;
	    if (ioctl(tg8s[m],SpsTg8DrvrENABLE_MODULE,NULL) < 0) {
	       close(tg8s[m]); tg8s[m] = 0;
	       perror("SpsTg8LibInitialize");
	       return TimLibErrorIO;
d406 21
a426 4
	 }
      }
      if (ok) {
	 if (timlib_debug)
d428 272
a699 227
		    "Tg8SpsLibInitialize: Found SPS TG8 module: %d on file descriptor: %d %s OK\n",
		    (int) module,
		    (int) tg8s[m],
		    fnm);

	 err = AttachMemory();
	 if (err != TimLibErrorSUCCESS) return err;

	 if (timlib_debug == 2) err = SpsTg8WriteAllActions();
	 if (err != TimLibErrorSUCCESS) return err;

	 if (timlib_debug == 3) err = SpsTg8WipeMemory();
	 return err;

      } else return TimLibErrorOPEN;
   }
   return TimLibErrorINIT;
}

/* ==================================================================== */
/* Connect to an interrupt. If you are connecting to either a CTIM      */
/* interrupt or to a hardware interrupt, you may need to specify on     */
/* which device the interrupt should be connected. This is achieved by  */
/* the module parameter. If the module is zero, the system will decide  */
/* which device to use, otherwise module contains a value between 1 and */
/* the number of installed timing receiver cards. For PTIM objects the  */
/* module parameter must be set to zero or the real module on which the */
/* PTIM object is implemented. On PTIM objects the module is implicit.  */

TimLibError Tg8SpsLibConnect(TimLibClass   iclss,    /* Class of interrupt */
			     unsigned long equip,    /* Equipment or hardware mask */
			     unsigned long module) { /* For HARD or CTIM classes */
int i, m;
SpsTg8DrvrCtimBinding *ctimp;
SpsTg8DrvrPtimBinding *ptimp;
SpsTg8DrvrAction       act;
TimLibError            err;

   if (module > SpsTg8DrvrMODULES) return TimLibErrorMODULE;
   m=0; if (module) m = module -1;

   if (!(tg8s[m])) return TimLibErrorMODULE;

   if (iclss == TimLibClassCTIM) {

      if (timlib_debug)
	 fprintf(stderr,"Tg8SpsLibConnect: To Ctim:%d on Module:%d\n",(int) equip, (int) m+1);

      for (i=0; i<ctims->Size; i++) {
	 ctimp = &(ctims->Objects[i]);
	 if (ctimp->EqpNum == equip) {
	    act.Frame   = ctimp->Frame;
	    act.Control = 0x8000;
	    act.Delay   = 0;
	    return SpsTg8WriteAction(&act,0,m);
	 }
      }
      return TimLibErrorCTIM;
   }

   else if (iclss == TimLibClassPTIM) {
      for (i=0; i<ptims->Size; i++) {
	 ptimp = &(ptims->Objects[i]);
	 if (ptimp->EqpNum == equip) {
	    if (!module) m = ptimp->ModuleIndex;

	    if (timlib_debug)
	       fprintf(stderr,"Tg8SpsLibConnect: To Ptim:%d on Module:%d\n",(int) equip, (int) m+1);

	    if (ptimp->ModuleIndex != m) return TimLibErrorMODULE;
	    err = SpsTg8ReadAction(&act,ptimp->StartIndex+1,m);
	    if (err != TimLibErrorSUCCESS) return err;
	    act.Control |= 0xC000;
	    return SpsTg8WriteAction(&act,ptimp->StartIndex +1,m);
	 }
      }
      return TimLibErrorPTIM;
   }
   return TimLibErrorNOT_IMP;
}

/* ==================================================================== */
/* Set queueing On or Off, and the time out value in micro seconds.     */
/* A timeout value of zero means no time out, you wait for ever.        */

TimLibError Tg8SpsLibQueue(unsigned long qflag,    /* 0=>Queue, 1=>NoQueue  */
			   unsigned long tmout) {  /* 0=>No time outs       */

   QFlag = qflag;
   TmOut = tmout;

   return TimLibErrorSUCCESS;
}

/* ==================================================================== */
/* Wait for an interrupt. The parameters are all returned from the call */
/* so you can know which interrupt it was that came back. Note, when    */
/* waiting for a hardware interrupt from either CTIM or from a counter, */
/* it is the CTIM or PTIM object that caused the interrupt returned.    */
/* The telegram will have been read already by the high prioity task    */
/* get_tgm_tg8/tg8, be aware of the race condition here, hence payload. */
/* This routine is a blocking call, it waits for interrupt or timeout.  */
/* Any NULL argument  is permitted, and no value will be returned.      */

/* Arguments:                                                           */
/*    iclss:   The class of the interrupt CTIM, PTIM, or hardware       */
/*    equip:   The PTIM, CTIM equipment, or hardware mask               */
/*    plnum:   If class is PTIM this is the PLS line number             */
/*    source:  The hardware source of the interrupt                     */
/*    onzero:  The time of the interrupt                                */
/*    trigger: The arrival time of the event that triggered the action  */
/*    start:   The time the start of the counter occured                */
/*    ctim:    The CTIM equipment number of the triggering event        */
/*    payload: The payload of the triggering event                      */
/*    module:  The module number 1..n of the timing receiver card       */
/*    missed:  The number of missed events since the last wait          */
/*    qsize:   The number of remaining interrupts on the queue          */

TimLibError Tg8SpsLibWait(TimLibClass    *iclass,  /* Class of interrupt */
			  unsigned long  *equip,   /* PTIM CTIM or hardware mask */
			  unsigned long  *plnum,   /* Ptim line number 1..n or 0 */
			  TimLibHardware *source,  /* Hardware source of interrupt */
			  TimLibTime     *onzero,  /* Time of interrupt/output */
			  TimLibTime     *trigger, /* Time of counters load */
			  TimLibTime     *start,   /* Time of counters start */
			  unsigned long  *ctim,    /* CTIM trigger equipment ID */
			  unsigned long  *payload, /* Payload of trigger event */
			  unsigned long  *module,  /* Module that interrupted */
			  unsigned long  *missed,  /* Number of missed interrupts */
			  unsigned long  *qsize) { /* Remaining interrupts on queue */

SpsTg8DrvrEvent        rbuf;
SpsTg8DrvrAction      *actp;
SpsTg8DrvrActionTable  atab;
SpsTg8DrvrPtimBinding *ptimp;
SpsTg8DrvrCtimBinding *ctimp;

fd_set rdset;
struct timeval tv;
struct timeval *ptv;
struct timezone tz;
int i, m, cnt, cc, mch, found;

TimLibClass    xclass   = TimLibClassHARDWARE;
unsigned long  xequip   = 0;
unsigned long  xplnum   = 0;
TimLibHardware xsource  = TimLibHardwareCTIM;
TimLibTime     xonzero  = {0, 0, 0, TgmMACHINE_NONE};
TimLibTime     xtrigger = {0, 0, 0, TgmMACHINE_NONE};
TimLibTime     xstart   = {0, 0, 0, TgmMACHINE_NONE};
unsigned long  xctim    = 0;
unsigned long  xpayload = 0;
unsigned long  xmodule  = 0;
unsigned long  xmissed  = 0;
unsigned long  xqsize   = 0;

   cnt = 1;
   FD_ZERO(&rdset);
   for (m=0; m<SpsTg8DrvrMODULES; m++) {
      if (tg8s[m]) {
	 if (QFlag) ioctl(tg8s[m],SpsTg8DrvrPURGE_QUEUE,NULL);
	 FD_SET(tg8s[m],&rdset);
	 cnt++;
      }
   }

   if (TmOut) {
      ptv = &tv;
      tv.tv_sec  = TmOut/1000000;
      tv.tv_usec = TmOut%1000000;
   } else ptv = NULL;

   tz.tz_minuteswest = 0;
   tz.tz_dsttime     = 0;

   cc = select(cnt,&rdset,NULL,NULL,ptv); gettimeofday(&tv,&tz);
   if (cc == 0) return TimLibErrorTIMEOUT;

   xmodule = 0;
   for (m=0; m<SpsTg8DrvrMODULES; m++) {
      if ((tg8s[m]) && (FD_ISSET(tg8s[m],&rdset))) {
	 xmodule = m + 1;
	 break;
      }
   }
   if (xmodule == 0) return TimLibErrorTIMEOUT;

   cc = read(tg8s[m],&rbuf,sizeof(SpsTg8DrvrEvent));
   if (cc <= 0) {
      perror("Tg8SpsLibWait");
      return TimLibErrorIO;
   } else {
      ioctl(tg8s[m],SpsTg8DrvrGET_QUEUE_LENGTH,&xqsize);
      xmissed = 0; if (xqsize >= 128) xmissed = 1;

      bzero((void *) &atab, sizeof(SpsTg8DrvrActionTable));
      atab.Row = rbuf.Inter.Ext.Act;
      atab.Cnt = 1;
      actp = &(atab.Table[0]);
      if (ioctl(tg8s[m],SpsTg8DrvrUSER_TABLE,&atab) < 0) {
	 perror("Tg8SpsLibWait");
	 return TimLibErrorIO;
      }
      actp->Control &= SpsTg8DrvrCONTROL_BITS;
      if (actp->Control == 0x8000) xclass = TimLibClassCTIM;
      else                         xclass = TimLibClassPTIM;

      mch = (rbuf.Inter.Frame & 0xF0000000) >> 28;
      mch = TgvTgvToTgmMachine(mch);

      xpayload = rbuf.Inter.Frame & 0xFFFF;

      xonzero.Second  = tv.tv_sec;
      xonzero.Nano    = tv.tv_usec * 1000;
      xonzero.CTrain  = rbuf.Inter.Out;
      xonzero.Machine = mch;

      xstart = xtrigger = xonzero;
      xtrigger.CTrain = rbuf.Inter.Occ;

      found = 0;
      for (i=0; i<ctims->Size; i++) {
	 ctimp = &(ctims->Objects[i]);
	 if (ctimp->Frame == rbuf.Frame) {
	    xequip = xctim = ctimp->EqpNum;
	    xsource = TimLibHardwareCTIM;
	    found = 1;
d701 68
a768 16
	 }
      }
      if (!found) return TimLibErrorCTIM;

      if (xclass == TimLibClassPTIM) {
	 found = 0;
	 for (i=0; i<ptims->Size; i++) {
	    ptimp = &(ptims->Objects[i]);
	    if ((atab.Row >= ptimp->StartIndex)
	    &&  (atab.Row <  ptimp->StartIndex + ptimp->Size + 1)) {
	       found = 1;
	       xequip  = ptimp->EqpNum;
	       xmodule = ptimp->ModuleIndex + 1;
	       xplnum  = 1;
	       xsource = ptimp->Counter;
	       break;
d770 70
a839 63
	 }
	 if (!found) return TimLibErrorPTIM;
      }
   }

   if (iclass)  *iclass  = xclass;
   if (equip)   *equip   = xequip;
   if (plnum)   *plnum   = xplnum;
   if (source)  *source  = xsource;
   if (onzero)  *onzero  = xonzero;
   if (trigger) *trigger = xtrigger;
   if (start)   *start   = xstart;
   if (ctim)    *ctim    = xctim;
   if (payload) *payload = xpayload;
   if (module)  *module  = xmodule;
   if (missed)  *missed  = xmissed;
   if (qsize)   *qsize   = xqsize;

   return TimLibErrorSUCCESS;
}

/* ==================================================================== */
/* Set the Ccv of a PTIM equipment. Note neither the counter number nor */
/* the trigger condition can be changed.                                */

TimLibError Tg8SpsLibSet(unsigned long ptim,    /* PTIM to write to */
		       TgmMachine      machine, /* Telegram identifier */
		       unsigned long   plnum,   /* Ptim line number 1..n or 0 */
		       unsigned long   ctim,    /* If plnum is not zero this is the ctim trigger */
		       unsigned long   grnum,   /* Tgm group number or Zero */
		       unsigned long   grval,   /* Group value if num not zero */
		       TimLibCcvMask   ccvm,    /* Which values to write */
		       TimLibCcv       *ccv) {  /* Current control value */

int i, m, msk, cntr, found;
SpsTg8DrvrPtimBinding *ptimp;
SpsTg8DrvrAction      act;
TimLibError           err;

   found = 0;
   for (i=0; i<ptims->Size; i++) {
      ptimp = &(ptims->Objects[i]);
      if (ptimp->EqpNum == ptim) {
	 m = ptimp->ModuleIndex;
	 if (!tg8s[m]) return TimLibErrorMODULE;
	 cntr = ptimp->Counter & 0x7;
	 err = SpsTg8ReadAction(&act,ptimp->StartIndex+1,m);
	 if (err != TimLibErrorSUCCESS) return err;
	 found = 1;
	 break;
      }
   }
   if (!found) return TimLibErrorPTIM;

   if ((grnum) || (plnum > 1)) return TimLibErrorPPM;  /* No PPM allowed */

   if (plnum) {
      found = 0;
      for (i=0; i<ctims->Size; i++) {
	 if (ctims->Objects[i].EqpNum == ctim) {
	    act.Frame   = ctims->Objects[i].Frame;
	    act.Control = 0x4000 | (cntr << 8);
	    act.Delay = 1;
d842 12
a853 9
	 }
      }
      if (!found) return TimLibErrorCTIM;
   }

   msk = 1;
   do {
      if (ccvm & msk) {
	 switch ((TimLibCcvMask) msk) {
d855 5
a859 3
	       if (ccv->Enable) act.Control |=  0x4000;
	       else             act.Control &= ~0x4000;
	       break;
d862 13
a874 14
	       if (ccv->Start >= TimLibSTARTS) return TimLibErrorSTART;
	       if (ccv->Start == TimLibStartNORMAL) {
		  act.Control &= 0xFF0F;
	       } else
	       if (ccv->Start == TimLibStartCHAINED) {
		  act.Control &= 0xFF0F;
		  act.Control |= 0x0040;
	       } else
	       if (ccv->Start == TimLibStartEXT1) {
		  act.Control &= 0xFF0F;
		  act.Control |= 0x0080;
	       } else
		  return TimLibErrorSTART;
	       break;
d877 36
a912 18
	       if (ccv->Clock >= TimLibCLOCKS) return TimLibErrorCLOCK;
	       if (ccv->Clock == TimLibClock1KHZ) {
		  act.Control &= 0xFFF0;
	       } else
	       if (ccv->Clock == TimLibClock10MHZ) {
		  act.Control &= 0xFFF0;
		  act.Control |= 0x0001;
	       } else
	       if (ccv->Clock == TimLibClockEXT1) {
		  act.Control &= 0xFFF0;
		  act.Control |= 0x0002;
	       } else
	       if (ccv->Clock == TimLibClockEXT2) {
		  act.Control &= 0xFFF0;
		  act.Control |= 0x0003;
	       } else
		  return TimLibErrorCLOCK;
	       break;
d915 2
a916 2
	       act.Delay = ccv->Delay;
	       break;
d922 6
a927 1
	       return TimLibErrorNOT_IMP;
d929 384
a1312 315
	    default: break;
	 }
      }
      msk <<= 1;
   } while (msk & TimLibCcvMaskBITS);

   return SpsTg8WriteAction(&act,ptimp->StartIndex+1,m);
}

/* ==================================================================== */
/* Get the Ccv of a PTIM equipment.                                     */

TimLibError Tg8SpsLibGet(unsigned long ptim,
			 TgmMachine    machine,
			 unsigned long grnum,
			 unsigned long grval,
			 TimLibCcvMask *ccvm,  /* Valid fields in ccv */
			 TimLibCcv     *ccv) {

int i, m, found;
SpsTg8DrvrPtimBinding *ptimp;
SpsTg8DrvrAction       act;
TimLibError            err;

   bzero((void *) ccv, sizeof(TimLibCcv));
   if (grnum) return TimLibErrorPPM;

   found = 0;
   for (i=0; i<ptims->Size; i++) {
      ptimp = &(ptims->Objects[i]);
      if (ptimp->EqpNum == ptim) {
	 m = ptimp->ModuleIndex;
	 if (!tg8s[m]) return TimLibErrorMODULE;
	 err = SpsTg8ReadAction(&act,ptimp->StartIndex+1,m);
	 if (err != TimLibErrorSUCCESS) return err;
	 found = 1;
	 break;
      }
   }
   if (!found) return TimLibErrorPTIM;

   *ccvm = TimLibCcvMaskENABLE
	 | TimLibCcvMaskSTART
	 | TimLibCcvMaskCLOCK
	 | TimLibCcvMaskDELAY;

   if (act.Control & 0x4000) ccv->Enable = 1;

   if (act.Control & 0x0040) ccv->Start  = TimLibStartCHAINED;
   if (act.Control & 0x0080) ccv->Start  = TimLibStartEXT1;

   if ((act.Control & 0x0003) == 3) ccv->Clock  = TimLibClockEXT2;
   if ((act.Control & 0x0002) == 2) ccv->Clock  = TimLibClockEXT2;

   ccv->Delay  = act.Delay;

   return TimLibErrorSUCCESS;
}

/* ==================================================================== */
/* By writing to the driver this call simulates an interrupt for the    */
/* connected clients. Also it can be used as a way of synchronizing     */
/* processes, this is especially important in Linux systems where the   */
/* schedular is not preemptive.                                         */

/* Arguments:                                                                     */
/*    xclass:   Class of interrupt to simulate, PTIM, CTIM or Hardware             */
/*    equip:   Equipment number for PTIM or CTIM, hardware mask for Hardware      */
/*    module:  When class is CTIM or Hardware, the module number is used          */
/*    machine: Telegram ID is used for PTIM interrupts if grnum is not zero       */
/*    grnum:   If zero, no telegram checking, else the PTIM triggers group number */
/*    grval:   The telegram group value for the PTIM trigger                      */

TimLibError Tg8SpsLibSimulate(TimLibClass   xclass,
			      unsigned long equip,
			      unsigned long module,
			      TgmMachine    machine,
			      unsigned long grnum,
			      unsigned long grval) {

   return TimLibErrorNOT_IMP;
}

/* ==================================================================== */
/* Set a counter under full remote control (IE under DSC tasks control) */
/* This feature permits you to do what you like with counters even if   */
/* there is no timing cable attached. With this you can drive stepper   */
/* motors, wire scanners or whatever. No PTIM or CTIM is involved, the  */
/* configuration is loaded directly by the application. Note that when  */
/* the argument remflg is set to 1, the counter can not be written to   */
/* by incomming triggers so all PTIM objects using the counter stop     */
/* overwriting the counter configuration and are effectivley disabled.  */
/* Setting the remflg 0 permits PTIM triggers to write to the counter   */
/* configuration, the write block is removed. Also note that in some    */
/* cases it is useful to perform remote actions, such as remoteSTOP,    */
/* even if the remflg is set to zero. The remflg simply blocks PTIM     */
/* overwrites, the counter configuration can still be accessed !        */

TimLibError Tg8SpsLibRemoteControl(unsigned long remflg, /* 0 = Normal, 1 = Remote */
				 unsigned long cntr,   /* 1..8 counter number */
				 TimLibRemote  rcmd,   /* Command */
				 TimLibCcvMask ccvm,   /* Fields to be set */
				 TimLibCcv     *ccv) { /* Value to load in counter */

   return TimLibErrorNOT_IMP;
}

/* ==================================================================== */
/* Read the instantaneous value of the time in UTC. The module parameter*/
/* can be set to zero in which case the system decideds which module to */
/* read the time from, otherwise it can be set to a value between 1 and */
/* the number of installed modules.                                     */

TimLibError Tg8SpsLibGetTime(unsigned long module, /* Module number to read from */
			   TimLibTime    *utc) { /* Returned time value */

struct timeval  tv;
struct timezone tz;

   tz.tz_minuteswest = 0;
   tz.tz_dsttime     = 0;

   gettimeofday(&tv,&tz);

   utc->Second  = tv.tv_sec;
   utc->Nano    = tv.tv_usec * 1000;
   utc->CTrain  = 0;
   utc->Machine = TgmMACHINE_NONE;

   return TimLibErrorSUCCESS;
}

/* ==================================================================== */
/* Read a machines telegram from a timing receiver. The module can be   */
/* either zero, in which case the system decides which device to use,   */
/* or it can be explicitly set between 1 and the number of installed    */
/* modules. The telegram object returned has an opaque structure and    */
/* can only be decoded through the Tgm library routine .....            */

/* unsigned long grval = TgmGetGroupValueFromTelegram(TgmMachine    machine,   */
/*                                                    unsigned long grnum,     */
/*                                                    TgmTelegram   *telegram) */

/* WARNING: The only task that should call this routine will be, get_tgm_lib,  */
/* all other, LOWER PRIORITY tasks must NEVER call this routine, instead they  */
/* should call the telegram library directly like this ...                     */

/* TgmTelegram telegram;                                                       */
/*                                                                             */
/* if (TgmGetTelegram(machine, index, offset, &telegram) == TgmNOT_IMP) { ...  */
/*                                                                             */
/* For more information on this function see the Tgm library man pages.        */

TimLibError Tg8SpsLibGetTelegram(unsigned long module,
			       TgmMachine    machine,
			       TgmTelegram   *telegram) {
SpsTg8DrvrTelegram spstgm;
int i, m;

   m = 0; if (module) m = module -1;
   if (tg8s[m] == 0) return TimLibErrorMODULE;

   spstgm.Machine = TgvTgmToTgvMachine(machine);
   if (ioctl(tg8s[m],SpsTg8DrvrTELEGRAM,&spstgm) < 0) {
      perror("Tg8SpsLibGetTelegram");
      return TimLibErrorIO;
   }
   bzero((void *) telegram, sizeof(TgmTelegram));
   telegram->Machine = machine;
   telegram->Size    = TgmLastGroupNumber(machine);
   for (i=0; i<telegram->Size; i++)
      telegram->Groups[i] = spstgm.Data[i];

   return TimLibErrorSUCCESS;
}

/* ==================================================================== */
/* Lets you know how many installed modules there are on this host.     */

unsigned long Tg8SpsLibGetInstalledModuleCount() {

unsigned long cnt = 0;
int m;

   for (m=0; m<SpsTg8DrvrMODULES; m++)
      if (tg8s[m]) cnt++;
   return cnt;
}

/* ==================================================================== */
/* Get the description of a given PTIM equipment. The dimension returns */
/* the PPM dimension, counter and module are obvious.                   */

TimLibError Tg8SpsLibGetPtimObject(unsigned long ptim, /* PTIM equipment number */
				 unsigned long *module,
				 unsigned long *counter,
				 unsigned long *dimension) {

int i;

   for (i=0; i<ctims->Size; i++) {
      if (ptims->Objects[i].EqpNum == ptim) {
	 *module    = ptims->Objects[i].ModuleIndex +1;
	 *counter   = ptims->Objects[i].Counter;
	 *dimension = ptims->Objects[i].Size;
	 return TimLibErrorSUCCESS;
      }
   }
   return TimLibErrorPTIM;
}

/* ==================================================================== */
/* Get the event code corresponding to a given CTIM equipment number.   */

TimLibError Tg8SpsLibGetCtimObject(unsigned long ctim, /* CTIM equipment number */
				 unsigned long *eventcode) {

int i;

   for (i=0; i<ctims->Size; i++) {
      if (ctims->Objects[i].EqpNum == ctim) {
	 *eventcode = ctims->Objects[i].Frame;
	 return TimLibErrorSUCCESS;
      }
   }
   return TimLibErrorCTIM;
}

/* ==================================================================== */
/* In some cases when running a GUI under Linux, say, a file handle to  */
/* put in a "select" is needed so that one can wait on multiple file    */
/* handles simultaneously. This routine returns such a handle suitable  */
/* to check for waiting interrupts. Do not read directly from it, but   */
/* call the wait routine. The queue flag must be on for this to work !! */

TimLibError Tg8SpsLibGetHandle(int *fd) {

   if (tg8s[0] == 0) return TimLibErrorINIT;
   *fd = tg8s[0];
   return TimLibErrorSUCCESS;
}

/* ==================================================================== */
/* Create a new PTIM object, the CCV settings will be defaulted.        */

TimLibError Tg8SpsLibCreatePtimObject(unsigned long ptim, /* PTIM equipment number */
				      unsigned long module,
				      unsigned long counter,
				      unsigned long dimension) {
SpsTg8DrvrAction act;
int m, i, anum, cntr;

   if ((module < 1) || (module > SpsTg8DrvrMODULES)) return TimLibErrorMODULE;
   m = module -1;
   if (!tg8s[m]) return TimLibErrorMODULE;
   if ((counter < 1) || (counter > 8)) return TimLibErrorCOUNTER;

   if (dimension != 1) return TimLibErrorPPM;

   for (i=0; i<ptims->Size; i++) {
      if (ptims->Objects[i].EqpNum == ptim) {
	 return TimLibErrorEXISTS;
      }
   }
   anum = 0;
   for (i=0; i<SpsTg8DrvrACTIONS; i++) {
      if (atabs[m].Table[i].Frame == 0) {
	 anum = i +1;
	 break;
      }
   }
   if (anum == 0) return TimLibErrorNOMEM;

   i = ptims->Size;
   if (i < SpsTg8DrvrPtimOBJECTS) {
      ptims->Objects[i].EqpNum      = ptim;
      ptims->Objects[i].ModuleIndex = m;
      ptims->Objects[i].Counter     = counter;
      ptims->Objects[i].Size        = 1;
      ptims->Objects[i].StartIndex  = anum -1;
      ptims->Size++;
   }

   /* Need to do this next step to be sure that space is reserved in the atab */

   for (i=0; i<dimension; i++) {
      cntr = counter & 0x7;
      act.Frame = 0x2101FFFF;  /* OX.NSSC-MTG */
      act.Control = (cntr << 8) | 0x4000;
      act.Delay = 1;
   }

   return SpsTg8WriteAction(&act,anum,m);
}

/* ==================================================================== */
/* Create a new CTIM object. If a payload is to be used for this event  */
/* be sure to set the low 16-Bits to 0xFFFF                             */

TimLibError Tg8SpsLibCreateCtimObject(unsigned long ctim, /* CTIM equipment number */
				      unsigned long eventcode) {
int i;

   for (i=0; i<ctims->Size; i++) {
      if (ctims->Objects[i].EqpNum == ctim) {
	 return TimLibErrorEXISTS;
      }
   }
   if (ctims->Size < SpsTg8DrvrCtimOBJECTS) {
      ctims->Objects[i].EqpNum  = ctim;
      ctims->Objects[i].Frame   = eventcode;
      ctims->Size++;
      return TimLibErrorSUCCESS;
   }
   return TimLibErrorNOMEM;
@


1.13
log
@*** empty log message ***
@
text
@d161 1
a161 1
/* tasks can access them.                                               */
d664 6
a669 4
	 if (ctimp->Frame == rbuf.Frame) xequip = xctim = ctimp->EqpNum;
	 xsource = TimLibHardwareCTIM;
	 found = 1;
	 break;
d748 1
a748 1
	    act.Delay   = 0;
@


1.12
log
@*** empty log message ***
@
text
@d2 2
a3 3
/* Implement the timing library over the CTR familly of timing receiver */
/* cards, PMC, PCI, and VME.                                            */
/* Julian Lewis May 2004                                                */
d124 1
a124 1
#define SpsTg8DrvrCtimOBJECTS 2048
d138 1
a138 1
#define SpsTg8DrvrPtimOBJECTS 2048
@


1.11
log
@Seems to work
@
text
@d178 1
d189 1
d200 1
d253 2
d260 1
a260 2
int i;
TimLibClass ccls;
d262 2
a263 2
   if (anum) {                                  /* Is it a PTIM ? */
      ccls = TimLibClassPTIM;
d265 2
a266 13
      if (timlib_debug) {
	 fprintf(stderr,
		 "SpsTg8WriteAction: Writing: Frame: 0x%08X Control: 0x%08X Delay: %d\n",
		 (int) ap->Frame,
		 (int) ap->Control,
		 (int) ap->Delay);
	 fprintf(stderr,
		 "SpsTg8WriteAction: To module: %d Action row: %d\n",
		 (int) m+1,
		 (int) anum);
      }
   } else {                                     /* Its a CTIM */
      ccls = TimLibClassCTIM;
d277 1
a277 1
	    if (atabs[m].Table[i].Frame == 0) { /* Make a new CTIM conection */
d287 13
a299 1
   if (ccls == TimLibClassPTIM) {
d315 64
a378 1
/* Read an action from memory                                               */
d410 8
a417 1
/* This is the CTR implementation, so device is irrelevant here.        */
a422 1
SpsTg8DrvrActionAddress ad;
a426 2
      timlib_debug = 1;

d433 1
d440 1
a440 1
	 if (((err = AttachMemory()) == TimLibErrorSUCCESS) && (timlib_debug)) {
d446 8
a453 11
	    bzero((void *) ctims,     sizeof(SpsTg8DrvrCtimObjects));
	    bzero((void *) ptims,     sizeof(SpsTg8DrvrPtimObjects));
	    bzero((void *) &atabs[m], sizeof(SpsTg8DrvrActionTable));
	    ad.Row = 1;
	    ad.Cnt = 255;
	    if (ioctl(tg8s[m],SpsTg8DrvrCLEAR_ACTION,&ad) < 0)  {
	       perror("Tg8SpsLibInitialize");
	       return TimLibErrorIO;
	    }
	    fprintf(stderr,"Tg8SpsLibInitialize: Memory Wiped clean OK\n");
	 }
d455 1
d486 4
d507 4
@


1.10
log
@*** empty log message ***
@
text
@d22 4
d86 6
a91 1
   SpsTg8DrvrAction Table[256];
a106 7
#if 0
  unsigned char   Min,    /* Triggered OR fired time stamp */
		  Sec;
  unsigned short  Ms;
  unsigned short  Pulse;  /* Pulse number */
  unsigned short  Train;  /* Train number */
#endif
d119 3
a121 3
    int            Machine;         /* Acc. machine number */
    unsigned short Data[Tg8GROUPS]; /* Telegram buffer */
  } SpsTg8DrvrTelegram;             /* SPS driver telegram */
a129 1
   unsigned long Clients;
d158 1
d189 10
d202 7
a208 3
/* ==================================================================== */
/* Open a connection to the SPS Tg8 driver.                             */
/* ==================================================================== */
d214 2
a215 2
char fnm[32], ver[32];
int  m, fnum;
d222 20
a241 15
   fnum = module * 8;
   sprintf(fnm,"/dev/Tg8.%1d",fnum);
   if ((tg8s[m] = open(fnm,O_RDWR,0)) > 0) {

      /* The CPS Tg8 driver returns a long version string <__DATE__ __TIME__> */
      /* while the SPS Tg8 driver returns a short version string <__DATE__>   */

      bzero((void *) ver, 32);
      if (ioctl(tg8s[m],SpsTg8DrvrGET_FIRMWARE_VERSION,&ver) < 0) {
	 perror("SpsTg8Open");
	 ver[0] = 0;
      }
      if ((strlen(ver) > 0)
      &&  (strlen(ver) < (strlen(__DATE__) + 4))) {
	 return tg8s[m];
a242 2
      close(tg8s[m]);
      tg8s[m] = 0;
d248 84
d348 1
d353 1
a353 2
      err = AttachMemory();
      if (err |= TimLibErrorSUCCESS) return err;
d366 20
a385 2
      if (ok) return TimLibErrorSUCCESS;
      else    return TimLibErrorOPEN;
d403 1
a403 1
int i, j, m, msk, changed;
a405 1
SpsTg8DrvrAction      *actp;
d407 1
a407 1
SpsTg8DrvrActionTable  atab;
a412 1
   msk = 1 << m;
a417 3
#if 0
	    if (ctimp->Clients & msk) return TimLibErrorSUCCESS; /* Already connected */
#endif
d421 1
a421 5
	    if (write(tg8s[m],&act,sizeof(SpsTg8DrvrAction)) > 0) {
	       ctimp->Clients |= msk;
	       return TimLibErrorSUCCESS;
	    }
	    return TimLibErrorIO;
d433 4
a436 24
	    atab.Row = ptimp->StartIndex;
	    atab.Cnt = ptimp->Size;
	    if (ioctl(tg8s[m],SpsTg8DrvrUSER_TABLE,&atab) < 0) {
	       perror("Tg8SpsLibConnect");
	       return TimLibErrorIO;
	    }
	    changed = 0;
	    for (j=0; j<ptimp->Size; j++) {
	       actp = &(atab.Table[i]);
	       if (actp->Control & 0x8000) continue;
	       changed = 1;
	       actp->Control |= 0x8000;
	    }
	    if (changed) {
	       if (ioctl(tg8s[m],SpsTg8DrvrCLEAR_ACTION,&atab) < 0) {
		  perror("Tg8SpsLibConnect");
		  return TimLibErrorIO;
	       }
	       if (write(tg8s[m],atab.Table,(atab.Cnt*sizeof(SpsTg8DrvrAction))) <= 0) {
		  perror("Tg8SpsLibConnect");
		  return TimLibErrorIO;
	       }
	    }
	    return TimLibErrorSUCCESS;
a440 1

d536 1
a536 1
   tz.tz_dsttime     = DST_NONE;
d555 1
a555 1
      ioctl(tg8s[m],Tg8DrvrGET_QUEUE_LENGTH,&xqsize);
d558 1
d566 1
d598 1
a598 1
	    &&  (atab.Row <  ptimp->StartIndex + ptimp->Size)) {
d602 1
a602 1
	       xplnum  = atab.Row - ptimp->StartIndex + 1;
d640 1
a640 1
int i, m, msk, anum, cntr, found;
d642 2
a643 2
SpsTg8DrvrAction      *actp;
SpsTg8DrvrActionTable  atab;
a650 2
	 anum = ptimp->StartIndex + plnum -1;
	 actp = &(atab.Table[anum]);
d652 2
a653 6
	 atab.Row = ptimp->StartIndex;
	 atab.Cnt = ptimp->Size;
	 if (ioctl(tg8s[m],SpsTg8DrvrUSER_TABLE,&atab) < 0) {
	    perror("Tg8SpsLibSet");
	    return TimLibErrorIO;
	 }
d660 1
a660 1
   if ((grnum) || (plnum > 1)) return TimLibErrorPPM;
d666 3
a668 3
	    actp->Frame   = ctims->Objects[i].Frame;
	    actp->Control = (cntr << 12);
	    actp->Delay   = 0;
d681 2
a682 2
	       if (ccv->Enable) actp->Control |=  0x4000;
	       else             actp->Control &= ~0x4000;
d688 1
a688 1
		  actp->Control &= 0xFF0F;
d691 2
a692 2
		  actp->Control &= 0xFF0F;
		  actp->Control |= 0x0040;
d695 2
a696 2
		  actp->Control &= 0xFF0F;
		  actp->Control |= 0x008F;
d704 1
a704 1
		  actp->Control &= 0xFFF0;
d707 2
a708 2
		  actp->Control &= 0xFFF0;
		  actp->Control |= 0x0001;
d711 2
a712 2
		  actp->Control &= 0xFFF0;
		  actp->Control |= 0x0002;
d715 2
a716 2
		  actp->Control &= 0xFFF0;
		  actp->Control |= 0x0003;
d722 1
a722 1
	       actp->Delay = ccv->Delay;
d737 1
a737 9
   if (ioctl(tg8s[m],SpsTg8DrvrCLEAR_ACTION,&atab) < 0) {
      perror("Tg8SpsLibSet");
      return TimLibErrorIO;
   }
   if (write(tg8s[m],atab.Table,(atab.Cnt*sizeof(SpsTg8DrvrAction))) <= 0) {
      perror("Tg8SpsLibSet");
      return TimLibErrorIO;
   }
   return TimLibErrorSUCCESS;
d750 1
a750 1
int i, m, anum, cntr, found;
d752 2
a753 2
SpsTg8DrvrAction      *actp;
SpsTg8DrvrActionTable  atab;
d764 2
a765 9
	 anum = ptimp->StartIndex;
	 actp = &(atab.Table[anum]);
	 cntr = ptimp->Counter & 0x7;
	 atab.Row = ptimp->StartIndex;
	 atab.Cnt = ptimp->Size;
	 if (ioctl(tg8s[m],SpsTg8DrvrUSER_TABLE,&atab) < 0) {
	    perror("Tg8SpsLibSet");
	    return TimLibErrorIO;
	 }
d777 1
a777 1
   if (actp->Control & 0x4000) ccv->Enable = 1;
d779 2
a780 2
   if (actp->Control & 0x0040) ccv->Start  = TimLibStartCHAINED;
   if (actp->Control & 0x0080) ccv->Start  = TimLibStartEXT1;
d782 2
a783 2
   if ((actp->Control & 0x0003) == 3) ccv->Clock  = TimLibClockEXT2;
   if ((actp->Control & 0x0002) == 2) ccv->Clock  = TimLibClockEXT2;
d785 1
a785 1
   ccv->Delay  = actp->Delay;
d851 1
a851 1
   tz.tz_dsttime     = DST_NONE;
d980 2
a981 3
SpsTg8DrvrAction      *actp;
SpsTg8DrvrActionTable  atab;
int m, i, si, cntr;
a989 1
   si = 0;
a991 1
	 si += ptims->Objects[i].StartIndex;
d995 11
a1005 1
   if (ptims->Size < SpsTg8DrvrPtimOBJECTS) {
d1009 2
a1010 2
      ptims->Objects[i].Size        = dimension;
      ptims->Objects[i].StartIndex  = si;
a1016 1
      actp = &(atab.Table[i]);
d1018 3
a1020 3
      actp->Frame = 0x2101FFFF;  /* OX.NSSC-MTG */
      actp->Control = cntr << 12;
      actp->Delay = i + 1;
d1023 1
a1023 11
   atab.Row = si;
   atab.Cnt = dimension;
   if (ioctl(tg8s[m],SpsTg8DrvrCLEAR_ACTION,&atab) <0) {
      perror("Tg8SpsLibCreatePtimObject");
      return TimLibErrorIO;
   }
   if (write(tg8s[m],atab.Table,(atab.Cnt*sizeof(SpsTg8DrvrAction))) <= 0) {
      perror("Tg8SpsLibCreatePtimObject");
      return TimLibErrorIO;
   }
   return TimLibErrorSUCCESS;
a1041 1
      ctims->Objects[i].Clients = 0;
@


1.9
log
@Finished code, now start testing
@
text
@d98 1
d104 1
d117 3
a119 3
    int  Machine;         /* Acc. machine number */
    Word Data[Tg8GROUPS]; /* Telegram buffer */
  } SpsTg8DrvrTelegram;   /* Get telegram */
d199 1
a199 1
int  m;
d206 2
a207 1
   sprintf(fnm,"/dev/Tg8.%1d",module);
d214 4
a217 1
      ioctl(tg8s[m],SpsTg8DrvrGET_FIRMWARE_VERSION,&ver);
d225 1
d243 2
a244 1
int ok, module;
d248 4
d254 8
a261 1
	 if (SpsTg8Open(module) != 0) ok = 1;
d299 1
d301 1
d323 4
a326 1
	    if (ioctl(tg8s[m],SpsTg8DrvrUSER_TABLE,&atab) < 0) return TimLibErrorIO;
d335 2
a336 2
	       if (ioctl(tg8s[m],SpsTg8DrvrCLEAR_ACTION,&atab) < 0) return TimLibErrorIO;
	       if (write(tg8s[m],atab.Table,(atab.Cnt*sizeof(SpsTg8DrvrAction))) <= 0)
d338 5
d459 5
a463 2
   if (read(tg8s[m],&rbuf,sizeof(SpsTg8DrvrEvent)) > 0) {

d470 4
a473 1
      if (ioctl(tg8s[m],SpsTg8DrvrUSER_TABLE,&atab) < 0) return TimLibErrorIO;
a515 2

      return TimLibErrorSUCCESS;
d531 1
a531 1
   return TimLibErrorIO;
d563 4
a566 1
	 if (ioctl(tg8s[m],SpsTg8DrvrUSER_TABLE,&atab) < 0) return TimLibErrorIO;
d619 4
d650 2
a651 2
   if (ioctl(tg8s[m],SpsTg8DrvrCLEAR_ACTION,&atab) < 0) return TimLibErrorIO;
   if (write(tg8s[m],atab.Table,(atab.Cnt*sizeof(SpsTg8DrvrAction))) <= 0)
d653 6
a658 2

   return TimLibErrorPTIM;
d690 4
a693 1
	 if (ioctl(tg8s[m],SpsTg8DrvrUSER_TABLE,&atab) < 0) return TimLibErrorIO;
d822 4
a825 2
   if (ioctl(tg8s[m],SpsTg8DrvrTELEGRAM,&spstgm) < 0) return TimLibErrorIO;

a932 1
      return TimLibErrorSUCCESS;
d947 2
a948 2
   ioctl(tg8s[m],SpsTg8DrvrCLEAR_ACTION,&atab);
   if (write(tg8s[m],atab.Table,(atab.Cnt*sizeof(SpsTg8DrvrAction))) <= 0)
d950 5
a954 1

@


1.8
log
@*** empty log message ***
@
text
@d114 5
d399 1
a399 1
   cnt = 0;
d728 12
d741 1
a741 1
   return TimLibErrorNOT_IMP;
d768 8
d777 7
a783 1
   return TimLibErrorNOT_IMP;
@


1.7
log
@*** empty log message ***
@
text
@d12 4
d85 29
d149 1
d326 2
a327 1
int m;
a328 8
   QFlag = qflag;
   for (m=0; m<SpsTg8DrvrMODULES; m++) {
      if (tg8s[m]) {
	 if (ioctl(tg8s[m],SpsTg8DrvrSET_TIME_OUT,&tmout) < 0) {
	    return TimLibErrorIO;
	 }
      }
   }
d356 70
a425 12
TimLibError Tg8SpsLibWait(TimLibClass    *iclss,   /* Class of interrupt */
			unsigned long  *equip,   /* PTIM CTIM or hardware mask */
			unsigned long  *plnum,   /* Ptim line number 1..n or 0 */
			TimLibHardware *source,  /* Hardware source of interrupt */
			TimLibTime     *onzero,  /* Time of interrupt/output */
			TimLibTime     *trigger, /* Time of counters load */
			TimLibTime     *start,   /* Time of counters start */
			unsigned long  *ctim,    /* CTIM trigger equipment ID */
			unsigned long  *payload, /* Payload of trigger event */
			unsigned long  *module,  /* Module that interrupted */
			unsigned long  *missed,  /* Number of missed interrupts */
			unsigned long  *qsize) { /* Remaining interrupts on queue */
d427 67
a493 1
   return TimLibErrorNOT_IMP;
d673 1
a673 1
/*    iclss:   Class of interrupt to simulate, PTIM, CTIM or Hardware             */
d680 1
a680 1
TimLibError Tg8SpsLibSimulate(TimLibClass   iclss,
d828 3
a830 1
int m, i, si;
d855 18
a872 1
   return TimLibErrorNOT_IMP;
@


1.6
log
@*** empty log message ***
@
text
@d113 3
a115 2
SpsTg8DrvrCtimObjects *ctims = NULL;
SpsTg8DrvrPtimObjects *ptims = NULL;
d290 1
a290 1
			 unsigned long tmout) {  /* 0=>No time outs       */
d292 11
a302 1
   return TimLibErrorNOT_IMP;
d465 5
a469 5
		       TgmMachine    machine,
		       unsigned long grnum,
		       unsigned long grval,
		       TimLibCcvMask *ccvm,  /* Valid fields in ccv */
		       TimLibCcv     *ccv) {
d471 42
a512 1
   return TimLibErrorNOT_IMP;
d530 5
a534 5
			     unsigned long equip,
			     unsigned long module,
			     TgmMachine    machine,
			     unsigned long grnum,
			     unsigned long grval) {
d536 1
a536 1
   return TimLibErrorIO;
d610 1
d612 2
@


1.5
log
@*** empty log message ***
@
text
@d17 64
d88 1
a133 1
   bzero((void *) ctims, sizeof(SpsTg8DrvrCtimObjects));
a143 1
   bzero((void *) ptims, sizeof(SpsTg8DrvrPtimObjects));
d152 8
a159 2
#define SpsTg8DrvrMODULES  4
#define SpsTg8DrvrGET_FIRMWARE_VERSION 2
d161 2
a162 1
static int sps_tg8 = 0; /* This global holds the SPS TG8 Driver file handle */
d164 2
a165 1
static int SpsTg8Open() {
d167 2
a168 2
char fnm[32], ver[32];
int  i;
d170 5
a174 17
   if (sps_tg8) return sps_tg8;
   for (i = 1; i <= SpsTg8DrvrMODULES; i++) {
      sprintf(fnm,"/dev/Tg8.%1d",i);
      if ((sps_tg8 = open(fnm,O_RDWR,0)) > 0) {

	 /* The CPS Tg8 driver returns a long version string <__DATE__ __TIME__> */
	 /* while the SPS Tg8 driver returns a short version string <__DATE__>   */

	 bzero((void *) ver, 32);
	 ioctl(sps_tg8,SpsTg8DrvrGET_FIRMWARE_VERSION,&ver);
	 if ((strlen(ver) > 0)
	 &&  (strlen(ver) < (strlen(__DATE__) + 4))) {
	    return sps_tg8;
	 }
	 close(sps_tg8);
	 sps_tg8 = 0;
	 break;
d176 2
d196 2
d200 3
a202 5
      if (sps_tg8 == 0) {
	 if (SpsTg8Open() == 0) {
	    sps_tg8 = 0;
	    return TimLibErrorOPEN;
	 }
d204 2
a205 1
      return TimLibErrorSUCCESS;
d221 59
a279 2
			   unsigned long equip,    /* Equipment or hardware mask */
			   unsigned long module) { /* For HARD or CTIM classes */
d347 101
a447 1
   return TimLibErrorNOT_IMP;
d610 2
a611 2
   if (sps_tg8 == 0) return TimLibErrorINIT;
   *fd = sps_tg8;
d622 8
a629 1
int i, si;
d640 1
a640 1
      ptims->Objects[i].ModuleIndex = module -1;
d664 3
a666 2
      ctims->Objects[i].EqpNum = ctim;
      ctims->Objects[i].Frame  = eventcode;
@


1.4
log
@*** empty log message ***
@
text
@d13 4
d75 1
a75 1
      if ((int) ctims == -1) {
d80 1
a80 1
   bzero((void *) ctims, sizeof(SpsTg8DrvrPtimObjects));
d89 2
a90 1
#define Tg8DrvrMODULES  4
d94 1
a94 1
static int Tg8Open() {
d96 1
a96 1
char fnm[32];
d100 1
a100 1
   for (i = 1; i <= Tg8DrvrMODULES; i++) {
d102 15
a116 1
      if ((sps_tg8 = open(fnm,O_RDWR,0)) > 0) return sps_tg8;
d135 11
a145 1
   return TimLibErrorNOT_IMP;
@


1.3
log
@*** empty log message ***
@
text
@d82 21
d152 1
a152 1
/* get_tgm_ctr/tg8, be aware of the race condition here, hence payload. */
d362 3
a364 1
   return TimLibErrorNOT_IMP;
@


1.2
log
@*** empty log message ***
@
text
@d7 74
d95 1
a95 1
   return TimLibErrorSUCCESS;
d112 1
a112 1
   return TimLibErrorSUCCESS;
d122 1
a122 1
   return TimLibErrorSUCCESS;
d162 1
a162 1
   return TimLibErrorSUCCESS;
d170 7
a176 5
		       TgmMachine    machine, /* Telegram identifier */
		       unsigned long grnum,   /* Tgm group number or Zero */
		       unsigned long grval,   /* Group value if num not zero */
		       TimLibCcvMask ccvm,    /* Which values to write */
		       TimLibCcv     *ccv) {  /* Current control value */
d178 1
a178 1
   return TimLibErrorSUCCESS;
d191 1
a191 1
   return TimLibErrorSUCCESS;
d239 1
a239 1
   return TimLibErrorSUCCESS;
d252 1
a252 1
   return TimLibErrorSUCCESS;
d272 1
a272 1
/* if (TgmGetTelegram(machine, index, offset, &telegram) == TgmSUCCESS) { ...  */
d280 1
a280 1
   return TimLibErrorSUCCESS;
d288 1
a288 1
unsigned long cnt;
d302 11
a312 1
   return TimLibErrorSUCCESS;
d321 8
d341 51
a391 1
   return TimLibErrorSUCCESS;
@


1.1
log
@Initial revision
@
text
@a6 19
#include <unistd.h>
#include <signal.h>
#include <sys/types.h>
#include <sched.h>
#include <fcntl.h>
#include <io.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/file.h>
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <time.h>

#include <tgm/tgm.h>
#include <tgv/tgv.h>
#include <TimLib.h>
#include <tg8.h>

a32 2

static int connected = 0;
@
