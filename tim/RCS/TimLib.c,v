head	1.61;
access;
symbols;
locks
	nmn:1.61; strict;
comment	@ * @;


1.61
date	2011.08.11.08.30.04;	author nmn;	state Exp;
branches;
next	1.60;

1.60
date	2009.10.23.14.22.45;	author lewis;	state Exp;
branches;
next	1.59;

1.59
date	2008.11.12.13.52.53;	author lewis;	state Exp;
branches;
next	1.58;

1.58
date	2008.04.30.19.05.48;	author lewis;	state Exp;
branches;
next	1.57;

1.57
date	2008.03.28.09.41.32;	author lewis;	state Exp;
branches;
next	1.56;

1.56
date	2008.02.25.18.21.06;	author lewis;	state Exp;
branches;
next	1.55;

1.55
date	2008.02.21.10.12.17;	author lewis;	state Exp;
branches;
next	1.54;

1.54
date	2008.01.10.13.59.32;	author lewis;	state Exp;
branches;
next	1.53;

1.53
date	2007.12.17.15.22.39;	author lewis;	state Exp;
branches;
next	1.52;

1.52
date	2007.11.30.14.00.56;	author lewis;	state Exp;
branches;
next	1.51;

1.51
date	2007.08.29.16.43.23;	author lewis;	state Exp;
branches;
next	1.50;

1.50
date	2007.08.14.15.51.01;	author lewis;	state Exp;
branches;
next	1.49;

1.49
date	2007.06.04.13.45.04;	author lewis;	state Exp;
branches;
next	1.48;

1.48
date	2007.02.12.15.03.46;	author lewis;	state Exp;
branches;
next	1.47;

1.47
date	2006.12.20.13.32.23;	author lewis;	state Exp;
branches;
next	1.46;

1.46
date	2006.05.02.13.59.00;	author lewis;	state Exp;
branches;
next	1.45;

1.45
date	2006.03.01.16.33.25;	author lewis;	state Exp;
branches;
next	1.44;

1.44
date	2006.02.13.16.15.03;	author lewis;	state Exp;
branches;
next	1.43;

1.43
date	2006.01.25.09.52.35;	author lewis;	state Exp;
branches;
next	1.42;

1.42
date	2006.01.20.10.27.07;	author lewis;	state Exp;
branches;
next	1.41;

1.41
date	2005.12.21.13.42.35;	author lewis;	state Exp;
branches;
next	1.40;

1.40
date	2005.12.16.10.37.38;	author lewis;	state Exp;
branches;
next	1.39;

1.39
date	2005.10.21.12.29.29;	author lewis;	state Exp;
branches;
next	1.38;

1.38
date	2005.10.20.14.27.37;	author lewis;	state Exp;
branches;
next	1.37;

1.37
date	2005.09.27.12.24.51;	author lewis;	state Exp;
branches;
next	1.36;

1.36
date	2005.08.29.12.05.07;	author lewis;	state Exp;
branches;
next	1.35;

1.35
date	2005.08.29.09.13.30;	author lewis;	state Exp;
branches;
next	1.34;

1.34
date	2005.08.24.15.40.38;	author lewis;	state Exp;
branches;
next	1.33;

1.33
date	2005.08.23.16.06.22;	author lewis;	state Exp;
branches;
next	1.32;

1.32
date	2005.08.01.13.24.12;	author lewis;	state Exp;
branches;
next	1.31;

1.31
date	2005.07.08.15.40.48;	author lewis;	state Exp;
branches;
next	1.30;

1.30
date	2005.07.04.08.18.54;	author lewis;	state Exp;
branches;
next	1.29;

1.29
date	2005.07.01.16.37.01;	author lewis;	state Exp;
branches;
next	1.28;

1.28
date	2005.07.01.16.19.54;	author lewis;	state Exp;
branches;
next	1.27;

1.27
date	2005.07.01.16.12.16;	author lewis;	state Exp;
branches;
next	1.26;

1.26
date	2005.06.13.12.20.08;	author lewis;	state Exp;
branches;
next	1.25;

1.25
date	2005.05.26.15.14.01;	author lewis;	state Exp;
branches;
next	1.24;

1.24
date	2005.05.26.07.43.12;	author lewis;	state Exp;
branches;
next	1.23;

1.23
date	2005.05.04.09.05.32;	author lewis;	state Exp;
branches;
next	1.22;

1.22
date	2005.04.28.08.22.34;	author lewis;	state Exp;
branches;
next	1.21;

1.21
date	2005.04.27.15.05.13;	author lewis;	state Exp;
branches;
next	1.20;

1.20
date	2005.04.27.08.38.31;	author lewis;	state Exp;
branches;
next	1.19;

1.19
date	2005.02.09.16.50.45;	author lewis;	state Exp;
branches;
next	1.18;

1.18
date	2005.01.17.10.54.57;	author lewis;	state Exp;
branches;
next	1.17;

1.17
date	2005.01.11.15.27.26;	author lewis;	state Exp;
branches;
next	1.16;

1.16
date	2005.01.10.10.31.06;	author lewis;	state Exp;
branches;
next	1.15;

1.15
date	2004.12.02.10.56.56;	author lewis;	state Exp;
branches;
next	1.14;

1.14
date	2004.12.01.18.44.07;	author lewis;	state Exp;
branches;
next	1.13;

1.13
date	2004.11.23.16.43.45;	author lewis;	state Exp;
branches;
next	1.12;

1.12
date	2004.11.23.09.28.53;	author lewis;	state Exp;
branches;
next	1.11;

1.11
date	2004.11.23.09.19.24;	author lewis;	state Exp;
branches;
next	1.10;

1.10
date	2004.11.19.15.49.59;	author lewis;	state Exp;
branches;
next	1.9;

1.9
date	2004.11.18.16.30.47;	author lewis;	state Exp;
branches;
next	1.8;

1.8
date	2004.11.18.10.54.51;	author lewis;	state Exp;
branches;
next	1.7;

1.7
date	2004.11.17.10.40.39;	author lewis;	state Exp;
branches;
next	1.6;

1.6
date	2004.10.21.09.00.15;	author lewis;	state Exp;
branches;
next	1.5;

1.5
date	2004.10.21.08.56.46;	author ikozsar;	state Exp;
branches;
next	1.4;

1.4
date	2004.07.29.15.32.30;	author lewis;	state Exp;
branches;
next	1.3;

1.3
date	2004.07.29.15.24.48;	author lewis;	state Exp;
branches;
next	1.2;

1.2
date	2004.07.29.14.32.51;	author lewis;	state Exp;
branches;
next	1.1;

1.1
date	2004.07.28.13.04.32;	author lewis;	state Exp;
branches;
next	;


desc
@@


1.61
log
@Remove tg8 support on Intel
@
text
@/* ==================================================================== */
/* Implement the timing library over the CTR familly of timing receiver */
/* cards, PMC, PCI, and VME.                                            */
/* Julian Lewis May 2004                                                */
/* ==================================================================== */

#include <unistd.h>
#include <signal.h>
#include <sys/types.h>
#include <sched.h>
#include <fcntl.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/file.h>
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <time.h>

#include <tgm/tgm.h>
#include <tgm/TgmDefP.h>
#include <tgv/tgv.h>
#include <TimLib.h>

#include "./ctr/CtrLib.c"
#if !defined(__i386__) && !defined(__x86_64__)
/* No support any more for TG8 on MEN A20 and on PC */
#include "./tg8cps/Tg8CpsLib.c"
#include "./tg8sps/Tg8SpsLib.c"
#endif
#include "./netwrk/NetWrkLib.c"

typedef struct {
   TimLibError   (*Connect)();
   TimLibError   (*DisConnect)();
   TimLibError   (*Queue)();
   TimLibError   (*Wait)();
   TimLibError   (*Set)();
   TimLibError   (*Get)();
   TimLibError   (*Simulate)();
   TimLibError   (*RemoteControl)();
   TimLibError   (*GetRemote)();
   TimLibError   (*GetTime)();
   TimLibError   (*GetTelegram)();
   unsigned long (*GetInstalledModuleCount)();
   TimLibError   (*GetPtimObject)();
   TimLibError   (*GetCtimObject)();
   TimLibError   (*GetHandle)();
   TimLibError   (*CreateCtimObject)();
   TimLibError   (*CreatePtimObject)();
   TimLibError   (*GetCableId)();

   TimLibStatus  (*GetStatus)();
   TimLibError   (*GetModuleVersion)();

   TimLibError   (*GetAllPtimObjects)();
   TimLibError   (*GetAllCtimObjects)();
   unsigned long (*GetQueueSize)();

   char*         (*GetSpecificInfo)();

   TimLibError   (*FdConnect)();
   TimLibError   (*FdQueue)();
   TimLibError   (*FdWait)();

   TimLibError   (*GetModuleStats)();
   TimLibError   (*SetPllLocking)();

   TimLibError   (*ConnectPayload)();

 } TimLibRoutines;

static TimLibRoutines routines;

/* ==================================================================== */
/* Local routine to initialize one real device                          */

static TimLibError InitDevice(int fd, TimLibDevice device) {

   switch (device) {

      case TimLibDevice_CTR:
	 routines.Connect                 = CtrLibConnect;
	 routines.DisConnect              = CtrLibDisConnect;
	 routines.Queue                   = CtrLibQueue;
	 routines.Wait                    = CtrLibWait;
	 routines.Set                     = CtrLibSet;
	 routines.Get                     = CtrLibGet;
	 routines.Simulate                = CtrLibSimulate;
	 routines.RemoteControl           = CtrLibRemoteControl;
	 routines.GetRemote               = CtrLibGetRemote;
	 routines.GetTime                 = CtrLibGetTime;
	 routines.GetTelegram             = CtrLibGetTelegram;
	 routines.GetInstalledModuleCount = CtrLibGetInstalledModuleCount;
	 routines.GetPtimObject           = CtrLibGetPtimObject;
	 routines.GetCtimObject           = CtrLibGetCtimObject;
	 routines.GetHandle               = CtrLibGetHandle;
	 routines.CreateCtimObject        = CtrLibCreateCtimObject;
	 routines.CreatePtimObject        = CtrLibCreatePtimObject;
	 routines.GetCableId              = CtrLibGetCableId;

	 routines.GetStatus               = CtrLibGetStatus;
	 routines.GetModuleVersion        = CtrLibGetModuleVersion;
	 routines.GetAllPtimObjects       = CtrLibGetAllPtimObjects;
	 routines.GetAllCtimObjects       = CtrLibGetAllCtimObjects;
	 routines.GetQueueSize            = CtrLibGetQueueSize;
	 routines.GetSpecificInfo         = CtrLibGetSpecificInfo;

	 routines.FdConnect               = CtrLibFdConnect;
	 routines.FdQueue                 = CtrLibFdQueue;
	 routines.FdWait                  = CtrLibFdWait;

	 routines.GetModuleStats          = CtrLibGetModuleStats;
	 routines.SetPllLocking           = CtrLibSetPllLocking;

	 routines.ConnectPayload          = CtrLibConnectPayload;

	 if (fd) return (TimLibError) CtrLibFdInitialize(device);
		 return               CtrLibInitialize(device);

#if !defined(__i386__) && !defined(__x86_64__)
      case TimLibDevice_TG8_CPS:
	 routines.Connect                 = Tg8CpsLibConnect;
	 routines.DisConnect              = Tg8CpsLibDisConnect;
	 routines.Queue                   = Tg8CpsLibQueue;
	 routines.Wait                    = Tg8CpsLibWait;
	 routines.Set                     = Tg8CpsLibSet;
	 routines.Get                     = Tg8CpsLibGet;
	 routines.Simulate                = Tg8CpsLibSimulate;
	 routines.RemoteControl           = Tg8CpsLibRemoteControl;
	 routines.GetRemote               = Tg8CpsLibGetRemote;
	 routines.GetTime                 = Tg8CpsLibGetTime;
	 routines.GetTelegram             = Tg8CpsLibGetTelegram;
	 routines.GetInstalledModuleCount = Tg8CpsLibGetInstalledModuleCount;
	 routines.GetPtimObject           = Tg8CpsLibGetPtimObject;
	 routines.GetCtimObject           = Tg8CpsLibGetCtimObject;
	 routines.GetHandle               = Tg8CpsLibGetHandle;
	 routines.CreateCtimObject        = Tg8CpsLibCreateCtimObject;
	 routines.CreatePtimObject        = Tg8CpsLibCreatePtimObject;
	 routines.GetCableId              = Tg8CpsLibGetCableId;

	 routines.GetStatus               = Tg8CpsLibGetStatus;
	 routines.GetModuleVersion        = Tg8CpsLibGetModuleVersion;
	 routines.GetAllPtimObjects       = Tg8CpsLibGetAllPtimObjects;
	 routines.GetAllCtimObjects       = Tg8CpsLibGetAllCtimObjects;
	 routines.GetQueueSize            = Tg8CpsLibGetQueueSize;
	 routines.GetSpecificInfo         = Tg8CpsLibGetSpecificInfo;

	 routines.FdConnect               = Tg8CpsLibFdConnect;
	 routines.FdQueue                 = Tg8CpsLibFdQueue;
	 routines.FdWait                  = Tg8CpsLibFdWait;

	 routines.GetModuleStats          = Tg8CpsLibGetModuleStats;
	 routines.SetPllLocking           = Tg8CpsLibSetPllLocking;

	 routines.ConnectPayload          = Tg8CpsLibConnectPayload;

	 if (fd) return (TimLibError) Tg8CpsLibFdInitialize(device);
		 return               Tg8CpsLibInitialize(device);

      case TimLibDevice_TG8_SPS:
	 routines.Connect                 = Tg8SpsLibConnect;
	 routines.DisConnect              = Tg8SpsLibDisConnect;
	 routines.Queue                   = Tg8SpsLibQueue;
	 routines.Wait                    = Tg8SpsLibWait;
	 routines.Set                     = Tg8SpsLibSet;
	 routines.Get                     = Tg8SpsLibGet;
	 routines.Simulate                = Tg8SpsLibSimulate;
	 routines.RemoteControl           = Tg8SpsLibRemoteControl;
	 routines.GetRemote               = Tg8SpsLibGetRemote;
	 routines.GetTime                 = Tg8SpsLibGetTime;
	 routines.GetTelegram             = Tg8SpsLibGetTelegram;
	 routines.GetInstalledModuleCount = Tg8SpsLibGetInstalledModuleCount;
	 routines.GetPtimObject           = Tg8SpsLibGetPtimObject;
	 routines.GetCtimObject           = Tg8SpsLibGetCtimObject;
	 routines.GetHandle               = Tg8SpsLibGetHandle;
	 routines.CreateCtimObject        = Tg8SpsLibCreateCtimObject;
	 routines.CreatePtimObject        = Tg8SpsLibCreatePtimObject;
	 routines.GetCableId              = Tg8SpsLibGetCableId;

	 routines.GetStatus               = Tg8SpsLibGetStatus;
	 routines.GetModuleVersion        = Tg8SpsLibGetModuleVersion;
	 routines.GetAllPtimObjects       = Tg8SpsLibGetAllPtimObjects;
	 routines.GetAllCtimObjects       = Tg8SpsLibGetAllCtimObjects;
	 routines.GetQueueSize            = Tg8SpsLibGetQueueSize;
	 routines.GetSpecificInfo         = Tg8SpsLibGetSpecificInfo;

	 routines.FdConnect               = Tg8SpsLibFdConnect;
	 routines.FdQueue                 = Tg8SpsLibFdQueue;
	 routines.FdWait                  = Tg8SpsLibFdWait;

	 routines.GetModuleStats          = Tg8SpsLibGetModuleStats;
	 routines.SetPllLocking           = Tg8SpsLibSetPllLocking;

	 routines.ConnectPayload          = Tg8SpsLibConnectPayload;

	 if (fd) return (TimLibError) Tg8SpsLibFdInitialize(device);
		 return               Tg8SpsLibInitialize(device);
#endif

      case TimLibDevice_NETWORK:
	 routines.Connect                 = NetWrkLibConnect;
	 routines.DisConnect              = NetWrkLibDisConnect;
	 routines.Queue                   = NetWrkLibQueue;
	 routines.Wait                    = NetWrkLibWait;
	 routines.Set                     = NetWrkLibSet;
	 routines.Get                     = NetWrkLibGet;
	 routines.Simulate                = NetWrkLibSimulate;
	 routines.RemoteControl           = NetWrkLibRemoteControl;
	 routines.GetRemote               = NetWrkLibGetRemote;
	 routines.GetTime                 = NetWrkLibGetTime;
	 routines.GetTelegram             = NetWrkLibGetTelegram;
	 routines.GetInstalledModuleCount = NetWrkLibGetInstalledModuleCount;
	 routines.GetPtimObject           = NetWrkLibGetPtimObject;
	 routines.GetCtimObject           = NetWrkLibGetCtimObject;
	 routines.GetHandle               = NetWrkLibGetHandle;
	 routines.CreateCtimObject        = NetWrkLibCreateCtimObject;
	 routines.CreatePtimObject        = NetWrkLibCreatePtimObject;
	 routines.GetCableId              = NetWrkLibGetCableId;

	 routines.GetStatus               = NetWrkLibGetStatus;
	 routines.GetModuleVersion        = NetWrkLibGetModuleVersion;
	 routines.GetAllPtimObjects       = NetWrkLibGetAllPtimObjects;
	 routines.GetAllCtimObjects       = NetWrkLibGetAllCtimObjects;
	 routines.GetQueueSize            = NetWrkLibGetQueueSize;
	 routines.GetSpecificInfo         = NetWrkLibGetSpecificInfo;

	 routines.FdConnect               = NetWrkLibFdConnect;
	 routines.FdQueue                 = NetWrkLibFdQueue;
	 routines.FdWait                  = NetWrkLibFdWait;

	 routines.ConnectPayload          = NetWrkLibConnectPayload;

	 if (fd) return (TimLibError) NetWrkLibFdInitialize(device);
		 return               NetWrkLibInitialize(device);

      default: break;
   }
   return TimLibErrorINIT;
}

/* ==================================================================== */
/* Little routines to try to handle "0" module numbers in the best way. */

static unsigned long CblIds[TimLibMODULES];
static unsigned long CblVal = 0;

unsigned long GetCableIds() {

int i;

   if (CblVal == 0) {
      bzero((void *) CblIds, sizeof(unsigned long) * TimLibMODULES);
      CblVal = TimLibGetInstalledModuleCount();
      if (CblVal > TimLibMODULES) CblVal = TimLibMODULES;

      for (i=0; i<CblVal; i++) {
	 if (TimLibGetCableId(i+1,&CblIds[i]) != TimLibErrorSUCCESS) {
	    CblVal = 0;
	    break;
	 }
      }
   }
   return CblVal;
}

/* =============================================== */

unsigned long GetModuleForCtim(unsigned long ctim) {

int i;
unsigned long cblid;

   if (GetCableIds()) {
      cblid = TgvFirstCableIdForMember(ctim);
      while (cblid != TgvCABLE_ID_NONE) {
	 for (i=0; i<CblVal; i++) {
	    if (cblid == CblIds[i]) return i+1;
	 }
	 cblid = TgvNextCableIdForMember();
      }
   }
   return 0;
}

/* =============================================== */

unsigned long GetModuleForMch(TgmMachine mch) {

int i;
unsigned long cblid;

   if (GetCableIds()) {
      cblid = TgvFirstCableIdForMachine(TgvTgmToTgvMachine(mch));
      while (cblid != TgvCABLE_ID_NONE) {
	 for (i=0; i<CblVal; i++) {
	    if (cblid == CblIds[i]) return i+1;
	 }
	 cblid = TgvNextCableIdForMachine();
      }
   }
   return 0;
}

/* ==================================================================== */
/* This routine could have been hidden from the user of the Timing lib, */
/* however, in some circumstances, the initialization can take several  */
/* minutes to complete. Hence I have decided to make an initialization  */
/* routine publicly available, and force users to call it.              */
/* This routine performs the following initialization functions...      */
/*    1) Opens a connection to the driver                               */
/*    2) Checks the Firmware/VHDL version against the latest revision   */
/*       Some EProms/FPGAs may need updating, this takes a while.       */
/*    3) Load all relavent CTIM and PTIM definitions if needed.         */
/* This is the CTR implementation, so device is irrelevant here.        */

/* These control behaviour of TimLibInit */

int timlib_debug     = 0;   /* 1/Print stuff, 2/Wipe memory */
int timlib_delay     = 0;   /* Input delay when not zero */
int timlib_enable    = 0;   /* Enable modules */
int timlib_jtag      = 0;   /* Check VHDL versions */
int timlib_ctims     = 300; /* For CPS Tg8, max size of CTIMS to allocate   */
int timlib_oby1_8    = 0;   /* CTRV Only: VME P2: 8 Output bytes for modules 1 to 8 */
int timlib_oby9_16   = 0;   /* CTRV Only: VME P2: 8 Output bytes for modules 9 to 16 */
int timlib_real_utc  = 0;   /* Frig UTC to PS TG8 if zero */
int timlib_allow_old = 0;   /* Don't allow old style SPS headers */

static int libinitialized = 0;

TimLibError TimLibInitialize(TimLibDevice device) { /* Initialize hardware/software */
TimLibDevice fdev, ldev, dev;
TimLibError err;

   if (libinitialized == 0) {

      if (device == TimLibDevice_ANY) {
	 fdev = TimLibDevice_CTR;
	 ldev = TimLibDevice_NETWORK;
      } else {
	 fdev = device;
	 ldev = device;
      }

      for (dev=fdev; dev<=ldev; dev++) {
	 err = InitDevice(0,dev);
	 if (err == TimLibErrorSUCCESS) {
	    libinitialized = 1;
	    return err;
	 }
      }
   } else return TimLibErrorSUCCESS;

   return TimLibErrorINIT;
}

/* ====== */
/* ==================================================================== */
/* For multi-threaded applications, each thread needs its own filedesc. */
/* This initialize will return a new file descriptor each time it is    */
/* called. Today the drivers support a maximum of 16 file descriptors   */
/* so the resource is limited and should be used economically; always   */
/* call "close(fd)" when the descriptor is no longer needed. In case of */
/* errors, a zero is returned.                                          */

int TimLibFdInitialize(TimLibDevice device) { /* Initialize hardware/software */
TimLibDevice fdev, ldev, dev;
int fd;

   if (device == TimLibDevice_ANY) {
      fdev = TimLibDevice_CTR;
      ldev = TimLibDevice_NETWORK;
   } else {
      fdev = device;
      ldev = device;
   }

   for (dev=fdev; dev<=ldev; dev++) {
      fd = (int) InitDevice(1,dev);
      if (fd) {
	 libinitialized = 1;
	 return fd;
      }
   }
   return 0;
}

/* ==================================================================== */
/* Get the version, returns a string containing date time of compiled.  */

char *TimLibGetVersion() {
static char version[32];

   sprintf(version,"%s %s",__DATE__,__TIME__);
   return version;
}

/* ==================================================================== */
/* Get VHDL/Firmware version of all modules, and the correct version.   */

TimLibError TimLibGetModuleVersion(TimLibModuleVersion *tver) {

   return routines.GetModuleVersion(tver);
}

/* ==================================================================== */
/* Get the status of a module and its device type.                      */

TimLibStatus TimLibGetStatus(unsigned long module, TimLibDevice *dev) {

   if (libinitialized) return routines.GetStatus(module,dev);
   return 0;
}

/* ==================================================================== */
/* Connect to an interrupt. If you are connecting to either a CTIM      */
/* interrupt or to a hardware interrupt, you may need to specify on     */
/* which device the interrupt should be connected. This is achieved by  */
/* the module parameter. If the module is zero, the system will decide  */
/* which device to use, otherwise module contains a value between 1 and */
/* the number of installed timing receiver cards. For PTIM objects the  */
/* module parameter must be set to zero or the real module on which the */
/* PTIM object is implemented. On PTIM objects the module is implicit.  */

TimLibError TimLibConnect(TimLibClass   iclss,    /* Class of interrupt */
			  unsigned long equip,    /* Equipment or hardware mask */
			  unsigned long module) { /* For HARD or CTIM classes */

#define OLD_SPS_SSC_HEADER 0x20000000
#define OLD_SPS_HEADER 0x21000000
#define ANCIENT_SPS_HEADER 0x2F000000

unsigned long frame;
unsigned long header;
TimLibStatus  sts;
TimLibDevice  dev;

   if (libinitialized) {
      if (iclss == TimLibClassCTIM) {
	 frame = TgvGetFrameForMember(equip);
	 if (frame != 0) {
	    header = frame & 0xFF000000;
	    if ( (timlib_allow_old == 0)
	    &&   ( (header == OLD_SPS_HEADER)
	    ||     (header == ANCIENT_SPS_HEADER)
	    ||     (header == OLD_SPS_SSC_HEADER) ) ) {

	       /* Can't connect to old style SPS events */

	       fprintf(stderr,"ERROR: Connecting to a deprecated SPS event: CTIM:%d Frame:0x%08X\n",
		       (int) equip, (int) frame);
	       return TimLibErrorCONNECT;
	    }
	 }
	 if (module == 0) module = GetModuleForCtim(equip);
      }
      if (iclss != TimLibClassHARDWARE) {
	 if (module) {
	    sts = TimLibGetStatus(module,&dev);
	    if ((sts & TimLibStatusENABLED) == 0) return TimLibErrorNOT_ENAB;
	 }
      }
      return routines.Connect(iclss,equip,module);
   }
   return TimLibErrorINIT;
}

/* ==================================================================== */
/* Connect to a CTIM with specified payload                             */

TimLibError TimLibConnectPayload(unsigned long ctim,        /* The CTIM ID you want to connect to */
				 unsigned long payload,     /* The 16 bit payload in a long */
				 unsigned long module) {    /* The module, or zero means don't care */

   if (libinitialized) return routines.ConnectPayload(ctim,payload,module);
   return TimLibErrorINIT;
}

/* ==================================================================== */
/* Get the module that best suits a given CTIM based on the cable ID    */

unsigned long TimLibGetModuleForCtim(unsigned long ctim) {
   return GetModuleForCtim(ctim);
}

/* ==================================================================== */
/* Disconnect from an interrupt                                         */

TimLibError TimLibDisConnect(TimLibClass   iclss,    /* Class of interrupt */
			     unsigned long equip,    /* Equipment or hardware mask */
			     unsigned long module) { /* For HARD or CTIM classes */

   if (libinitialized) return routines.DisConnect(iclss,equip,module);
   return TimLibErrorINIT;
}

/* ==================================================================== */
/* Set queueing On or Off, and the time out value in micro seconds.     */
/* A timeout value of zero means no time out, you wait for ever.        */

TimLibError TimLibQueue(unsigned long qflag,    /* 0=>Queue, 1=>NoQueue  */
			unsigned long tmout) {  /* 0=>No time outs       */

   if (libinitialized) return routines.Queue(qflag,tmout);
   return TimLibErrorINIT;
}

/* ==================================================================== */
/* To know if a call to wait will block, this call returns the Queue    */
/* size. If the size iz greater than zero a call to wait will not block */
/* and return without waiting. If the qflag is set to NoQueue, zero is  */
/* allways returned and all calls to wait will block.                   */

unsigned long TimLibGetQueueSize() {

   if (libinitialized) return routines.GetQueueSize();
   return TimLibErrorINIT;
}

/* ==================================================================== */
/* Wait for an interrupt. The parameters are all returned from the call */
/* so you can know which interrupt it was that came back. Note, when    */
/* waiting for a hardware interrupt from either CTIM or from a counter, */
/* it is the CTIM or PTIM object that caused the interrupt returned.    */
/* The telegram will have been read already by the high prioity task    */
/* get_tgm_ctr/tg8, be aware of the race condition here, hence payload. */
/* This routine is a blocking call, it waits for interrupt or timeout.  */
/* Any NULL argument  is permitted, and no value will be returned.      */

/* Arguments:                                                           */
/*    iclss:   The class of the interrupt CTIM, PTIM, or hardware       */
/*    equip:   The PTIM, CTIM equipment, or hardware mask               */
/*    plnum:   If class is PTIM this is the PLS line number             */
/*    source:  The hardware source of the interrupt                     */
/*    onzero:  The time of the interrupt                                */
/*    trigger: The arrival time of the event that triggered the action  */
/*    start:   The time the start of the counter occured                */
/*    ctim:    The CTIM equipment number of the triggering event        */
/*    payload: The payload of the triggering event                      */
/*    module:  The module number 1..n of the timing receiver card       */
/*    missed:  The number of missed events since the last wait          */
/*    qsize:   The number of remaining interrupts on the queue          */
/*    mch:     The machine to which the interrupt belongs               */

TimLibError TimLibWait(TimLibClass    *iclss,   /* Class of interrupt */
		       unsigned long  *equip,   /* PTIM CTIM or hardware mask */
		       unsigned long  *plnum,   /* Ptim line number 1..n or 0 */
		       TimLibHardware *source,  /* Hardware source of interrupt */
		       TimLibTime     *onzero,  /* Time of interrupt/output */
		       TimLibTime     *trigger, /* Time of counters load */
		       TimLibTime     *start,   /* Time of counters start */
		       unsigned long  *ctim,    /* CTIM trigger equipment ID */
		       unsigned long  *payload, /* Payload of trigger event */
		       unsigned long  *module,  /* Module that interrupted */
		       unsigned long  *missed,  /* Number of missed interrupts */
		       unsigned long  *qsize,   /* Remaining interrupts on queue */
		       TgmMachine     *mch) {   /* Corresponding TgmMachine */


   if (libinitialized) {

      return routines.Wait(iclss,
			   equip,
			   plnum,
			   source,
			   onzero,
			   trigger,
			   start,
			   ctim,
			   payload,
			   module,
			   missed,
			   qsize,
			   mch);
   }
   return TimLibErrorINIT;
}

/* ==================================================================== */
/* Set the Ccv of a PTIM equipment. Note neither the counter number nor */
/* the trigger condition can be changed.                                */

TimLibError TimLibSet(unsigned long ptim,    /* PTIM to write to */
		      unsigned long plnum,   /* Ptim line number 1..n or 0 */
		      unsigned long grnum,   /* Tgm group number or Zero */
		      unsigned long grval,   /* Group value if num not zero */
		      TimLibCcvMask ccvm,    /* Which values to write */
		      TimLibCcv     *ccv) {  /* Current control value */

   if (libinitialized) return routines.Set(ptim,plnum,grnum,grval,ccvm,ccv);
   return TimLibErrorINIT;
}

/* ==================================================================== */
/* Get the Ccv of a PTIM equipment.                                     */

TimLibError TimLibGet(unsigned long ptim,
		      unsigned long plnum,   /* Ptim line number 1..n or 0 */
		      unsigned long grnum,
		      unsigned long grval,
		      TimLibCcvMask *ccvm,   /* Valid fields in ccv */
		      TimLibCcv     *ccv) {

   if (libinitialized) return routines.Get(ptim,plnum,grnum,grval,ccvm,ccv);
   return TimLibErrorINIT;
}

/* ==================================================================== */
/* By writing to the driver this call simulates an interrupt for the    */
/* connected clients. Also it can be used as a way of synchronizing     */
/* processes, this is especially important in Linux systems where the   */
/* schedular is not preemptive.                                         */

/* Arguments:                                                                     */
/*    iclss:   Class of interrupt to simulate, PTIM, CTIM or Hardware             */
/*    equip:   Equipment number for PTIM or CTIM, hardware mask for Hardware      */
/*    module:  When class is CTIM or Hardware, the module number is used          */
/*    machine: Telegram ID is used for PTIM interrupts if grnum is not zero       */
/*    grnum:   If zero, no telegram checking, else the PTIM triggers group number */
/*    grval:   The telegram group value for the PTIM trigger                      */

TimLibError TimLibSimulate(TimLibClass   iclss,
			   unsigned long equip,
			   unsigned long module,
			   TgmMachine    machine,
			   unsigned long grnum,
			   unsigned long grval) {

   if (libinitialized) return routines.Simulate(iclss,equip,module,machine,grnum,grval);
   return TimLibErrorINIT;
}

/* ==================================================================== */
/* Set a counter under full remote control (IE under DSC tasks control) */
/* This feature permits you to do what you like with counters even if   */
/* there is no timing cable attached. With this you can drive stepper   */
/* motors, wire scanners or whatever. No PTIM or CTIM is involved, the  */
/* configuration is loaded directly by the application. Note that when  */
/* the argument remflg is set to 1, the counter can not be written to   */
/* by incomming triggers so all PTIM objects using the counter stop     */
/* overwriting the counter configuration and are effectivley disabled.  */
/* Setting the remflg 0 permits PTIM triggers to write to the counter   */
/* configuration, the write block is removed. Also note that in some    */
/* cases it is useful to perform remote actions, such as remoteSTOP,    */
/* even if the remflg is set to zero. The remflg simply blocks PTIM     */
/* overwrites, the counter configuration can still be accessed !        */

TimLibError TimLibRemoteControl(unsigned long remflg, /* 0 = Normal, 1 = Remote */
				unsigned long module, /* Module or zero */
				unsigned long cntr,   /* 1..8 counter number */
				TimLibRemote  rcmd,   /* Command */
				TimLibCcvMask ccvm,   /* Fields to be set */
				TimLibCcv     *ccv) { /* Value to load in counter */

   if (libinitialized) return routines.RemoteControl(remflg,module,cntr,rcmd,ccvm,ccv);
   return TimLibErrorINIT;
}

/* ==================================================================== */
/* Get a counters remote configuration                                  */

TimLibError TimLibGetRemote(unsigned long module,
			    unsigned long cntr,
			    unsigned long *remflg,
			    TimLibCcvMask *ccvm,
			    TimLibCcv     *ccv) {

   if (libinitialized) return routines.GetRemote(module,cntr,remflg,ccvm,ccv);
   return TimLibErrorINIT;
}

/* ==================================================================== */
/* Read the instantaneous value of the time in UTC. The module parameter*/
/* can be set to zero in which case the system decideds which module to */
/* read the time from, otherwise it can be set to a value between 1 and */
/* the number of installed modules.                                     */

TimLibError TimLibGetTime(unsigned long module, /* Module number to read from */
			  TimLibTime    *utc) { /* Returned time value */


   if (libinitialized) return routines.GetTime(module,utc);
   return TimLibErrorINIT;
}

/* ==================================================================== */
/* Read a machines telegram from a timing receiver. The module can be   */
/* either zero, in which case the system decides which device to use,   */
/* or it can be explicitly set between 1 and the number of installed    */
/* modules. The telegram object returned has an opaque structure and    */
/* can only be decoded through the Tgm library routine .....            */

/* unsigned long grval = TgmGetGroupValueFromTelegram(TgmMachine    machine,   */
/*                                                    unsigned long grnum,     */
/*                                                    TgmTelegram   *telegram) */

/* WARNING: The only task that should call this routine will be, get_tgm_lib,  */
/* all other, LOWER PRIORITY tasks must NEVER call this routine, instead they  */
/* should call the telegram library directly like this ...                     */

/* WARNING: If the calling task is not get_tgm_lib, then calling this routine  */
/* will actually be re-routed and the equivalent TGM call will be made instead */

/* TgmTelegram telegram;                                                       */
/*                                                                             */
/* if (TgmGetTelegram(machine, index, offset, &telegram) == TgmSUCCESS) { ...  */
/*                                                                             */
/* For more information on this function see the Tgm library man pages.        */

int TimLibClient = 0;
static int attached = 0;

TimLibError TimLibGetTelegram(unsigned long module,
			      TgmMachine    machine,
			      TgmTelegram   *telegram) {

int msk;

   if (TimLibClient) {
      if (libinitialized) {
	 if (module == 0) module = GetModuleForMch(machine);
	 return routines.GetTelegram(module,machine,(TgmPTelegram *) telegram);
      }
      return TimLibErrorINIT;
   }

   msk = 1 << (int) machine;
   if ((msk & attached) == 0) {
      if (TgmAttach(machine,TgmTELEGRAM) == TgmSUCCESS) {
	 attached |= msk;
	 sleep(1);
      } else return TimLibErrorINIT;
   }

   if (TgmGetTelegram(machine,TgmCURRENT,0,telegram) == TgmSUCCESS)
      return TimLibErrorSUCCESS;
   return TimLibErrorIO;
}

/* ==================================================================== */
/* Convert a TimLibError into a string. The returned char pointer is    */
/* either NULL if the supplied error is out of range, or it points to a */
/* static string contained on the library routines heap. You must copy  */
/* the string if you need to be sure it is not overwritten. Obviously   */
/* this routine is therfore not thread safe, but you don't need to free */
/* allocated memory thus avoiding potential memory leaks.               */

char *TimLibErrorToString(TimLibError error) {

static char *estr[TimLibERRORS] = {
"No Error ",
"Invalid hardware setting for this module type ",
"Invalid start setting for this module type ",
"Invalid mode setting for this module type ",
"Invalid clock setting for this module type ",
"Invalid pulse width setting for this module type ",
"Invalid delay value setting for this module type ",
"That remote command is not available on this module type ",
"No module with that number is installed ",
"Invalid counter/channel number for this module",
"No such PTIM equipment number defined ",
"No such CTIM equipment number defined ",
"That operation has been blocked ",
"PPM is not supported on this device type",
"No such telegram ID ",
"No such group for that PTIM object",
"Library not initialized or get_tgm_tim not running",
"Can not establish a connection to the hardware, OPEN failed ",
"Can not connect to the specified interrupt ",
"There are no connections to wait for ",
"Timeout occured in wait ",
"The queue flag is set 1=off, however queueing is needed ",
"Gereral IO error, see errno for more details ",
"That feature is not implemented on this device",
"That equipment exists already",
"Out of resource space or memory",
"The module is not enabled",
"Couldn't find a cycle for that time stamp",
"Cycle string did not specify an actual cycle" };

static char result[TimLibErrorSTRING_SIZE];
char *cp;

   if ((error < 0) || (error >= TimLibERRORS)) cp = "No such error number";
   else                                        cp = estr[(int) error];
   bzero((void *) result, TimLibErrorSTRING_SIZE);
   strcpy(result,cp);
   return result;
}

/* ==================================================================== */
/* Lets you know how many installed modules there are on this host.     */

unsigned long TimLibGetInstalledModuleCount() {

   if (libinitialized) return routines.GetInstalledModuleCount();
   return 0;
}

/* ==================================================================== */
/* Get the description of a given PTIM equipment. The dimension returns */
/* the PPM dimension, counter and module are obvious.                   */

TimLibError TimLibGetPtimObject(unsigned long ptim, /* PTIM equipment number */
				unsigned long *module,
				unsigned long *counter,
				unsigned long *dimension) {

   if (libinitialized) return routines.GetPtimObject(ptim,module,counter,dimension);
   return TimLibErrorINIT;
}

/* ==================================================================== */
/* Get the list of all defined PTIM objects                             */

TimLibError TimLibGetAllPtimObjects(unsigned long *ptimlist,  /* List of ptim equipments */
				    unsigned long *psize,     /* Number of ptims in list */
				    unsigned long size) {     /* Max size of list */

   if (libinitialized) return routines.GetAllPtimObjects(ptimlist,psize,size);
   return TimLibErrorINIT;
}

/* ==================================================================== */
/* Get the list of all defined CTIM objects                             */

TimLibError TimLibGetAllCtimObjects(unsigned long *ctimlist,  /* List of ctim equipments */
				    unsigned long *csize,     /* Number of ctims in list */
				    unsigned long size) {     /* Max size of list */

   if (libinitialized) return routines.GetAllCtimObjects(ctimlist,csize,size);
   return TimLibErrorINIT;
}

/* ==================================================================== */
/* Get the event code corresponding to a given CTIM equipment number.   */

TimLibError TimLibGetCtimObject(unsigned long ctim, /* CTIM equipment number */
				unsigned long *eventcode) {

   if (libinitialized) return routines.GetCtimObject(ctim,eventcode);
   return TimLibErrorINIT;
}

/* ==================================================================== */
/* In some cases when running a GUI under Linux, say, a file handle to  */
/* put in a "select" is needed so that one can wait on multiple file    */
/* handles simultaneously. This routine returns such a handle suitable  */
/* to check for waiting interrupts. Do not read directly from it, but   */
/* call the wait routine. The queue flag must be on for this to work !! */

TimLibError TimLibGetHandle(int *fd) {

   if (libinitialized) return routines.GetHandle(fd);
   return TimLibErrorINIT;
}

/* ==================================================================== */
/* Create a new PTIM object, the CCV settings will be defaulted.        */


TimLibError TimLibCreatePtimObject(unsigned long ptim, /* PTIM equipment number */
				   unsigned long module,
				   unsigned long counter,
				   unsigned long dimension) {

   if (libinitialized) return routines.CreatePtimObject(ptim,module,counter,dimension);
   return TimLibErrorINIT;
}

/* ==================================================================== */
/* Create a new CTIM object. If a payload is to be used for this event  */
/* be sure to set the low 16-Bits to 0xFFFF                             */

TimLibError TimLibCreateCtimObject(unsigned long ctim, /* CTIM equipment number */
				   unsigned long eventcode) {

   if (libinitialized) return routines.CreateCtimObject(ctim,eventcode);
   return TimLibErrorINIT;
}

/* ==================================================================== */
/* Set the debug level                                                  */

void TimLibSetDebug(unsigned long level) { /* Zero means no debug */
   timlib_debug = level;
   if (timlib_debug) fprintf(stderr,"TimLibSetDebug:ON Level:%d\n",(int) timlib_debug);
}

/* ==================================================================== */
/* Get the cable identifier to which a given module is attached so that */
/* the correct module can be used to read telegrams. This function will */
/* be used by the program get_tgm_tim only; it is of no interest to the */
/* majority of clients because calls to ReadTelegram are diverted.      */

TimLibError TimLibGetCableId(unsigned long module,   /* The given module */
			     unsigned long *cable) { /* The cable ID */

   if (libinitialized) return routines.GetCableId(module,cable);
   return TimLibErrorINIT;
}

/* ==================================================================== */
/* Get telegram information from a time stamp.                          */
/* This routine searches the telegram history for a cycle in which your */
/* time stamp occured. It then returns the cycles time stamp in which   */
/* the time you gave occurd and its present and next tags.              */
/* Null pointers for cyclestamp, cytag and ncytag are allowed, and in   */
/* particular the routine runs faster when the tags are null.           */

TimLibError TimLibGetTgmInfo(TimLibTime    stamp,       /* Time you want telegram information about */
			     TimLibTime    *cyclestamp, /* Time of cycle for given stamp */
			     unsigned long *cytag,      /* Cycle tag */
			     unsigned long *ncytag) {   /* Next cycle tag */


TgmHistoryBuffer *his;
TgmMachine mch;
unsigned long secs, mlsc, nano;
int of, msk;

unsigned long gcytag, gncytag;

   msk = 1 << (int) stamp.Machine;
   if ((msk & attached) == 0) {
      if (TgmAttach(stamp.Machine,TgmTELEGRAM) == TgmSUCCESS) {
	 attached |= msk;
	 sleep(1);
      } else return TimLibErrorINIT;
   }

   for (of=0; of<BlkEVENT_HISTORY_SIZE; of++) {
      his = (TgmHistoryBuffer *) TgmGetEvent(of);
      if (his) {
	 mch = (TgmMachine) TgmHisGetMachine(his);
	 if (stamp.Machine == mch) {
	    secs = (unsigned long) TgmHisGetCycleTimeSec(his);
	    mlsc = (unsigned long) TgmHisGetCycleTimeMSc(his);
	    nano = mlsc * 1000000;
	    if (stamp.Second < secs) continue;
	    if (stamp.Second > secs) break;
	    if (stamp.Nano   < nano) continue;
	    break;
	 }
      } else return TimLibErrorNOT_FOUND;
   }
   if (of<BlkEVENT_HISTORY_SIZE) {
      if (cyclestamp) {
	 cyclestamp->Second  = secs;
	 cyclestamp->Nano    = nano;
	 cyclestamp->Machine = mch;
	 cyclestamp->CTrain  = 0;
      }
      if (cytag) {
	 gcytag= (unsigned long) TgmGetGroupNumber(mch,"CYTAG");
	 if (gcytag) *cytag  = (unsigned long) TgmHisGetTelegram(his,gcytag);
	 else        *cytag  = 0;
      }
      if (ncytag) {
	 gncytag = (unsigned long) TgmGetGroupNumber(mch,"NCYTAG");
	 if (gncytag) *ncytag = (unsigned long) TgmHisGetTelegram(his,gncytag);
	 else         *ncytag = 0;
      }
      return TimLibErrorSUCCESS;
   }
   return TimLibErrorNOT_FOUND;
}

/* ==================================================================== */
/* Get a group value from the telegram for given cycle stamp.           */

TimLibError TimLibGetGroupValueFromStamp(TimLibTime    stamp, /* Cycle stamp  */
					 unsigned long gn,    /* Group number */
					 unsigned long next,  /* Next flag    */
					 unsigned long *gv) { /* Group value  */

TgmHistoryBuffer his, res, *rp;
unsigned long msk, g, v;

   msk = 1 << (int) stamp.Machine;
   if ((msk & attached) == 0) {
      if (TgmAttach(stamp.Machine,TgmTELEGRAM) == TgmSUCCESS) {
	 attached |= msk;
	 sleep(1);
      } else return TimLibErrorINIT;
   }

   TgmHisClear(&his);
   TgmHisSetMachine(&his,stamp.Machine);
   TgmHisSetCycleTimeSec(&his,stamp.Second);
   TgmHisSetCycleTimeMSc(&his,stamp.Nano/1000000);

   rp = &res;
   if (TgmHisGetHistory(&his,1,&rp)) {
      if (gv) {
	 if (next) g = TgmGetNextGroupNumber(stamp.Machine,gn);
	 else      g = gn;
	 if (g == 0) return TimLibErrorGROUP;
	 v = TgmHisGetTelegram(rp,g);
	 if (gv) *gv = v;
      }
      return TimLibErrorSUCCESS;
   }
   return TimLibErrorNOT_FOUND;
}

/* ==================================================================== */
/* Convert a cycle Id string like CPS.USER.SFTPRO into a slot index.    */
/* No abbreviations are supported, seperators are dots. Strict Syntax.  */
/* The result is slix, the slot index ranging from [0..(GroupSize-1)].  */
/* No change is made to slix on error always check return before using. */

TimLibError TimLibStringToSlot(char          *cyid,     /* Cycle ID string */
			       unsigned long *slix) {   /* Resulting slot index */

TgmLineNameTable ltab;
char *cp, mch[TgmNAME_SIZE], grp[TgmNAME_SIZE], lnm[TgmNAME_SIZE];
int i, m;

   cp = cyid;
   if (cp == NULL) return TimLibErrorIO;

   i = 0;
   while ((*cp) && (*cp != '.'))
      mch[i++] = *cp++;
   mch[i] = 0; cp++;

   for (m=0; m<TgmMACHINES; m++) {
      if (strcmp(mch,TgmGetMachineName(m)) == 0) {
	 i=0;
	 while ((*cp) && (*cp != '.'))
	    grp[i++] = *cp++;
	 grp[i] = 0; cp++;
	 if (TgmGetLineNameTable(m,grp,&ltab) == TgmSUCCESS) {
	    i = 0;
	    while ((*cp) && (*cp != '.'))
	      lnm[i++] = *cp++;
	    lnm[i] = 0; cp++;
	    for (i=0; i<ltab.Size; i++) {
	       if (strcmp(lnm,ltab.Table[i].Name)==0) {
		  *slix = i;
		  return TimLibErrorSUCCESS;
	       }
	    }
	    return TimLibErrorSTRING;
	 }
	 return TimLibErrorSTRING;
      }
   }
   return TimLibErrorSTRING;
}

/* ==================================================================== */
/* Special IO routine for CTR only, Get CTR LEMO values                 */

TimLibError TimLibGetIoStatus(unsigned long module,
			      TimLibLemo *input) {

   return CtrLibGetIoStatus(module, input);
}

/* ==================================================================== */
/* Special IO routine for CTR only, Set Counter Output LEMO values      */

TimLibError TimLibSetOutputs(unsigned long module,
			     TimLibLemo output,     /* Output values */
			     TimLibLemo mask) {     /* Which ones you eant to set */

   return CtrLibSetOutputs(module, output, mask);
}

/* ==================================================================== */
/* Get specific information string                                      */
/* There is some very specific module dependent status information.     */
/* This routine returns a free format human readable string containing  */
/* specific status information that may help diagnosing problems for a  */
/* timing receiver module. A null pointer can be returned if the module */
/* is either dead or not installed.                                     */

char *TimLibGetSpecificInfo(unsigned long module) { /* The given module */

   if (libinitialized) return routines.GetSpecificInfo(module);
   return NULL;
}

/* ==================================================================== */
/* For multi-threaded applications, each thread needs its own filedesc. */
/* This is just like the usual connect except you must supply a fd that */
/* is open and was obtained from FdInitialize. Should you supply a fd   */
/* with a bad value the driver will check if it belongs to your process */
/* and if it dose it will use it. This may cause unpredictable results. */

TimLibError TimLibFdConnect(int         fd,       /* File descriptor */
			  TimLibClass   iclss,    /* Class of interrupt */
			  unsigned long equip,    /* Equipment or hardware mask */
			  unsigned long module) { /* For HARD or CTIM classes */

   return routines.FdConnect(fd,iclss,equip,module);
}

/* ==================================================================== */
/* For multi-threaded applications, each thread needs its own filedesc. */

TimLibError TimLibFdQueue(int         fd,        /* File descriptor */
			unsigned long qflag,     /* 0=>Queue, 1=>NoQueue  */
			unsigned long tmout) {   /* 0=>No time outs       */

   return routines.FdQueue(fd,qflag,tmout);
}

/* ==================================================================== */
/* For multi-threaded applications, each thread needs its own filedesc. */

TimLibError TimLibFdWait(int          fd,        /* File descriptor */
		       TimLibClass    *iclss,    /* Class of interrupt */
		       unsigned long  *equip,    /* PTIM CTIM or hardware mask */
		       unsigned long  *plnum,    /* Ptim line number 1..n or 0 */
		       TimLibHardware *source,   /* Hardware source of interrupt */
		       TimLibTime     *onzero,   /* Time of interrupt/output */
		       TimLibTime     *trigger,  /* Time of counters load */
		       TimLibTime     *start,    /* Time of counters start */
		       unsigned long  *ctim,     /* CTIM trigger equipment ID */
		       unsigned long  *payload,  /* Payload of trigger event */
		       unsigned long  *module,   /* Module that interrupted */
		       unsigned long  *missed,   /* Number of missed interrupts */
		       unsigned long  *qsize,    /* Remaining interrupts on queue */
		       TgmMachine     *mch) {    /* Corresponding TgmMachine */

   return routines.FdWait(fd,iclss,equip,plnum,source,onzero,trigger,start,
			  ctim,payload,module,missed,qsize,mch);
}

/* ==================================================================== */
/* Get the module statistics for the given module                       */

TimLibError TimLibGetModuleStats(unsigned long module,
				 TimLibModuleStats *stats) {

   return routines.GetModuleStats(module,stats);
}

/* ==================================================================== */
/* Control how the PLL locks after synchronization loss                 */

TimLibError TimLibSetPllLocking(unsigned long module,
				unsigned long lockflag) { /* 1=> Brutal, else Slow */

   return routines.SetPllLocking(module,lockflag);
}
@


1.60
log
@TgmGetInfo failed if used by more than one TgmMachine because
group numbers were static. Now we look up the groupnumber
each time its needed.
@
text
@d26 2
d30 1
d121 1
d199 1
@


1.59
log
@Added routines to connect to C-time and get module for a CTIM
@
text
@d917 1
a917 1
static unsigned long gcytag = 0xFFFF, gncytag = 0xFFFF;
d950 3
a952 3
	 if (gcytag == 0xFFFF)  gcytag  = (unsigned long) TgmGetGroupNumber(mch,"CYTAG");
	 if (gcytag)            *cytag  = (unsigned long) TgmHisGetTelegram(his,gcytag);
	 else                   *cytag  = 0;
d955 3
a957 3
	 if (gncytag == 0xFFFF) gncytag = (unsigned long) TgmGetGroupNumber(mch,"NCYTAG");
	 if (gncytag)           *ncytag = (unsigned long) TgmHisGetTelegram(his,gncytag);
	 else                   *ncytag = 0;
@


1.58
log
@*** empty log message ***
@
text
@d66 2
d113 2
d152 2
d191 2
d227 2
d464 18
@


1.57
log
@*** empty log message ***
@
text
@d1023 2
a1024 1
TimLibError TimLibGetIoStatus(TimLibLemo *input) {
d1026 1
a1026 1
   return CtrLibGetIoStatus(input);
d1032 2
a1033 1
TimLibError TimLibSetOutputs(TimLibLemo output,     /* Output values */
d1036 1
a1036 1
   return CtrLibSetOutputs(output, mask);
@


1.56
log
@*** empty log message ***
@
text
@d63 3
d108 3
d145 3
d182 3
d1097 18
@


1.55
log
@*** empty log message ***
@
text
@d854 2
a855 5
   if (TimLibClient) {
      if (libinitialized) return routines.GetCableId(module,cable);
      return TimLibErrorINIT;
   }
   return TimLibErrorBLOCKED;
@


1.54
log
@Bug in FdInit corrected
@
text
@d292 9
a300 8
int timlib_debug   = 0;   /* 1/Print stuff, 2/Wipe memory */
int timlib_delay   = 0;   /* Input delay when not zero */
int timlib_enable  = 0;   /* Enable modules */
int timlib_jtag    = 0;   /* Check VHDL versions */
int timlib_ctims   = 300; /* For CPS Tg8, max size of CTIMS to allocate   */
int timlib_oby1_8  = 0;   /* CTRV Only: VME P2: 8 Output bytes for modules 1 to 8 */
int timlib_oby9_16 = 0;   /* CTRV Only: VME P2: 8 Output bytes for modules 9 to 16 */
int timlib_real_utc= 0;   /* Frig UTC to PS TG8 if zero */
d416 4
a419 3
	    if ( (header == OLD_SPS_HEADER)
	    ||   (header == ANCIENT_SPS_HEADER)
	    ||   (header == OLD_SPS_SSC_HEADER) ) {
@


1.53
log
@Added Thread support via File Descriptor FD extra parameter
@
text
@d352 4
a355 1
      if (fd) return fd;
@


1.52
log
@Added default module logic to search over cable ids
to find the best one to read events or telegrams from
@
text
@d59 4
d70 1
a70 1
static TimLibError InitDevice(TimLibDevice device) {
d101 6
a106 1
	 return CtrLibInitialize(device);
d135 6
a140 1
	 return Tg8CpsLibInitialize(device);
d169 6
a174 1
	 return Tg8SpsLibInitialize(device);
d203 6
a208 1
	 return NetWrkLibInitialize(device);
d318 1
a318 1
	 err = InitDevice(dev);
d329 28
d1036 47
@


1.51
log
@Added specific status info string
@
text
@d192 63
d371 1
d618 4
a621 1
      if (libinitialized) return routines.GetTelegram(module,machine,(TgmPTelegram *) telegram);
@


1.50
log
@Added GetModuleVersion
@
text
@d57 2
d95 1
d124 1
d153 1
d182 1
d903 14
@


1.49
log
@DisConnect
@
text
@d51 2
d89 1
d117 1
d145 1
d173 1
d247 8
@


1.48
log
@Added IO routines for the CTR modules only
@
text
@d32 1
d68 1
d95 1
d122 1
d149 1
d301 11
@


1.47
log
@Removed Legacy event support 20,21,2F headers
Removed FESA2.6 support
Removed adjust time to tg8, tg8 firmware will be changed
@
text
@d850 17
@


1.46
log
@Added GetQueueSize
@
text
@d258 1
d273 2
a274 1
	 /* ||   (header == ANCIENT_SPS_HEADER) */ ) {
a279 1
	       fprintf(stderr,"ERROR: FESA Can not handle old style SPS payloads\n");
@


1.45
log
@Bug corrected, some groups can have a zero value
@
text
@d52 1
d87 1
d113 1
d139 1
d165 1
d306 12
@


1.44
log
@Allowed 2F connections
Bug in Connect with 0 module gave error via GetStatus
@
text
@d190 1
a779 1
	 if (v == 0) return TimLibErrorGROUP;
@


1.43
log
@Added ifdef FESA2p7 to suppress frigging CYTAG payloads
@
text
@d265 2
a266 1
	    if ((header == OLD_SPS_HEADER) || (header == ANCIENT_SPS_HEADER)) {
d278 4
a281 2
	 sts = TimLibGetStatus(module,&dev);
	 if ((sts & TimLibStatusENABLED) == 0) return TimLibErrorNOT_ENAB;
@


1.42
log
@In TimLibGetTgmInfo if CYTAG or NCYTAG are not present avoid futher processing
and hence calls to errlog.
@
text
@d267 1
a267 1
	       /* Warn people off old style SPS events */
d269 1
a269 1
	       fprintf(stderr,"WARNING: Connecting to a deprecated SPS event: CTIM:%d Frame:0x%08X\n",
d271 2
a272 4
	       fprintf(stderr,"WARNING: This will become a fatal error soon\n");
	       fprintf(stderr,"WARNING: Please ask for the correct equivalent CTIM\n");
	       fprintf(stderr,"WARNING: Header: 0x%2X will not be supported in future\n",
		       (int) (frame >> 24));
@


1.41
log
@*** empty log message ***
@
text
@d697 1
a697 1
unsigned long secs, mlsc, nano, gcytag, gncytag;
d700 2
d733 3
a735 2
	 gcytag  = (unsigned long) TgmGetGroupNumber(mch,"CYTAG");
	 *cytag  = (unsigned long) TgmHisGetTelegram(his,gcytag);
d738 3
a740 2
	 gncytag = (unsigned long) TgmGetGroupNumber(mch,"NCYTAG");
	 *ncytag = (unsigned long) TgmHisGetTelegram(his,gncytag);
@


1.40
log
@*** empty log message ***
@
text
@a11 1
#include <io.h>
@


1.39
log
@*** empty log message ***
@
text
@d554 2
a555 1
"Couldn't find a cycle for that time stamp" };
d782 46
@


1.38
log
@Added stuff to get Tgm info
@
text
@d502 1
d508 1
a508 1
      }
d510 1
d543 1
a543 1
"The Hardware has not been Initialized",
d686 2
d698 1
a698 1
int of;
d700 7
a706 2
   if (TgmAttach(stamp.Machine,TgmTELEGRAM) != TgmSUCCESS)
      return TimLibErrorMACHINE;
d742 39
@


1.37
log
@Added logic to set output bytes on CTRV P2 connector
@
text
@d551 2
a552 1
"The module is not enabled" };
d678 55
@


1.36
log
@*** empty log message ***
@
text
@d184 7
a190 5
int timlib_debug  = 0;   /* 1/Print stuff, 2/Wipe memory */
int timlib_delay  = 0;   /* Input delay when not zero */
int timlib_enable = 0;   /* Enable modules */
int timlib_jtag   = 0;   /* Check VHDL versions */
int timlib_ctims  = 300; /* For CPS Tg8, max size of CTIMS to allocate   */
@


1.35
log
@Dynamic calculation of CTIM size for TG8 CPS
@
text
@d184 5
a188 4
int timlib_debug  = 0;  /* 1/Print stuff, 2/Wipe memory */
int timlib_delay  = 0;  /* Input delay when not zero */
int timlib_enable = 0;  /* Enable modules */
int timlib_jtag   = 0;  /* Check VHDL versions */
a644 2
int timlib_ctims = 300; /* For CPS Tg8, max size of CTIMS to allocate   */

@


1.34
log
@Added CTIM edit
@
text
@d644 2
@


1.33
log
@Added GetAllCtims
@
text
@d261 13
a273 12
	 if (frame == 0) return TimLibErrorCTIM;
	 header = frame & 0xFF000000;
	 if ((header == OLD_SPS_HEADER) || (header == ANCIENT_SPS_HEADER)) {

	    /* Warn people off old style SPS events */

	    fprintf(stderr,"WARNING: Connecting to a deprecated SPS event: CTIM:%d Frame:0x%08X\n",
		    (int) equip, (int) frame);
	    fprintf(stderr,"WARNING: This will become a fatal error soon\n");
	    fprintf(stderr,"WARNING: Please ask for the correct equivalent CTIM\n");
	    fprintf(stderr,"WARNING: Header: 0x%2X will not be supported in future\n",
		    (int) (frame >> 24));
@


1.32
log
@Added error to connect on a disabled module for PTIM or CTIM
@
text
@d52 1
d86 1
d111 1
d136 1
d161 1
d593 11
@


1.31
log
@Added VHDL reloader
@
text
@d250 2
d270 4
d329 17
a345 3
   if (libinitialized) return
  
   routines.Wait(iclss,equip,plnum,source,onzero,trigger,start,ctim,payload,module,missed,qsize,mch);
d541 2
a542 1
"Out of resource space or memory" };
@


1.30
log
@*** empty log message ***
@
text
@d182 1
@


1.29
log
@*** empty log message ***
@
text
@d177 6
@


1.28
log
@*** empty log message ***
@
text
@a25 6
/* These control behaviour of TimLibInit */

int timlib_debug  = 0;  /* 1/Print stuff, 2/Wipe memory */
int timlib_delay  = 0;  /* Input delay when not zero */
int timlib_enable = 0;  /* Enable modules */

@


1.27
log
@Added inputdelay and enable
@
text
@d29 2
a30 2
int timlib_delay  = 40; /* Input delay when not zero */
int timlib_enable = 1;  /* Enable modules */
@


1.26
log
@*** empty log message ***
@
text
@d26 5
a30 1
static int timlib_debug = 0; /* 1/Print stuff, 2/Wipe memory */
@


1.25
log
@Ancient headers 0x2F added
@
text
@a242 1
TimLibError err;
d248 2
a249 2
	 err = TimLibGetCtimObject(equip,&frame);
	 if (err != TimLibErrorSUCCESS) return err;
@


1.24
log
@Warn against connecting to old style SPS events
@
text
@d240 3
d245 1
d251 2
a252 1
	 if ((frame & 0xFF000000) == 0x21000000) {
d260 2
a261 2
	    fprintf(stderr,"WARNING: Events frame: 0x%08X will not be supported in future\n",
		    (int) frame);
@


1.23
log
@*** empty log message ***
@
text
@d240 21
a260 1
   if (libinitialized) return routines.Connect(iclss,equip,module);
@


1.22
log
@*** empty log message ***
@
text
@d41 1
d74 1
d98 1
d122 1
d146 1
d381 13
@


1.21
log
@*** empty log message ***
@
text
@d512 1
a512 1
				    unsigned long *ptims,     /* Number of ptims in list */
d515 1
a515 1
   if (libinitialized) return routines.GetAllPtimObjects(ptimlist,ptims,size);
@


1.20
log
@Added GetStatus GetVersion GetSetDebud GetAllPtims GetAllCtims
Change call to GetCcv to include plnum handling
@
text
@d51 1
a51 1
   TimLibError   (*GetStatus)();
a52 1
   TimLibError   (*GetAllCtimObjects)();
a84 1
	 routines.GetAllCtimObjects       = CtrLibGetAllCtimObjects;
a107 1
	 routines.GetAllCtimObjects       = Tg8CpsLibGetAllCtimObjects;
a130 1
	 routines.GetAllCtimObjects       = Tg8SpsLibGetAllCtimObjects;
a153 1
	 routines.GetAllCtimObjects       = NetWrkLibGetAllCtimObjects;
d218 1
a218 1
   return TimLibErrorINIT;
a529 11
/* Get the list of all defined CTIM objects                             */

TimLibError TimLibGetAllCtimObjects(unsigned long *ctimlist,  /* List of ptim equipments */
				    unsigned long *ctims,     /* Number of ptims in list */
				    unsigned long size) {     /* Max size of list */

   if (libinitialized) return routines.GetAllPtimObjects(ctimlist,ctims,size);
   return TimLibErrorINIT;
}

/* ==================================================================== */
@


1.19
log
@*** empty log message ***
@
text
@d50 5
d83 5
d107 5
d131 5
d155 5
d208 19
d319 1
d322 1
a322 1
		      TimLibCcvMask *ccvm,     /* Valid fields in ccv */
d325 1
a325 1
   if (libinitialized) return routines.Get(ptim,grnum,grval,ccvm,ccv);
d514 11
d535 11
@


1.18
log
@*** empty log message ***
@
text
@d234 1
@


1.17
log
@..
@
text
@d31 1
a31 1
#include "./dtmtim/DtmTimLib.c"
d49 1
d77 1
d96 1
d115 1
d119 17
a135 16
	 routines.Connect                 = DtmTimLibConnect;
	 routines.Queue                   = DtmTimLibQueue;
	 routines.Wait                    = DtmTimLibWait;
	 routines.Set                     = DtmTimLibSet;
	 routines.Get                     = DtmTimLibGet;
	 routines.Simulate                = DtmTimLibSimulate;
	 routines.RemoteControl           = DtmTimLibRemoteControl;
	 routines.GetTime                 = DtmTimLibGetTime;
	 routines.GetTelegram             = DtmTimLibGetTelegram;
	 routines.GetInstalledModuleCount = DtmTimLibGetInstalledModuleCount;
	 routines.GetPtimObject           = DtmTimLibGetPtimObject;
	 routines.GetCtimObject           = DtmTimLibGetCtimObject;
	 routines.GetHandle               = DtmTimLibGetHandle;
	 routines.CreateCtimObject        = DtmTimLibCreateCtimObject;
	 routines.CreatePtimObject        = DtmTimLibCreatePtimObject;
	 return DtmTimLibInitialize(device);
d515 1
a515 1
/* Turn debugging on (!=0) or off (0)                                   */
d517 2
a518 2
void TimLibSetDebug(unsigned long on_off) { /* Not zero => On, Zero => off */
   timlib_debug = on_off;
d521 16
@


1.16
log
@*** empty log message ***
@
text
@d22 1
d377 1
a377 1
      if (libinitialized) return routines.GetTelegram(module,machine,telegram);
@


1.15
log
@*** empty log message ***
@
text
@a253 1
		      TgmMachine    machine, /* Telegram identifier */
a254 1
		      unsigned long ctim,    /* If plnum is not zero this is the ctim trigger */
d260 1
a260 1
   if (libinitialized) return routines.Set(ptim,machine,plnum,ctim,grnum,grval,ccvm,ccv);
a267 1
		      TgmMachine    machine,
d273 1
a273 1
   if (libinitialized) return routines.Get(ptim,machine,grnum,grval,ccvm,ccv);
@


1.14
log
@*** empty log message ***
@
text
@d321 1
d327 1
a327 1
   if (libinitialized) return routines.RemoteControl(remflg,cntr,rcmd,ccvm,ccv);
d412 1
a412 1
"Remote control is not available on this module type ",
@


1.13
log
@*** empty log message ***
@
text
@d25 2
d171 2
a172 1
   }
d510 7
@


1.12
log
@*** empty log message ***
@
text
@d414 1
@


1.11
log
@*** empty log message ***
@
text
@d382 1
@


1.10
log
@*** empty log message ***
@
text
@d167 1
a167 1
	 } else return err;
d170 1
a170 1
   return TimLibErrorSUCCESS;
d366 1
d372 2
d378 6
d409 1
@


1.9
log
@*** empty log message ***
@
text
@d252 2
d259 1
a259 1
   if (libinitialized) return routines.Set(ptim,machine,grnum,grval,ccvm,ccv);
@


1.8
log
@*** empty log message ***
@
text
@d410 3
a412 1
"That feature is not implemented on this device" };
@


1.7
log
@Added PTIM and CTIM creation
Added Polarity field in CCV
Added DEFAULT CCV settings
@
text
@d71 2
a72 2
	 routines.CreateCtim              = CtrLibCreateCtimObject;
	 routines.CreatePtim              = CtrLibCreatePtimObject;
d89 2
a90 2
	 routines.CreateCtim              = Tg8CpsLibCreateCtimObject;
	 routines.CreatePtim              = Tg8CpsLibCreatePtimObject;
d107 2
a108 2
	 routines.CreateCtim              = Tg8SpsLibCreateCtimObject;
	 routines.CreatePtim              = Tg8SpsLibCreatePtimObject;
d125 2
a126 2
	 routines.CreateCtim              = DtmTimLibCreateCtimObject;
	 routines.CreatePtim              = DtmTimLibCreatePtimObject;
d363 2
d369 7
a375 2
   if (libinitialized) return routines.GetTelegram(module,machine,telegram);
   return TimLibErrorINIT;
@


1.6
log
@Don't throw error if call to tim lib init when already initialized
@
text
@d44 2
d71 2
d89 2
d107 2
d125 2
d242 1
a242 1
routines.Wait(iclss,equip,plnum,source,onzero,trigger,start,ctim,payload,module,missed,qsize,mch);
d354 3
d459 25
@


1.5
log
@*** empty log message ***
@
text
@d157 1
a157 1
	 }
d160 1
a160 1
   return TimLibErrorINIT;  /* Error Library not initialized */
@


1.4
log
@*** empty log message ***
@
text
@d227 2
a228 1
		       unsigned long  *qsize) { /* Remaining interrupts on queue */
d230 3
a232 1
   if (libinitialized) return routines.Wait(iclss,equip,plnum,source,onzero,trigger,start,ctim,payload,module,missed,qsize);
@


1.3
log
@*** empty log message ***
@
text
@d25 1
a25 2
#include "./ctri/CtriLib.c"
#include "./ctrv/CtrvLib.c"
d55 15
a69 31
      case TimLibDevice_CTR_PCI:
	 routines.Connect                 = CtriLibConnect;
	 routines.Queue                   = CtriLibQueue;
	 routines.Wait                    = CtriLibWait;
	 routines.Set                     = CtriLibSet;
	 routines.Get                     = CtriLibGet;
	 routines.Simulate                = CtriLibSimulate;
	 routines.RemoteControl           = CtriLibRemoteControl;
	 routines.GetTime                 = CtriLibGetTime;
	 routines.GetTelegram             = CtriLibGetTelegram;
	 routines.GetInstalledModuleCount = CtriLibGetInstalledModuleCount;
	 routines.GetPtimObject           = CtriLibGetPtimObject;
	 routines.GetCtimObject           = CtriLibGetCtimObject;
	 routines.GetHandle               = CtriLibGetHandle;
	 return CtriLibInitialize(device);

      case TimLibDevice_CTR_VME:
	 routines.Connect                 = CtrvLibConnect;
	 routines.Queue                   = CtrvLibQueue;
	 routines.Wait                    = CtrvLibWait;
	 routines.Set                     = CtrvLibSet;
	 routines.Get                     = CtrvLibGet;
	 routines.Simulate                = CtrvLibSimulate;
	 routines.RemoteControl           = CtrvLibRemoteControl;
	 routines.GetTime                 = CtrvLibGetTime;
	 routines.GetTelegram             = CtrvLibGetTelegram;
	 routines.GetInstalledModuleCount = CtrvLibGetInstalledModuleCount;
	 routines.GetPtimObject           = CtrvLibGetPtimObject;
	 routines.GetCtimObject           = CtrvLibGetCtimObject;
	 routines.GetHandle               = CtrvLibGetHandle;
	 return CtrvLibInitialize(device);
d145 1
a145 1
	 fdev = TimLibDevice_CTR_PCI;
@


1.2
log
@*** empty log message ***
@
text
@d32 13
a44 13
   TimLibError (*Connect)();
   TimLibError (*Queue)();
   TimLibError (*Wait)();
   TimLibError (*Set)();
   TimLibError (*Get)();
   TimLibError (*Simulate)();
   TimLibError (*RemoteControl)();
   TimLibError (*GetTime)();
   TimLibError (*GetTelegram)();
   TimLibError (*GetInstalledModuleCount)();
   TimLibError (*GetPtimObject)();
   TimLibError (*GetCtimObject)();
   TimLibError (*GetHandle)();
d69 1
a69 1
	 routines.GetHandle               = CtriLibHandle;
d85 1
a85 1
	 routines.GetHandle               = CtrvLibHandle;
d101 1
a101 1
	 routines.GetHandle               = Tg8CpsLibHandle;
d117 1
a117 1
	 routines.GetHandle               = Tg8SpsLibHandle;
d133 1
a133 1
	 routines.GetHandle               = DtmTimLibHandle;
d157 1
a171 1
	    libdevice = 1;
d194 1
a194 1
   if (libinitialized) return routines.Connect(iclss,equip,module)
@


1.1
log
@Initial revision
@
text
@d25 5
a29 74
TimLibError    CtriLibInitialize();
TimLibError    CtriLibConnect();
TimLibError    CtriLibQueue();
TimLibError    CtriLibWait();
TimLibError    CtriLibSet();
TimLibError    CtriLibGet();
TimLibError    CtriLibSimulate();
TimLibError    CtriLibRemoteControl();
TimLibError    CtriLibGetTime();
TimLibError    CtriLibGetTelegram();
unsigned long  CtriLibGetInstalledModuleCount();
TimLibError    CtriLibGetPtimObject();
TimLibError    CtriLibGetCtimObject();
TimLibError    CtriLibHandle();

TimLibError    CtrvLibInitialize();
TimLibError    CtrvLibConnect();
TimLibError    CtrvLibQueue();
TimLibError    CtrvLibWait();
TimLibError    CtrvLibSet();
TimLibError    CtrvLibGet();
TimLibError    CtrvLibSimulate();
TimLibError    CtrvLibRemoteControl();
TimLibError    CtrvLibGetTime();
TimLibError    CtrvLibGetTelegram();
unsigned long  CtrvLibGetInstalledModuleCount();
TimLibError    CtrvLibGetPtimObject();
TimLibError    CtrvLibGetCtimObject();
TimLibError    CtrvLibHandle();

TimLibError    Tg8CpsLibInitialize();
TimLibError    Tg8CpsLibConnect();
TimLibError    Tg8CpsLibQueue();
TimLibError    Tg8CpsLibWait();
TimLibError    Tg8CpsLibSet();
TimLibError    Tg8CpsLibGet();
TimLibError    Tg8CpsLibSimulate();
TimLibError    Tg8CpsLibRemoteControl();
TimLibError    Tg8CpsLibGetTime();
TimLibError    Tg8CpsLibGetTelegram();
unsigned long  Tg8CpsLibGetInstalledModuleCount();
TimLibError    Tg8CpsLibGetPtimObject();
TimLibError    Tg8CpsLibGetCtimObject();
TimLibError    Tg8CpsLibHandle();

TimLibError    Tg8SpsLibInitialize();
TimLibError    Tg8SpsLibConnect();
TimLibError    Tg8SpsLibQueue();
TimLibError    Tg8SpsLibWait();
TimLibError    Tg8SpsLibSet();
TimLibError    Tg8SpsLibGet();
TimLibError    Tg8SpsLibSimulate();
TimLibError    Tg8SpsLibRemoteControl();
TimLibError    Tg8SpsLibGetTime();
TimLibError    Tg8SpsLibGetTelegram();
unsigned long  Tg8SpsLibGetInstalledModuleCount();
TimLibError    Tg8SpsLibGetPtimObject();
TimLibError    Tg8SpsLibGetCtimObject();
TimLibError    Tg8SpsLibHandle();

TimLibError    DtmTimLibInitialize();
TimLibError    DtmTimLibConnect();
TimLibError    DtmTimLibQueue();
TimLibError    DtmTimLibWait();
TimLibError    DtmTimLibSet();
TimLibError    DtmTimLibGet();
TimLibError    DtmTimLibSimulate();
TimLibError    DtmTimLibRemoteControl();
TimLibError    DtmTimLibGetTime();
TimLibError    DtmTimLibGetTelegram();
unsigned long  DtmTimLibGetInstalledModuleCount();
TimLibError    DtmTimLibGetPtimObject();
TimLibError    DtmTimLibGetCtimObject();
TimLibError    DtmTimLibHandle();
d403 2
a404 1
"Gereral IO error, see errno for more details " };
@
