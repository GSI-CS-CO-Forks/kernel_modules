head	1.80;
access;
symbols;
locks; strict;
comment	@ * @;


1.80
date	2009.12.07.10.50.35;	author lewis;	state Exp;
branches;
next	1.79;

1.79
date	2008.11.12.13.54.52;	author lewis;	state Exp;
branches;
next	1.78;

1.78
date	2008.04.30.19.06.19;	author lewis;	state Exp;
branches;
next	1.77;

1.77
date	2008.04.11.07.47.57;	author lewis;	state Exp;
branches;
next	1.76;

1.76
date	2008.03.28.09.51.53;	author lewis;	state Exp;
branches;
next	1.75;

1.75
date	2008.03.26.09.13.28;	author lewis;	state Exp;
branches;
next	1.74;

1.74
date	2008.01.11.14.58.36;	author lewis;	state Exp;
branches;
next	1.73;

1.73
date	2007.12.18.15.48.23;	author lewis;	state Exp;
branches;
next	1.72;

1.72
date	2007.12.18.15.39.35;	author lewis;	state Exp;
branches;
next	1.71;

1.71
date	2007.12.17.15.23.41;	author lewis;	state Exp;
branches;
next	1.70;

1.70
date	2007.08.29.16.45.16;	author lewis;	state Exp;
branches;
next	1.69;

1.69
date	2007.08.14.15.54.19;	author lewis;	state Exp;
branches;
next	1.68;

1.68
date	2007.06.04.13.45.54;	author lewis;	state Exp;
branches;
next	1.67;

1.67
date	2007.05.03.09.30.00;	author lewis;	state Exp;
branches;
next	1.66;

1.66
date	2007.05.02.15.34.11;	author lewis;	state Exp;
branches;
next	1.65;

1.65
date	2007.02.12.17.58.06;	author lewis;	state Exp;
branches;
next	1.64;

1.64
date	2007.02.12.15.01.50;	author lewis;	state Exp;
branches;
next	1.63;

1.63
date	2007.02.12.14.13.25;	author lewis;	state Exp;
branches;
next	1.62;

1.62
date	2006.12.20.13.30.52;	author lewis;	state Exp;
branches;
next	1.61;

1.61
date	2006.12.19.16.05.22;	author lewis;	state Exp;
branches;
next	1.60;

1.60
date	2006.05.02.13.59.45;	author lewis;	state Exp;
branches;
next	1.59;

1.59
date	2006.04.26.15.02.56;	author lewis;	state Exp;
branches;
next	1.58;

1.58
date	2006.04.13.12.29.00;	author lewis;	state Exp;
branches;
next	1.57;

1.57
date	2006.03.17.10.38.02;	author lewis;	state Exp;
branches;
next	1.56;

1.56
date	2006.03.02.15.13.08;	author lewis;	state Exp;
branches;
next	1.55;

1.55
date	2006.02.13.16.17.47;	author lewis;	state Exp;
branches;
next	1.54;

1.54
date	2006.01.27.08.52.29;	author lewis;	state Exp;
branches;
next	1.53;

1.53
date	2006.01.25.09.51.53;	author lewis;	state Exp;
branches;
next	1.52;

1.52
date	2006.01.19.10.26.18;	author lewis;	state Exp;
branches;
next	1.51;

1.51
date	2005.11.03.18.25.40;	author lewis;	state Exp;
branches;
next	1.50;

1.50
date	2005.09.27.12.48.04;	author lewis;	state Exp;
branches;
next	1.49;

1.49
date	2005.09.27.12.23.03;	author lewis;	state Exp;
branches;
next	1.48;

1.48
date	2005.08.23.16.06.58;	author lewis;	state Exp;
branches;
next	1.47;

1.47
date	2005.08.03.12.21.23;	author lewis;	state Exp;
branches;
next	1.46;

1.46
date	2005.07.11.08.37.51;	author lewis;	state Exp;
branches;
next	1.45;

1.45
date	2005.07.11.08.25.40;	author lewis;	state Exp;
branches;
next	1.44;

1.44
date	2005.07.08.15.42.36;	author lewis;	state Exp;
branches;
next	1.43;

1.43
date	2005.07.08.15.38.16;	author lewis;	state Exp;
branches;
next	1.42;

1.42
date	2005.07.04.12.23.01;	author lewis;	state Exp;
branches;
next	1.41;

1.41
date	2005.07.04.12.13.29;	author lewis;	state Exp;
branches;
next	1.40;

1.40
date	2005.07.04.08.20.16;	author lewis;	state Exp;
branches;
next	1.39;

1.39
date	2005.07.01.16.19.16;	author lewis;	state Exp;
branches;
next	1.38;

1.38
date	2005.06.20.13.21.09;	author lewis;	state Exp;
branches;
next	1.37;

1.37
date	2005.06.20.12.48.31;	author lewis;	state Exp;
branches;
next	1.36;

1.36
date	2005.06.17.14.14.33;	author lewis;	state Exp;
branches;
next	1.35;

1.35
date	2005.05.18.11.56.50;	author lewis;	state Exp;
branches;
next	1.34;

1.34
date	2005.05.17.15.16.51;	author lewis;	state Exp;
branches;
next	1.33;

1.33
date	2005.05.17.14.32.38;	author baujc;	state Exp;
branches;
next	1.32;

1.32
date	2005.05.13.12.15.26;	author lewis;	state Exp;
branches;
next	1.31;

1.31
date	2005.05.04.13.37.55;	author lewis;	state Exp;
branches;
next	1.30;

1.30
date	2005.04.28.09.02.59;	author lewis;	state Exp;
branches;
next	1.29;

1.29
date	2005.04.28.08.45.49;	author lewis;	state Exp;
branches;
next	1.28;

1.28
date	2005.04.28.08.32.16;	author lewis;	state Exp;
branches;
next	1.27;

1.27
date	2005.04.15.09.30.32;	author lewis;	state Exp;
branches;
next	1.26;

1.26
date	2005.02.04.15.42.47;	author lewis;	state Exp;
branches;
next	1.25;

1.25
date	2005.02.04.13.29.46;	author lewis;	state Exp;
branches;
next	1.24;

1.24
date	2005.02.03.14.42.39;	author lewis;	state Exp;
branches;
next	1.23;

1.23
date	2005.02.02.17.19.52;	author ikozsar;	state Exp;
branches;
next	1.22;

1.22
date	2005.01.17.10.14.34;	author lewis;	state Exp;
branches;
next	1.21;

1.21
date	2005.01.12.14.08.07;	author lewis;	state Exp;
branches;
next	1.20;

1.20
date	2004.12.02.10.56.08;	author lewis;	state Exp;
branches;
next	1.19;

1.19
date	2004.11.24.17.50.05;	author lewis;	state Exp;
branches;
next	1.18;

1.18
date	2004.11.23.16.28.20;	author lewis;	state Exp;
branches;
next	1.17;

1.17
date	2004.11.23.15.58.07;	author lewis;	state Exp;
branches;
next	1.16;

1.16
date	2004.11.23.13.34.30;	author lewis;	state Exp;
branches;
next	1.15;

1.15
date	2004.11.22.16.51.21;	author lewis;	state Exp;
branches;
next	1.14;

1.14
date	2004.11.22.10.27.31;	author lewis;	state Exp;
branches;
next	1.13;

1.13
date	2004.11.19.16.02.49;	author lewis;	state Exp;
branches;
next	1.12;

1.12
date	2004.11.19.15.51.26;	author lewis;	state Exp;
branches;
next	1.11;

1.11
date	2004.11.19.08.45.44;	author lewis;	state Exp;
branches;
next	1.10;

1.10
date	2004.11.18.16.36.55;	author lewis;	state Exp;
branches;
next	1.9;

1.9
date	2004.11.17.10.44.17;	author lewis;	state Exp;
branches;
next	1.8;

1.8
date	2004.11.01.16.27.43;	author lewis;	state Exp;
branches;
next	1.7;

1.7
date	2004.10.26.12.26.01;	author lewis;	state Exp;
branches;
next	1.6;

1.6
date	2004.10.26.12.25.36;	author lewis;	state Exp;
branches;
next	1.5;

1.5
date	2004.10.26.12.24.09;	author lewis;	state Exp;
branches;
next	1.4;

1.4
date	2004.09.28.16.43.44;	author lewis;	state Exp;
branches;
next	1.3;

1.3
date	2004.08.20.16.14.40;	author lewis;	state Exp;
branches;
next	1.2;

1.2
date	2004.08.19.13.52.37;	author lewis;	state Exp;
branches;
next	1.1;

1.1
date	2004.07.29.15.29.04;	author lewis;	state Exp;
branches;
next	;


desc
@@


1.80
log
@*** empty log message ***
@
text
@/* ==================================================================== */
/* Implement the timing library over the CTR familly of timing receiver */
/* cards, PMC, PCI, and VME.                                            */
/* Julian Lewis May 2004                                                */
/* ==================================================================== */

#define CTR_VME
#include <ctrdrvr.h>
#include <errno.h>

#include <errno.h>
extern int errno;

extern double round(double x);

extern int timlib_debug;
extern int timlib_delay;
extern int timlib_enable;
extern int timlib_jtag;
extern int timlib_oby1_8;
extern int timlib_oby9_16;
extern int timlib_real_utc;

/* ==================================================================== */
/* Open a Ctr Driver file handel.                                       */

CtrDrvrDevice ctr_device = CtrDrvrDeviceANY;
char *devnames[CtrDrvrDEVICES] = {"ctr", "ctri", "ctrp", "ctrv", "ctre" };

static int ctr = 0; /* This global holds the CTR Driver file handle */

static int CtrOpen() {

char fnm[32];
int  i;

   if (ctr) return ctr;
   for (i = 1; i <= CtrDrvrCLIENT_CONTEXTS; i++) {
      sprintf(fnm,"/dev/%s.%1d",devnames[ctr_device],i);
      if ((ctr = open(fnm,O_RDWR,0)) > 0) return ctr;
   }
   return 0;
}

/* ========= */

static int CtrFdOpen() {

char fnm[32];
int  i, fd;

   for (i = 1; i <= CtrDrvrCLIENT_CONTEXTS; i++) {
      sprintf(fnm,"/dev/%s.%1d",devnames[ctr_device],i);
      if ((fd = open(fnm,O_RDWR,0)) > 0) return fd;
   }
   return 0;
}

/* ==================================================================== */
/* Convert HPTDC ticks to nano seconds.                                 */

static unsigned long CtrHptdcToNano(unsigned long hptdc) {
double fns;
unsigned long ins;

   fns = ((double) hptdc) / 2.56;
   ins = (unsigned long) fns;
   return ins;
}

/* ==================================================================== */
/* Lets you know how many installed modules there are on this host.     */

unsigned long CtrLibGetInstalledModuleCount() {

unsigned long cnt;

   if (ctr == 0) return 0;
   if (ioctl(ctr,CtrDrvrGET_MODULE_COUNT,&cnt) < 0) return 0;
   return cnt;
}

/* ==================================================================== */
/* This routine could have been hidden from the user of the Timing lib, */
/* however, in some circumstances, the initialization can take several  */
/* minutes to complete. Hence I have decided to make an initialization  */
/* routine publicly available, and force users to call it.              */
/* This routine performs the following initialization functions...      */
/*    1) Opens a connection to the driver                               */
/*    2) Checks the Firmware/VHDL version against the latest revision   */
/*       Some EProms/FPGAs may need updating, this takes a while.       */
/*    3) Load all relavent CTIM and PTIM definitions if needed.         */
/* This is the CTR implementation, so device is irrelevant here.        */

TimLibError CtrLibInitialize(TimLibDevice device) { /* Initialize hardware/software */
char cmd[64];
int m, mods;
unsigned long p2c, oby; /* VME P2Connector output byte */

   if ((device == TimLibDevice_ANY)
   ||  (device == TimLibDevice_CTR)) {
      if (!ctr) {
	 if (CtrOpen() == 0) {
	    ctr = 0;
	    return TimLibErrorOPEN;
	 }
      }

      if (timlib_jtag) {
	 sprintf(cmd,"echo \"(Xjtag) (load 1) q\" | /usr/local/bin/ctrtest");
	 fprintf(stdout,"CtrLibInitialize:Execute:%s\n",cmd);
	 system(cmd);
      }
      mods = CtrLibGetInstalledModuleCount();
      for (m=1; m<=mods; m++) {
	 ioctl(ctr,CtrDrvrSET_MODULE,&m);
	 if (timlib_debug)  ioctl(ctr,CtrDrvrSET_SW_DEBUG,   &timlib_debug);
	 if (timlib_delay)  ioctl(ctr,CtrDrvrSET_INPUT_DELAY,&timlib_delay);
	 if (timlib_enable) ioctl(ctr,CtrDrvrENABLE,         &timlib_enable);

	 if (m == 1) p2c = timlib_oby1_8;
	 if (m == 9) p2c = timlib_oby9_16;
	 oby = 0xF & p2c;
	 if (oby) {
	    sprintf(cmd,"echo \"(mo %d) (oby %d) q\" | /usr/local/bin/ctrvtest",m,(int) oby);
	    fprintf(stdout,"CtrLibInitialize:Execute:%s\n",cmd);
	    system(cmd);
	 }
	 p2c = p2c >> 4;

      }
      m = 1;
      ioctl(ctr,CtrDrvrSET_MODULE,&m);

      return TimLibErrorSUCCESS;
   }
   return TimLibErrorINIT;
}

/* ====== */

int CtrLibFdInitialize(TimLibDevice device) { /* Initialize hardware/software */

TimLibError er;

   if (ctr == 0) {
      er = CtrLibInitialize(device);
      if (er != TimLibErrorSUCCESS) return 0;
      return ctr;
   }
   return CtrFdOpen();
}

/* ==================================================================== */
/* Connect to an interrupt. If you are connecting to either a CTIM      */
/* interrupt or to a hardware interrupt, you may need to specify on     */
/* which device the interrupt should be connected. This is achieved by  */
/* the module parameter. If the module is zero, the system will decide  */
/* which device to use, otherwise module contains a value between 1 and */
/* the number of installed timing receiver cards. For PTIM objects the  */
/* module parameter must be set to zero or the real module on which the */
/* PTIM object is implemented. On PTIM objects the module is implicit.  */

static int ctr_connected = 0;

TimLibError CtrLibConnect(TimLibClass   iclss,    /* Class of interrupt */
			  unsigned long equip,    /* Equipment or hardware mask */
			  unsigned long module) { /* For HARD or CTIM classes */

CtrDrvrConnection con;

   if (ctr == 0) return TimLibErrorINIT;

   con.EqpClass = (CtrDrvrConnectionClass) iclss;
   con.EqpNum   = equip;
   con.Module   = module;

   if (con.EqpNum == 0) {
      if (ioctl(ctr,CtrDrvrDISCONNECT,&con) < 0) return TimLibErrorIO;
      ctr_connected = 0;
      return TimLibErrorSUCCESS;
   }
   if (ioctl(ctr,CtrDrvrCONNECT,&con) < 0) return TimLibErrorCONNECT;

   ctr_connected++;

   return TimLibErrorSUCCESS;
}

/* ====== */

TimLibError CtrLibFdConnect(int           fd,       /* File descriptor */
			    TimLibClass   iclss,    /* Class of interrupt */
			    unsigned long equip,    /* Equipment or hardware mask */
			    unsigned long module) { /* For HARD or CTIM classes */

CtrDrvrConnection con;

   if (fd == 0) return TimLibErrorINIT;

   con.EqpClass = (CtrDrvrConnectionClass) iclss;
   con.EqpNum   = equip;
   con.Module   = module;

   if (con.EqpNum == 0) {
      if (ioctl(fd,CtrDrvrDISCONNECT,&con) < 0) return TimLibErrorIO;
      ctr_connected = 0;
      return TimLibErrorSUCCESS;
   }
   if (ioctl(fd,CtrDrvrCONNECT,&con) < 0) return TimLibErrorCONNECT;

   return TimLibErrorSUCCESS;
}

/* =============================================== */

TimLibError CtrLibConnectPayload(unsigned long ctim,        /* The CTIM ID you want to connect to */
				 unsigned long payload,     /* The 16 bit payload in a long */
				 unsigned long module) {    /* The module, or zero means don't care */
CtrDrvrAction act;
CtrDrvrCtimObjects ctimo;
CtrDrvrTrigger *trg;
TimLibError ter;
int i ,j;

   trg = &(act.Trigger);

   if (module) {
      if (ioctl(ctr,CtrDrvrSET_MODULE,&module) < 0)
	 return TimLibErrorMODULE;
   }
   if (ioctl(ctr,CtrDrvrLIST_CTIM_OBJECTS,&ctimo) < 0) return TimLibErrorIO;
   for (i=0; i<ctimo.Size; i++) {
      if (ctimo.Objects[i].EqpNum == ctim) {

	 ter = CtrLibConnect(TimLibClassCTIM,ctim,module);
	 if (ter != TimLibErrorSUCCESS) return ter;

	 for (j=1; j<=CtrDrvrRamTableSIZE; j++) {
	    act.TriggerNumber = j;
	    if (ioctl(ctr,CtrDrvrGET_ACTION,&act) < 0) return TimLibErrorIO;

	    if (act.EqpClass == CtrDrvrConnectionClassCTIM) {
	       if (trg->Ctim == ctim) {
		  trg->Frame.Long = ((ctimo.Objects[i].Frame.Long & 0xFFFF0000)
				  |  (payload & 0x0000FFFF));

		  if (ioctl(ctr,CtrDrvrSET_ACTION,&act) < 0) return TimLibErrorIO;
		  else                                       return TimLibErrorSUCCESS;
	       }
	    }
	    else if (act.EqpClass == CtrDrvrConnectionClassPTIM) continue;
	    else                                                 break;
	 }
	 break;
      }
   }
   return TimLibErrorCTIM;
}

/* ==================================================================== */
/* Disconnect from an interrupt                                         */

TimLibError CtrLibDisConnect(TimLibClass   iclss,    /* Class of interrupt */
			     unsigned long equip,    /* Equipment or hardware mask */
			     unsigned long module) { /* For HARD or CTIM classes */

CtrDrvrConnection con;

   if (ctr == 0) return TimLibErrorINIT;

   con.EqpClass = (CtrDrvrConnectionClass) iclss;
   con.EqpNum   = equip;
   con.Module   = module;

   if (ioctl(ctr,CtrDrvrDISCONNECT,&con) < 0) return TimLibErrorCONNECT;

   if (con.EqpNum == 0)   ctr_connected = 0;
   if (ctr_connected > 0) ctr_connected--;

   return TimLibErrorSUCCESS;
}

/* ==================================================================== */
/* Set queueing On or Off, and the time out value in micro seconds.     */
/* A timeout value of zero means no time out, you wait for ever.        */

TimLibError CtrLibQueue(unsigned long qflag,    /* 0=>Queue, 1=>NoQueue  */
			unsigned long tmout) {  /* 0=>No time outs       */

   if (ctr == 0) return TimLibErrorINIT;

   if (ioctl(ctr,CtrDrvrSET_TIMEOUT,&tmout)    < 0) return TimLibErrorIO;
   if (ioctl(ctr,CtrDrvrSET_QUEUE_FLAG,&qflag) < 0) return TimLibErrorIO;

   return TimLibErrorSUCCESS;
}

/* ====== */

TimLibError CtrLibFdQueue(int           fd,      /* File descriptor       */
			  unsigned long qflag,   /* 0=>Queue, 1=>NoQueue  */
			  unsigned long tmout) { /* 0=>No time outs       */

   if (fd == 0) return TimLibErrorINIT;

   if (ioctl(fd,CtrDrvrSET_TIMEOUT,&tmout)    < 0) return TimLibErrorIO;
   if (ioctl(fd,CtrDrvrSET_QUEUE_FLAG,&qflag) < 0) return TimLibErrorIO;

   return TimLibErrorSUCCESS;
}

/* ==================================================================== */
/* To know if a call to wait will block, this call returns the Queue    */
/* size. If the size iz greater than zero a call to wait will not block */
/* and return without waiting. If the qflag is set to NoQueue, zero is  */
/* allways returned and all calls to wait will block.                   */

unsigned long CtrLibGetQueueSize() {

unsigned long qflag;
unsigned long qsize;

   if (ioctl(ctr,CtrDrvrGET_QUEUE_FLAG,&qflag) < 0) return 0;
   if (qflag) return 0;

   if (ioctl(ctr,CtrDrvrGET_QUEUE_SIZE,&qsize) < 0) return 0;

   return qsize;
}

/* ==================================================================== */
/* Wait for an interrupt. The parameters are all returned from the call */
/* so you can know which interrupt it was that came back. Note, when    */
/* waiting for a hardware interrupt from either CTIM or from a counter, */
/* it is the CTIM or PTIM object that caused the interrupt returned.    */
/* The telegram will have been read already by the high prioity task    */
/* get_tgm_ctr/tg8, be aware of the race condition here, hence payload. */
/* This routine is a blocking call, it waits for interrupt or timeout.  */
/* Any NULL argument  is permitted, and no value will be returned.      */

/* Arguments:                                                           */
/*    iclss:   The class of the interrupt CTIM, PTIM, or hardware       */
/*    equip:   The PTIM, CTIM equipment, or hardware mask               */
/*    plnum:   If class is PTIM this is the PLS line number             */
/*    source:  The hardware source of the interrupt                     */
/*    onzero:  The time of the interrupt                                */
/*    trigger: The arrival time of the event that triggered the action  */
/*    start:   The time the start of the counter occured                */
/*    ctim:    The CTIM equipment number of the triggering event        */
/*    payload: The payload of the triggering event                      */
/*    module:  The module number 1..n of the timing receiver card       */
/*    missed:  The number of missed events since the last wait          */
/*    qsize:   The number of remaining interrupts on the queue          */

TimLibError CtrLibWait(TimLibClass    *iclss,      /* Class of interrupt */
		       unsigned long  *equip,      /* PTIM CTIM or hardware mask */
		       unsigned long  *plnum,      /* Ptim line number 1..n or 0 */
		       TimLibHardware *source,     /* Hardware source of interrupt */
		       TimLibTime     *onzero,     /* Time of interrupt/output */
		       TimLibTime     *trigger,    /* Time of counters load */
		       TimLibTime     *start,      /* Time of counters start */
		       unsigned long  *ctim,       /* CTIM trigger equipment ID */
		       unsigned long  *payload,    /* Payload of trigger event */
		       unsigned long  *module,     /* Module that interrupted */
		       unsigned long  *missed,     /* Number of missed interrupts */
		       unsigned long  *qsize,      /* Remaining interrupts on queue */
		       TgmMachine     *machine) {  /* Corresponding TgmMachine */

static int         cbl = 0;
CtrDrvrReadBuf     rbf;
CtrDrvrPtimBinding ob;
CtrDrvrAction      act;
TgmMachine         mch;

   if (ctr == 0) return TimLibErrorINIT;
   if (ctr_connected == 0) return TimLibErrorWAIT;

   while (1) {
      if (read(ctr,&rbf,sizeof(CtrDrvrReadBuf)) <= 0) return TimLibErrorTIMEOUT;
      if (rbf.Connection.EqpClass == CtrDrvrConnectionClassPTIM) {
	 ioctl(ctr,CtrDrvrSET_MODULE,&rbf.Connection.Module);
	 act.TriggerNumber = rbf.TriggerNumber;
	 if (ioctl(ctr,CtrDrvrGET_ACTION,&act) < 0) return TimLibErrorIO;
	 if ((act.Config.OnZero & CtrDrvrCounterOnZeroOUT) == 0) continue;
      }
      break;
   }
   
   if (cbl == 0) ioctl(ctr,CtrDrvrGET_CABLE_ID,&cbl);
   mch = TgvTgvToTgmMachine(TgvFirstMachineForCableId(cbl));

   if (iclss)   *iclss   = rbf.Connection.EqpClass;
   if (equip)   *equip   = rbf.Connection.EqpNum;
   if (source)  *source  = rbf.InterruptNumber;
   if (module)  *module  = rbf.Connection.Module;
   if (machine) {
      if (*iclss != TimLibClassHARDWARE) *machine = TgvTgvToTgmMachine(TgvGetMachineForMember(rbf.Ctim));
      else                               *machine = mch;
   }
   if (ctim)    *ctim    = rbf.Ctim;

   if (payload) *payload = rbf.Frame.Struct.Value;

   if (plnum) {
      if (rbf.Connection.EqpClass == CtrDrvrConnectionClassPTIM) {
	 ob.EqpNum = rbf.Connection.EqpNum;
	 ioctl(ctr,CtrDrvrGET_PTIM_BINDING,&ob);
	 *plnum  = rbf.TriggerNumber - ob.StartIndex;
      } else *plnum = 0;
   }
   if (missed) ioctl(ctr,CtrDrvrGET_QUEUE_OVERFLOW,missed);
   if (qsize)  ioctl(ctr,CtrDrvrGET_QUEUE_SIZE,qsize);

   if (onzero) {
      onzero->Machine = mch;
      onzero->CTrain  = rbf.OnZeroTime.CTrain;
      onzero->Second  = rbf.OnZeroTime.Time.Second;
      onzero->Nano    = CtrHptdcToNano(rbf.OnZeroTime.Time.TicksHPTDC);
   }

   if (trigger) {
      trigger->Machine = mch;
      trigger->CTrain  = rbf.TriggerTime.CTrain;
      trigger->Second  = rbf.TriggerTime.Time.Second;
      trigger->Nano    = CtrHptdcToNano(rbf.TriggerTime.Time.TicksHPTDC);
   }
   if (start) {
      start->Machine = mch;
      start->CTrain  = rbf.StartTime.CTrain;
      start->Second  = rbf.StartTime.Time.Second;
      start->Nano    = CtrHptdcToNano(rbf.StartTime.Time.TicksHPTDC);
   }
   return TimLibErrorSUCCESS;
}

/* ====== */

TimLibError CtrLibFdWait(int            fd,          /* File descriptor */
			 TimLibClass    *iclss,      /* Class of interrupt */
			 unsigned long  *equip,      /* PTIM CTIM or hardware mask */
			 unsigned long  *plnum,      /* Ptim line number 1..n or 0 */
			 TimLibHardware *source,     /* Hardware source of interrupt */
			 TimLibTime     *onzero,     /* Time of interrupt/output */
			 TimLibTime     *trigger,    /* Time of counters load */
			 TimLibTime     *start,      /* Time of counters start */
			 unsigned long  *ctim,       /* CTIM trigger equipment ID */
			 unsigned long  *payload,    /* Payload of trigger event */
			 unsigned long  *module,     /* Module that interrupted */
			 unsigned long  *missed,     /* Number of missed interrupts */
			 unsigned long  *qsize,      /* Remaining interrupts on queue */
			 TgmMachine     *machine) {  /* Corresponding TgmMachine */

static int         cbl = 0;
CtrDrvrReadBuf     rbf;
CtrDrvrPtimBinding ob;
CtrDrvrAction      act;
TgmMachine         mch;

   if (fd == 0) return TimLibErrorINIT;

   while (1) {
      if (read(fd,&rbf,sizeof(CtrDrvrReadBuf)) <= 0) return TimLibErrorTIMEOUT;
      if (rbf.Connection.EqpClass == CtrDrvrConnectionClassPTIM) {
	 ioctl(fd,CtrDrvrSET_MODULE,&rbf.Connection.Module);
	 act.TriggerNumber = rbf.TriggerNumber;
	 if (ioctl(fd,CtrDrvrGET_ACTION,&act) < 0) return TimLibErrorIO;
	 if ((act.Config.OnZero & CtrDrvrCounterOnZeroOUT) == 0) continue;
      }
      break;
   }
   
   if (cbl == 0) ioctl(fd,CtrDrvrGET_CABLE_ID,&cbl);
   mch = TgvTgvToTgmMachine(TgvFirstMachineForCableId(cbl));

   if (iclss)   *iclss   = rbf.Connection.EqpClass;
   if (equip)   *equip   = rbf.Connection.EqpNum;
   if (source)  *source  = rbf.InterruptNumber;
   if (module)  *module  = rbf.Connection.Module;
   if (machine) {
      if (*iclss != TimLibClassHARDWARE) *machine = TgvTgvToTgmMachine(TgvGetMachineForMember(rbf.Ctim));
      else                               *machine = mch;
   }
   if (ctim)    *ctim    = rbf.Ctim;

   if (payload) *payload = rbf.Frame.Struct.Value;

   if (plnum) {
      if (rbf.Connection.EqpClass == CtrDrvrConnectionClassPTIM) {
	 ob.EqpNum = rbf.Connection.EqpNum;
	 ioctl(fd,CtrDrvrGET_PTIM_BINDING,&ob);
	 *plnum  = rbf.TriggerNumber - ob.StartIndex;
      } else *plnum = 0;
   }
   if (missed) ioctl(fd,CtrDrvrGET_QUEUE_OVERFLOW,missed);
   if (qsize)  ioctl(fd,CtrDrvrGET_QUEUE_SIZE,qsize);

   if (onzero) {
      onzero->Machine = mch;
      onzero->CTrain  = rbf.OnZeroTime.CTrain;
      onzero->Second  = rbf.OnZeroTime.Time.Second;
      onzero->Nano    = CtrHptdcToNano(rbf.OnZeroTime.Time.TicksHPTDC);
   }

   if (trigger) {
      trigger->Machine = mch;
      trigger->CTrain  = rbf.TriggerTime.CTrain;
      trigger->Second  = rbf.TriggerTime.Time.Second;
      trigger->Nano    = CtrHptdcToNano(rbf.TriggerTime.Time.TicksHPTDC);
   }
   if (start) {
      start->Machine = mch;
      start->CTrain  = rbf.StartTime.CTrain;
      start->Second  = rbf.StartTime.Time.Second;
      start->Nano    = CtrHptdcToNano(rbf.StartTime.Time.TicksHPTDC);
   }
   return TimLibErrorSUCCESS;
}

/* ==================================================================== */
/* Set the Ccv of a PTIM equipment. Note neither the counter number nor */
/* the trigger condition can be changed.                                */

TimLibError CtrLibSet(unsigned long ptim,    /* PTIM to write to */
		      unsigned long plnum,   /* Ptim line number 1..n or 0 */
		      unsigned long grnum,   /* Tgm group number or Zero */
		      unsigned long grval,   /* Group value if num not zero */
		      TimLibCcvMask ccvm,    /* Which values to write */
		      TimLibCcv     *ccv) {  /* Current control value */

int                          anum, msk, i, found, module;
CtrDrvrAction                act;
CtrDrvrTrigger              *trg;
CtrDrvrCounterConfiguration *cnf;
CtrDrvrTgmGroup             *grp;
CtrDrvrPtimBinding           ob;
CtrDrvrCounterMaskBuf        cmsb;
TgmGroupDescriptor           desc;
CtrDrvrCtimObjects           ctimo;

   if (ctr == 0) return TimLibErrorINIT;

   ob.EqpNum = ptim;
   if (ioctl(ctr,CtrDrvrGET_PTIM_BINDING,&ob) < 0) return TimLibErrorPTIM;
   anum = ob.StartIndex +1;

   module = ob.ModuleIndex +1;
   ioctl(ctr,CtrDrvrSET_MODULE,&module);

   trg = &(act.Trigger);
   cnf = &(act.Config);
   grp = &(trg->Group);

   act.TriggerNumber = anum;
   if (ioctl(ctr,CtrDrvrGET_ACTION,&act) < 0) return TimLibErrorIO;

   if (plnum) {
      anum += plnum -1;
      act.TriggerNumber = anum;

      if (anum > ob.StartIndex + ob.Size) return TimLibErrorGROUP;

      if (ioctl(ctr,CtrDrvrGET_ACTION,&act) < 0) return TimLibErrorIO;

   } else if (grnum) {
      do {
	 if ((trg->Group.GroupNumber == grnum)
	 &&  (trg->Group.GroupValue  == grval)) break;

	 if (anum++ >= ob.StartIndex + ob.Size) return TimLibErrorGROUP;

	 act.TriggerNumber = anum;
	 if (ioctl(ctr,CtrDrvrGET_ACTION,&act) < 0) return TimLibErrorGROUP;
      } while (1);
   }
   trg->Counter = ob.Counter;

   msk = 1;
   do {
      if (ccvm & msk) {
	 switch ((TimLibCcvMask) msk) {
	    case TimLibCcvMaskENABLE:
	       if (ccv->Enable & TimLibEnableOUT) cnf->OnZero |= CtrDrvrCounterOnZeroOUT;
	       else                               cnf->OnZero &= ~CtrDrvrCounterOnZeroOUT;
	       break;

	    case TimLibCcvMaskSTART:
	       if (ccv->Start >= TimLibSTARTS) return TimLibErrorSTART;
	       cnf->Start = ccv->Start;
	       break;

	    case TimLibCcvMaskMODE:
	       if (ccv->Mode >= TimLibMODES) return TimLibErrorMODE;
	       cnf->Mode = ccv->Mode;
	       break;

	    case TimLibCcvMaskCLOCK:
	       if (ccv->Clock >= TimLibCLOCKS) return TimLibErrorCLOCK;
	       cnf->Clock = ccv->Clock;
	       break;

	    case TimLibCcvMaskPWIDTH:
	       if ((ccv->PulsWidth < 0)
	       ||  (ccv->PulsWidth > CtrDrvrCounterConfigPULSE_WIDTH_MASK))
		  return TimLibErrorPWIDTH;
	       cnf->PulsWidth = ccv->PulsWidth;
	       break;

	    case TimLibCcvMaskDELAY:
	       cnf->Delay = ccv->Delay;
	       break;

	    case TimLibCcvMaskOMASK:
	       cmsb.Counter = ob.Counter;
	       if (ioctl(ctr,CtrDrvrGET_OUT_MASK,&cmsb) < 0) return TimLibErrorIO;
	       cmsb.Mask = ccv->OutputMask;
	       if (ioctl(ctr,CtrDrvrSET_OUT_MASK,&cmsb) < 0) return TimLibErrorIO;
	       break;

	    case TimLibCcvMaskPOLARITY:
	       cmsb.Counter = ob.Counter;
	       if (ioctl(ctr,CtrDrvrGET_OUT_MASK,&cmsb) < 0) return TimLibErrorIO;
	       cmsb.Polarity = ccv->Polarity;
	       if (ioctl(ctr,CtrDrvrSET_OUT_MASK,&cmsb) < 0) return TimLibErrorIO;
	       break;

	    case TimLibCcvMaskCTIM:
	       found = 0;
	       if (ioctl(ctr,CtrDrvrLIST_CTIM_OBJECTS,&ctimo) < 0) return TimLibErrorIO;
	       if (ccv->Ctim == 0) {
		  if (ctimo.Size) {
		     trg->Ctim  = ctimo.Objects[0].EqpNum;
		     trg->Frame = ctimo.Objects[0].Frame;
		  } else {
		     trg->Ctim       = 100;
		     trg->Frame.Long = 0x34fe0000;
		  }
		  break;
	       }
	       for (i=0; i<ctimo.Size; i++) {
		  if (ctimo.Objects[i].EqpNum == ccv->Ctim) {
		     trg->Ctim  = ccv->Ctim;
		     trg->Frame = ctimo.Objects[i].Frame;
		     found = 1;
		     break;
		  }
	       }
	       if (!found) return TimLibErrorCTIM;
	       break;

	    case TimLibCcvMaskPAYLOAD:
	       trg->Frame.Struct.Value &= ~0xFFFF;
	       trg->Frame.Struct.Value |= (0xFFFF & ccv->Payload);
	       break;

	    case TimLibCcvMaskMACHINE:
	       trg->Machine = TgvTgmToTgvMachine(ccv->Machine);
	       break;

	    case TimLibCcvMaskGRNUM:
	       grp->GroupNumber = ccv->GrNum;
	       trg->TriggerCondition = CtrDrvrTriggerConditionNO_CHECK;
	       if (ccv->GrNum) {
		  if (TgmGetGroupDescriptor(TgvTgvToTgmMachine(trg->Machine),ccv->GrNum,&desc) != TgmSUCCESS)
		     return TimLibErrorGROUP;
		  if (desc.Type == TgmEXCLUSIVE)
		     trg->TriggerCondition = CtrDrvrTriggerConditionEQUALITY;
		  else if (desc.Type == TgmBIT_PATTERN)
		     trg->TriggerCondition = CtrDrvrTriggerConditionAND;
	       }
	       break;

	    case TimLibCcvMaskGRVAL:
	       grp->GroupValue = ccv->GrVal;
	    break;

	    default: break;
	 }
      }
      msk <<= 1;
   } while (msk & TimLibCcvMaskBITS);

   act.TriggerNumber = anum;
   if (ioctl(ctr,CtrDrvrSET_ACTION,&act) < 0) return TimLibErrorIO;

   return TimLibErrorSUCCESS;
}

/* ==================================================================== */
/* Get the Ccv of a PTIM equipment.                                     */

TimLibError CtrLibGet(unsigned long ptim,
		      unsigned long plnum,   /* Ptim line number 1..n or 0 */
		      unsigned long grnum,
		      unsigned long grval,
		      TimLibCcvMask *ccvm,  /* Valid fields in ccv */
		      TimLibCcv     *ccv) {

int                          anum, module;
CtrDrvrAction                act;
CtrDrvrTrigger              *trg;
CtrDrvrCounterConfiguration *cnf;
CtrDrvrTgmGroup             *grp;
CtrDrvrPtimBinding           ob;
CtrDrvrCounterMaskBuf        cmsb;

   if (ctr == 0) return TimLibErrorINIT;

   ob.EqpNum = ptim;
   if (ioctl(ctr,CtrDrvrGET_PTIM_BINDING,&ob) < 0) return TimLibErrorPTIM;
   anum = ob.StartIndex +1;

   module = ob.ModuleIndex +1;
   ioctl(ctr,CtrDrvrSET_MODULE,&module);

   act.TriggerNumber = anum;
   trg = &(act.Trigger);
   cnf = &(act.Config);
   grp = &(trg->Group);

   if (ioctl(ctr,CtrDrvrGET_ACTION,&act) < 0) return TimLibErrorIO;

   /* If the Tgm group number is not zero, search for the PTIM action */

   if (plnum) {
      anum += plnum -1;
      act.TriggerNumber = anum;

      if (anum > ob.StartIndex + ob.Size) return TimLibErrorGROUP;

      if (ioctl(ctr,CtrDrvrGET_ACTION,&act) < 0) return TimLibErrorIO;

   } else if (grnum) {
      do {
	 if ((trg->Group.GroupNumber == grnum)
	 &&  (trg->Group.GroupValue  == grval)) break;

	 if (anum++ >= ob.StartIndex + ob.Size) return TimLibErrorGROUP;

	 act.TriggerNumber = anum;
	 if (ioctl(ctr,CtrDrvrGET_ACTION,&act) < 0) return TimLibErrorIO;
      } while (1);
   }

   ccv->Enable = TimLibEnableNOOUT;
   if (cnf->OnZero & CtrDrvrCounterOnZeroOUT) ccv->Enable |= TimLibEnableOUT;
   if (cnf->OnZero & CtrDrvrCounterOnZeroBUS) ccv->Enable |= TimLibEnableBUS;

   *ccvm          = TimLibCcvMaskBITS;
   ccv->Start     = cnf->Start;
   ccv->Mode      = cnf->Mode;
   ccv->Clock     = cnf->Clock;
   ccv->PulsWidth = cnf->PulsWidth;
   ccv->Delay     = cnf->Delay;
   ccv->Ctim      = trg->Ctim;
   ccv->Payload   = trg->Frame.Struct.Value & 0xFFFF;
   ccv->Machine   = TgvTgvToTgmMachine(trg->Machine);
   if (trg->TriggerCondition == CtrDrvrTriggerConditionNO_CHECK) ccv->GrNum = 0;
   else                                                          ccv->GrNum = grp->GroupNumber;
   ccv->GrVal     = grp->GroupValue;

   cmsb.Counter = ob.Counter;
   if (ioctl(ctr,CtrDrvrGET_OUT_MASK,&cmsb) < 0) return TimLibErrorIO;

   ccv->OutputMask = cmsb.Mask;
   ccv->Polarity   = cmsb.Polarity;

   return TimLibErrorSUCCESS;
}

/* ==================================================================== */
/* By writing to the driver this call simulates an interrupt for the    */
/* connected clients. Also it can be used as a way of synchronizing     */
/* processes, this is especially important in Linux systems where the   */
/* schedular is not preemptive.                                         */

/* Arguments:                                                                     */
/*    iclss:   Class of interrupt to simulate, PTIM, CTIM or Hardware             */
/*    equip:   Equipment number for PTIM or CTIM, hardware mask for Hardware      */
/*    module:  When class is CTIM or Hardware, the module number is used          */
/*    machine: Telegram ID is used for PTIM interrupts if grnum is not zero       */
/*    grnum:   If zero, no telegram checking, else the PTIM triggers group number */
/*    grval:   The telegram group value for the PTIM trigger                      */

TimLibError CtrLibSimulate(TimLibClass   iclss,
			     unsigned long equip,
			     unsigned long module,
			     TgmMachine    machine,
			     unsigned long grnum,
			     unsigned long grval) {

int                          cc, anum;
CtrDrvrPtimBinding           ob;
CtrDrvrWriteBuf              wbf;
CtrDrvrAction                act;
CtrDrvrTrigger              *trg;
CtrDrvrCounterConfiguration *cnf;
CtrDrvrTgmGroup             *grp;

   if (ctr == 0) return TimLibErrorINIT;

   trg = &(act.Trigger);
   cnf = &(act.Config);
   grp = &(trg->Group);

   switch (iclss) {

      case CtrDrvrConnectionClassHARD:
      case CtrDrvrConnectionClassCTIM:
	 wbf.TriggerNumber       = 0;
	 wbf.Connection.Module   = module;
	 wbf.Connection.EqpNum   = equip;
	 wbf.Connection.EqpClass = iclss;
	 wbf.Payload             = grval; /* CTIM payload */
	 cc = write(ctr,&wbf,sizeof(CtrDrvrWriteBuf));
	 if (cc > 0) return TimLibErrorSUCCESS;
      break;

      case CtrDrvrConnectionClassPTIM:
	 ob.EqpNum = equip;
	 if (ioctl(ctr,CtrDrvrGET_PTIM_BINDING,&ob) < 0) return TimLibErrorPTIM;

	 if (grnum) anum = grval + ob.StartIndex -1; else anum = 0;

	 wbf.TriggerNumber       = anum;
	 wbf.Connection.Module   = ob.ModuleIndex + 1;
	 wbf.Connection.EqpNum   = ob.EqpNum;
	 wbf.Connection.EqpClass = CtrDrvrConnectionClassPTIM;

	 cc = write(ctr,&wbf,sizeof(CtrDrvrWriteBuf));
	 if (cc > 0) return TimLibErrorSUCCESS;
      break;

      default: break;
   }
   return TimLibErrorIO;
}

/* ==================================================================== */
/* Set a counter under full remote control (IE under DSC tasks control) */
/* This feature permits you to do what you like with counters even if   */
/* there is no timing cable attached. With this you can drive stepper   */
/* motors, wire scanners or whatever. No PTIM or CTIM is involved, the  */
/* configuration is loaded directly by the application. Note that when  */
/* the argument remflg is set to 1, the counter can not be written to   */
/* by incomming triggers so all PTIM objects using the counter stop     */
/* overwriting the counter configuration and are effectivley disabled.  */
/* Setting the remflg 0 permits PTIM triggers to write to the counter   */
/* configuration, the write block is removed. Also note that in some    */
/* cases it is useful to perform remote actions, such as remoteSTOP,    */
/* even if the remflg is set to zero. The remflg simply blocks PTIM     */
/* overwrites, the counter configuration can still be accessed !        */

TimLibError CtrLibRemoteControl(unsigned long remflg, /* 0 = Normal, 1 = Remote */
				unsigned long module, /* The module or zero */
				unsigned long cntr,   /* 1..8 counter number */
				TimLibRemote  rcmd,   /* Command */
				TimLibCcvMask ccvm,   /* Fields to be set */
				TimLibCcv     *ccv) { /* Value to load in counter */

unsigned long                  msk;
CtrDrvrCounterConfiguration    *cnf;
CtrDrvrCounterConfigurationBuf cnfb;
CtrdrvrRemoteCommandBuf        crmb;
CtrDrvrCounterMaskBuf          cmbf;

   if (ctr == 0) return TimLibErrorINIT;

   ioctl(ctr,CtrDrvrSET_MODULE,&module);

   crmb.Remote = remflg;
   crmb.Counter = cntr;

   if (ioctl(ctr,CtrDrvrSET_REMOTE,&crmb) < 0) return TimLibErrorIO;

   msk = ccvm & ~TimLibCcvMaskOMASK;
   if (ccvm & TimLibCcvMaskBITS) {
      cnfb.Counter = cntr;
      if (ioctl(ctr,CtrDrvrGET_CONFIG,&cnfb) < 0) return TimLibErrorIO;
      cnf = &cnfb.Config;
      if (ccvm & TimLibCcvMaskSTART ) cnf->Start     = ccv->Start;
      if (ccvm & TimLibCcvMaskMODE  ) cnf->Mode      = ccv->Mode;
      if (ccvm & TimLibCcvMaskCLOCK ) cnf->Clock     = ccv->Clock;
      if (ccvm & TimLibCcvMaskDELAY ) cnf->Delay     = ccv->Delay;
      if (ccvm & TimLibCcvMaskPWIDTH) cnf->PulsWidth = ccv->PulsWidth;
      if (ccvm & TimLibCcvMaskENABLE) {
	 cnf->OnZero = 0;
	 if (ccv->Enable & TimLibEnableOUT) cnf->OnZero |= CtrDrvrCounterOnZeroOUT;
	 if (ccv->Enable & TimLibEnableBUS) cnf->OnZero |= CtrDrvrCounterOnZeroBUS;
      }

      if (ioctl(ctr,CtrDrvrSET_CONFIG,&cnfb) < 0) return TimLibErrorIO;
   }

   if (ccvm & (TimLibCcvMaskPOLARITY | TimLibCcvMaskOMASK)) {
      cmbf.Counter = cntr;
      if (ioctl(ctr,CtrDrvrGET_OUT_MASK,&cmbf) < 0) return TimLibErrorIO;
      if (ccvm & TimLibCcvMaskPOLARITY) cmbf.Polarity = ccv->Polarity;
      if (ccvm & TimLibCcvMaskOMASK)    cmbf.Mask     = ccv->OutputMask;
      if (ioctl(ctr,CtrDrvrSET_OUT_MASK,&cmbf) < 0) return TimLibErrorIO;
   }

   if (rcmd & TimLibRemoteBITS) {
      crmb.Remote = rcmd;
      if (ioctl(ctr,CtrDrvrREMOTE,&crmb) < 0) return TimLibErrorIO;
   }
   return TimLibErrorSUCCESS;
}

/* ==================================================================== */
/* Get a counters remote configuration                                  */

TimLibError CtrLibGetRemote(unsigned long module,
			       unsigned long cntr,
			       unsigned long *remflg,
			       TimLibCcvMask *ccvm,
			       TimLibCcv     *ccv) {

CtrDrvrCounterConfiguration    *cnf;
CtrDrvrCounterConfigurationBuf cnfb;
CtrdrvrRemoteCommandBuf        crmb;
CtrDrvrCounterMaskBuf          cmbf;

   if (ctr == 0) return TimLibErrorINIT;

   ioctl(ctr,CtrDrvrSET_MODULE,&module);

   crmb.Counter = cntr;

   if (ioctl(ctr,CtrDrvrGET_REMOTE,&crmb) < 0) return TimLibErrorIO;
   if (remflg) *remflg = crmb.Remote;
   if (crmb.Remote == 0) return TimLibErrorSUCCESS;

   if ((ccvm) && (ccv)) {
      cnfb.Counter = cntr;
      if (ioctl(ctr,CtrDrvrGET_CONFIG,&cnfb) < 0) return TimLibErrorIO;
      cnf = &cnfb.Config;

      *ccvm = 0;
      *ccvm |= TimLibCcvMaskSTART;  ccv->Start     = cnf->Start;
      *ccvm |= TimLibCcvMaskMODE;   ccv->Mode      = cnf->Mode;
      *ccvm |= TimLibCcvMaskCLOCK;  ccv->Clock     = cnf->Clock;
      *ccvm |= TimLibCcvMaskDELAY;  ccv->Delay     = cnf->Delay;
      *ccvm |= TimLibCcvMaskPWIDTH; ccv->PulsWidth = cnf->PulsWidth;

      *ccvm |= TimLibCcvMaskENABLE; ccv->Enable = TimLibEnableNOOUT;
      if (cnf->OnZero & CtrDrvrCounterOnZeroOUT) ccv->Enable |= TimLibEnableOUT;
      if (cnf->OnZero & CtrDrvrCounterOnZeroBUS) ccv->Enable |= TimLibEnableBUS;

      cmbf.Counter = cntr;
      if (ioctl(ctr,CtrDrvrGET_OUT_MASK,&cmbf) < 0) return TimLibErrorIO;
      *ccvm |= TimLibCcvMaskPOLARITY;
      ccv->Polarity = cmbf.Polarity;

      *ccvm |= TimLibCcvMaskOMASK;
      ccv->OutputMask = cmbf.Mask;

   }
   return TimLibErrorSUCCESS;
}

/* ==================================================================== */
/* Read the instantaneous value of the time in UTC. The module parameter*/
/* can be set to zero in which case the system decideds which module to */
/* read the time from, otherwise it can be set to a value between 1 and */
/* the number of installed modules.                                     */

TimLibError CtrLibGetTime(unsigned long module, /* Module number to read from */
			   TimLibTime    *utc) { /* Returned time value */


unsigned long cbl;
CtrDrvrCTime  ct;
CtrDrvrTime   *t;

   if (ctr == 0) return TimLibErrorINIT;

   t = &ct.Time;

   if (module) {
      if (ioctl(ctr,CtrDrvrSET_MODULE,&module)) return TimLibErrorMODULE;
   }
   if (ioctl(ctr,CtrDrvrGET_UTC,&ct) < 0) return TimLibErrorIO;

   ioctl(ctr,CtrDrvrGET_CABLE_ID,&cbl);

   utc->Machine = TgvTgvToTgmMachine(TgvFirstMachineForCableId(cbl));
   utc->CTrain  = ct.CTrain;
   utc->Second  = t->Second;
   utc->Nano    = CtrHptdcToNano(t->TicksHPTDC);

   return TimLibErrorSUCCESS;
}

/* ==================================================================== */
/* Read a machines telegram from a timing receiver. The module can be   */
/* either zero, in which case the system decides which device to use,   */
/* or it can be explicitly set between 1 and the number of installed    */
/* modules. The telegram object returned has an opaque structure and    */
/* can only be decoded through the Tgm library routine .....            */

/* unsigned long grval = TgmGetGroupValueFromTelegram(unsigned long grnum,     */
/*                                                    TgmTelegram   *telegram) */

/* WARNING: The only task that should call this routine will be, get_tgm_lib,  */
/* all other, LOWER PRIORITY tasks must NEVER call this routine, instead they  */
/* should call the telegram library directly like this ...                     */

/* TgmTelegram telegram;                                                       */
/*                                                                             */
/* if (TgmGetTelegram(machine, index, offset, &telegram) == TgmSUCCESS) { ...  */
/*                                                                             */
/* For more information on this function see the Tgm library man pages.        */

TimLibError CtrLibGetTelegram(unsigned long module,
			      TgmMachine    machine,
			      TgmPTelegram   *telegram) {

int            i;
CtrDrvrTgmBuf  tgmb;

   if (ctr == 0) return TimLibErrorINIT;

   if (module) {
      if (ioctl(ctr,CtrDrvrSET_MODULE,&module)) return TimLibErrorMODULE;
   }
   tgmb.Machine = TgvTgmToTgvMachine(machine);
   if (ioctl(ctr,CtrDrvrREAD_TELEGRAM,&tgmb) < 0) return TimLibErrorIO;
   telegram->Size = TgmLastGroupNumber(machine);
   telegram->Machine = machine;
   for (i=0; i<telegram->Size; i++) {
      TgmSetGroupValueInTelegram(i+1,(long) tgmb.Telegram[i], (TgmTelegram *) telegram);
   }
   return TimLibErrorSUCCESS;
}

/* ==================================================================== */
/* Get the description of a given PTIM equipment. The dimension returns */
/* the PPM dimension, counter and module are obvious.                   */

TimLibError CtrLibGetPtimObject(unsigned long ptim, /* PTIM equipment number */
				 unsigned long *module,
				 unsigned long *counter,
				 unsigned long *dimension) {

CtrDrvrPtimBinding ob;

   if (ctr == 0) return TimLibErrorINIT;

   ob.EqpNum = ptim;
   if (ioctl(ctr,CtrDrvrGET_PTIM_BINDING,&ob) < 0) return TimLibErrorPTIM;

   if (module) *module = ob.ModuleIndex +1;
   if (counter) *counter = ob.Counter;
   if (dimension) *dimension = ob.Size;

   return TimLibErrorSUCCESS;
}

/* ==================================================================== */
/* Get the event code corresponding to a given CTIM equipment number.   */

TimLibError CtrLibGetCtimObject(unsigned long ctim, /* CTIM equipment number */
				 unsigned long *eventcode) {

int i;
CtrDrvrCtimObjects ctimo;

   if (ctr == 0) return TimLibErrorINIT;

   if (ioctl(ctr,CtrDrvrLIST_CTIM_OBJECTS,&ctimo) < 0) return TimLibErrorCTIM;
   for (i=0; i<ctimo.Size; i++) {
      if (ctimo.Objects[i].EqpNum == ctim) {
	 *eventcode = ctimo.Objects[i].Frame.Long;
	 return TimLibErrorSUCCESS;
      }
   }
   return TimLibErrorCTIM;
}

/* ==================================================================== */
/* In some cases when running a GUI under Linux, say, a file handle to  */
/* put in a "select" is needed so that one can wait on multiple file    */
/* handles simultaneously. This routine returns such a handle suitable  */
/* to check for waiting interrupts. Do not read directly from it, but   */
/* call the wait routine. The queue flag must be on for this to work !! */

TimLibError CtrLibGetHandle(int *fd) {

unsigned long qflag;

   if (ctr == 0) return TimLibErrorINIT;
   if (ioctl(ctr,CtrDrvrGET_QUEUE_FLAG,&qflag) < 0) return TimLibErrorIO;
   if (qflag == 1) return TimLibErrorQFLAG;
   *fd = ctr;
   return TimLibErrorSUCCESS;
}

/* ==================================================================== */
/* Create a new PTIM object, the CCV settings will be defaulted.        */


TimLibError CtrLibCreatePtimObject(unsigned long ptimeqp, /* PTIM equipment number */
				   unsigned long module,
				   unsigned long counter,
				   unsigned long dimension) {
int cc;
CtrDrvrPtimBinding ptim;

   if (ctr == 0) return TimLibErrorINIT;

   ptim.EqpNum = ptimeqp;
   ptim.ModuleIndex = module -1;
   ptim.Counter = counter;
   ptim.Size = dimension;
   ptim.StartIndex = 0;

   cc = ioctl(ctr,CtrDrvrCREATE_PTIM_OBJECT,&ptim);
   if (errno == EBUSY)  return TimLibErrorEXISTS;
   if (errno == ENOMEM) return TimLibErrorNOMEM;
   if (cc < 0) return TimLibErrorIO;

   return TimLibErrorSUCCESS;
}

/* ==================================================================== */
/* Create a new CTIM object. If a payload is to be used for this event  */
/* be sure to set the low 16-Bits to 0xFFFF                             */

TimLibError CtrLibCreateCtimObject(unsigned long ctimeqp, /* CTIM equipment number */
				   unsigned long eventcode) {

int cc;
CtrDrvrCtimBinding ctim;

   if (ctr == 0) return TimLibErrorINIT;

   ctim.EqpNum = ctimeqp;
   ctim.Frame.Long = eventcode;

   cc = ioctl(ctr,CtrDrvrCREATE_CTIM_OBJECT,&ctim);
   if (cc == EBUSY)  return TimLibErrorEXISTS;
   if (cc == ENOMEM) return TimLibErrorNOMEM;
   if (cc < 0) return TimLibErrorIO;

   return TimLibErrorSUCCESS;
}

/* ==================================================================== */
/* Get the cable identifier to which a given module is attached so that */
/* the correct module can be used to read telegrams. This function will */
/* be used by the program get_tgm_tim only; it is of no interest to the */
/* majority of clients because calls to ReadTelegram are diverted.      */

TimLibError CtrLibGetCableId(unsigned long module,   /* The given module */
			     unsigned long *cable) { /* The cable ID */

   if (ctr == 0) return TimLibErrorINIT;
   if (ioctl(ctr,CtrDrvrSET_MODULE,&module)) return TimLibErrorMODULE;
   if (ioctl(ctr,CtrDrvrGET_CABLE_ID,cable)) return TimLibErrorIO;
   return TimLibErrorSUCCESS;
}

/* ==================================================================== */
/* Set cable identifier. This is needed to handle CTR boards receiving  */
/* events from other event generators such as the SMP module that sends */
/* beam energy, intensity etc as an event stream. The SMP dose not send */
/* Cable ID events, so we set the module cable with this function.      */
/* This routine is hidden and can not be called accross TimLib, it must */
/* be explicitly declared. Setting the ID to zero causes the module to  */
/* return its true cable ID register, any other value over rides it.    */

TimLibError CtrLibSetCableId(unsigned long module,  /* The given module */
			     unsigned long cable) { /* The given CablID */

   if (ctr == 0) return TimLibErrorINIT;
   if (ioctl(ctr,CtrDrvrSET_MODULE,&module))  return TimLibErrorMODULE;
   if (ioctl(ctr,CtrDrvrSET_CABLE_ID,&cable)) return TimLibErrorIO;
   return TimLibErrorSUCCESS;
}

/* ==================================================================== */
/* Get the status of a module and its device type.                      */

TimLibStatus CtrLibGetStatus(unsigned long module, TimLibDevice *dev) {

TimLibStatus  tstat;
CtrDrvrStatus cstat;

   if (dev) *dev = TimLibDevice_CTR;

   if (ioctl(ctr,CtrDrvrSET_MODULE,&module)) return TimLibErrorIO;
   if (ioctl(ctr,CtrDrvrGET_STATUS,&cstat))  return TimLibErrorIO;

   tstat = 0;
   if (cstat & CtrDrvrStatusGMT_OK)       tstat |= TimLibStatusGMT_OK;
   if (cstat & CtrDrvrStatusPLL_OK)       tstat |= TimLibStatusPLL_OK;
   if (cstat & CtrDrvrStatusSELF_TEST_OK) tstat |= TimLibStatusSELF_OK;
   if (cstat & CtrDrvrStatusENABLED)      tstat |= TimLibStatusENABLED;

// if ((cstat & CtrDrvrStatusNO_BUS_ERROR)
// &&  (cstat & CtrDrvrStatusNO_LOST_INTERRUPTS)) tstat |= TimLibStatusBUS_OK;

   if (cstat & CtrDrvrStatusNO_BUS_ERROR) tstat |= TimLibStatusBUS_OK;

   return tstat;
}

/* ==================================================================== */
/* Get the list of all defined PTIM objects                             */

TimLibError CtrLibGetAllPtimObjects(unsigned long *ptimlist,  /* List of ptim equipments */
				    unsigned long *psize,     /* Number of ptims in list */
				    unsigned long size) {     /* Max size of list */

int i;
CtrDrvrPtimObjects ptimo;

   bzero((void *) &ptimo, sizeof(CtrDrvrPtimObjects));
   if (psize) *psize = 0;

   if (ioctl(ctr,CtrDrvrLIST_PTIM_OBJECTS,&ptimo) < 0) return TimLibErrorIO;

   for (i=0; i<ptimo.Size; i++) {

      if (i>=size) break;

      if (ptimlist) ptimlist[i] = ptimo.Objects[i].EqpNum;
      if (psize)    *psize = i +1;
   }

   return TimLibErrorSUCCESS;
}

/* ==================================================================== */
/* Get the list of all defined CTIM objects                             */

TimLibError CtrLibGetAllCtimObjects(unsigned long *ctimlist,  /* List of ctim equipments */
				    unsigned long *csize,     /* Number of ctims in list */
				    unsigned long size) {     /* Max size of list */

int i;
CtrDrvrCtimObjects ctimo;

   bzero((void *) &ctimo, sizeof(CtrDrvrCtimObjects));
   if (csize) *csize = 0;

   if (ioctl(ctr,CtrDrvrLIST_CTIM_OBJECTS,&ctimo) < 0) return TimLibErrorIO;

   for (i=0; i<ctimo.Size; i++) {

      if (i>=size) break;

      if (ctimlist) ctimlist[i] = ctimo.Objects[i].EqpNum;
      if (csize)    *csize = i +1;
   }

   return TimLibErrorSUCCESS;
}

/* ==================================================================== */
/* Get the CTR input status                                             */

TimLibError CtrLibGetIoStatus(unsigned long module,
			      TimLibLemo *input) {

unsigned long iostat;

   if (ctr == 0) return TimLibErrorINIT;
   if (input == NULL) return TimLibErrorNOMEM;

   if (ioctl(ctr,CtrDrvrSET_MODULE,&module)) return TimLibErrorIO;

   if (ioctl(ctr,CtrDrvrGET_IO_STATUS,&iostat) < 0) return TimLibErrorIO;

   *input = 0;

   if (iostat & CtrDrvrIoStatusCTRXI) {
      if (iostat & CtrDrvrIoStatusO1) *input |= TimLibLemoOUT_1;
      if (iostat & CtrDrvrIoStatusO2) *input |= TimLibLemoOUT_2;
      if (iostat & CtrDrvrIoStatusO3) *input |= TimLibLemoOUT_3;
      if (iostat & CtrDrvrIoStatusO4) *input |= TimLibLemoOUT_4;
      if (iostat & CtrDrvrIoStatusO5) *input |= TimLibLemoOUT_5;
      if (iostat & CtrDrvrIoStatusO6) *input |= TimLibLemoOUT_6;
      if (iostat & CtrDrvrIoStatusO7) *input |= TimLibLemoOUT_7;
      if (iostat & CtrDrvrIoStatusO8) *input |= TimLibLemoOUT_8;
      if (iostat & CtrDrvrIoStatusS1) *input |= TimLibLemoXST_1;
      if (iostat & CtrDrvrIoStatusS2) *input |= TimLibLemoXST_2;
      if (iostat & CtrDrvrIoStatusX1) *input |= TimLibLemoXCL_1;
      if (iostat & CtrDrvrIoStatusX2) *input |= TimLibLemoXCL_2;
      return TimLibErrorSUCCESS;
   }
   return TimLibErrorNOT_IMP;
}

/* ==================================================================== */
/* Set the outputs by changing the polarity                             */

TimLibError CtrLibSetOutputs(unsigned long module,
			     TimLibLemo output,
			     TimLibLemo mask) {

TimLibLemo input;
TimLibError err;
CtrDrvrCounterMaskBuf cmsb;
unsigned long msk, cntr;

   if (ctr == 0) return TimLibErrorINIT;

   if (ioctl(ctr,CtrDrvrSET_MODULE,&module)) return TimLibErrorIO;

   err = CtrLibGetIoStatus(module,&input);
   if (err != TimLibErrorSUCCESS) return err;

   cntr = 0;

   for (msk = TimLibLemoOUT_1; msk <= TimLibLemoOUT_8; msk <<= 1) {
      cntr ++;
      if (mask & msk) {

	 cmsb.Counter = cntr;
	 if (ioctl(ctr,CtrDrvrGET_OUT_MASK,&cmsb) < 0) return TimLibErrorIO;

	 if (msk & output) cmsb.Polarity = CtrDrvrPolarityTTL_BAR;
	 else              cmsb.Polarity = CtrDrvrPolarityTTL;

	 if (ioctl(ctr,CtrDrvrSET_OUT_MASK,&cmsb) < 0) return TimLibErrorIO;
      }
   }

   return TimLibErrorSUCCESS;
}

/* ==================================================================== */
/* Get VHDL/Firmware version of all modules, and the correct version.   */

TimLibError CtrLibGetModuleVersion(TimLibModuleVersion *tver) {

CtrDrvrVersion cver;
CtrDrvrHardwareType ht;
char *cp, *ep, txt[128];
unsigned long cnt, m;
FILE *fver;

   if (ctr == 0)     return TimLibErrorINIT;
   if (tver == NULL) return TimLibErrorNOMEM;

   bzero((void *) tver, sizeof(TimLibModuleVersion));

   m = 1;
   if (ioctl(ctr,CtrDrvrSET_MODULE, &m)    < 0) return TimLibErrorIO;
   if (ioctl(ctr,CtrDrvrGET_VERSION,&cver) < 0) return TimLibErrorIO;

   tver->DrvVer    = cver.DrvrVersion;
   tver->ModVer[0] = cver.VhdlVersion;

   if      (cver.HardwareType == CtrDrvrHardwareTypeCTRP) tver->ModTyp = TimLibModuleTypeCTRP;
   else if (cver.HardwareType == CtrDrvrHardwareTypeCTRI) tver->ModTyp = TimLibModuleTypeCTRI;
   else if (cver.HardwareType == CtrDrvrHardwareTypeCTRV) tver->ModTyp = TimLibModuleTypeCTRV;
   else                                                   tver->ModTyp = TimLibModuleTypeNONE;

   fver = fopen("/usr/local/drivers/ctr/Vhdl.versions","r");
   if (fver) {
      for (ht=CtrDrvrHardwareTypeNONE; ht<CtrDrvrHardwareTYPES; ht++) {
	 if (fgets(txt,128,fver) != NULL) {
	    if (ht == cver.HardwareType) {
	       cp = ep = txt;
	       tver->CorVer = strtoul(cp,&ep,10);
	       break;
	    }
	 }
      }
      fclose(fver);
   }

   if (ioctl(ctr,CtrDrvrGET_MODULE_COUNT,&cnt) < 0) return TimLibErrorIO;
   for (m=2; m<=cnt; m++) {
      if (ioctl(ctr,CtrDrvrSET_MODULE, &m)    < 0) return TimLibErrorIO;
      if (ioctl(ctr,CtrDrvrGET_VERSION,&cver) < 0) return TimLibErrorIO;
      tver->ModVer[m-1] = cver.VhdlVersion;
   }
   return TimLibErrorSUCCESS;
}

/* ==================================================================== */
/* Convert time to string                                               */

static char *TmToSt(CtrDrvrTime *t) {

static char tbuf[32];

char tmp[128];
char *yr, *ti, *md, *mn, *dy;

    bzero((void *) tbuf, 32);
    bzero((void *) tmp,  32);

    if (t->Second) {

	ctime_r(&t->Second,tmp); /* Day Mon DD HH:MM:SS YYYY\n\0 */

        tmp[3] = 0;
        dy = &(tmp[0]);
        tmp[7] = 0;
        mn = &(tmp[4]);
        tmp[10] = 0;
        md = &(tmp[8]);
        if (md[0] == ' ')
            md[0] = '0';
        tmp[19] = 0;
        ti = &(tmp[11]);
        tmp[24] = 0;
        yr = &(tmp[20]);

	sprintf (tbuf, "%s-%s/%s/%s %s"  , dy, md, mn, yr, ti);

    } else {
	sprintf (tbuf, "--- Zero ---");
    }
    return (tbuf);
}

/* ==================================================================== */
/* My strcat with boundary check                                        */

#define RESLN 1024
static char res[RESLN];

int mystrcat(char *cp) {
int sz;

   sz = strlen(res) + strlen(cp);
   if (sz < RESLN) {
      strcat(res,cp);
      return 1;
   }

   sprintf(res,"Result string too big:Required:%d Available:%d\n",sz,RESLN);
   return 0;
}

/* ==================================================================== */
/* Return CTR specific status string                                    */

char *CtrLibGetSpecificInfo(unsigned long module) { /* The given module */

#define TMPLN 512

CtrDrvrBoardId brid;
CtrDrvrReceptionErrors rers;
CtrDrvrTime t;
TimLibModuleVersion tver;
CtrDrvrPll plb;
float aspn, tempr;
double ph, er;
char tmp[TMPLN], txd[32];
unsigned long stat;
CtrDrvrModuleStats mstat;

   if (ctr == 0) return NULL;

   if (ioctl(ctr,CtrDrvrSET_MODULE, &module) < 0) return NULL;

   bzero((void *) tmp, TMPLN);
   bzero((void *) res, RESLN);

   if (ioctl(ctr,CtrDrvrGET_PLL,&plb) >= 0) {
      if (ioctl(ctr,CtrDrvrGET_PLL_ASYNC_PERIOD,&aspn) >= 0) {


	 ph = aspn * ((double) (int) plb.Phase / (double) (int) plb.NumAverage);
	 er = aspn * ((double) (int) plb.Error / (double) (int) plb.NumAverage);

	 sprintf(tmp,"\nPLL Parameters\n"
		    "PllError:0x%08x %d\n"
		    "Integrator:0x%08x %d\n"
		    "Dac:0x%08x %d\n"
		    "LastItLen:0x%08x %d\n"
		    "KI:0x%08x %d\n"
		    "KP:0x%08x %d\n"
		    "NumAverage:0x%08x %d\n"
		    "Phase:0x%08x %d\n"
		    "AsPrdNs:%f (ns)\n"
		    "Error*Period/Naverage:%fns\n"
		    "Phase*Period/Naverage:%fns\n"
		    ,(int) plb.Error     ,(int) plb.Error
		    ,(int) plb.Integrator,(int) plb.Integrator
		    ,(int) plb.Dac       ,(int) plb.Dac
		    ,(int) plb.LastItLen ,(int) plb.LastItLen
		    ,(int) plb.KI        ,(int) plb.KI
		    ,(int) plb.KP        ,(int) plb.KP
		    ,(int) plb.NumAverage,(int) plb.NumAverage
		    ,(int) plb.Phase     ,(int) plb.Phase
		    ,aspn
		    ,er
		    ,ph);
	 mystrcat(tmp);
      }
   }

   if (CtrLibGetModuleVersion(&tver) == TimLibErrorSUCCESS) {
      t.Second = tver.ModVer[module -1];
      t.TicksHPTDC = 0;
      sprintf(tmp,"\nVHDL Version:%s\n",TmToSt(&t));
      mystrcat(tmp);
   }

   if (ioctl(ctr,CtrDrvrGET_RECEPTION_ERRORS,&rers) >= 0) {
      t.Second = rers.LastReset;
      t.TicksHPTDC = 0;
      if (t.Second < tver.CorVer)
	 sprintf(txd,"Reset:Has never been reset");
      else
	 sprintf(txd,"Reset:UTC[%d]/%s", (int) rers.LastReset, TmToSt(&t));

      sprintf(tmp,"\nReception ErrLog\n"
		  "%s\n"
		  "Parity:%d "
		  "Sync:%d "
		  "CodViol:%d "
		  "Queue:%d "
		  "Total:%d\n"
		  ,txd
		  ,(int) rers.PartityErrs
		  ,(int) rers.SyncErrs
		  ,(int) rers.CodeViolErrs
		  ,(int) rers.QueueErrs
		  ,(int) rers.TotalErrs);
      mystrcat(tmp);
   }

   if (ioctl(ctr,CtrDrvrGET_IO_STATUS,&stat) >= 0) {
      sprintf(tmp,"\nIoStat:Available\n");
      mystrcat(tmp);

      if (stat & CtrDrvrIoStatusCTRXE) {
	 sprintf(tmp,"EnergyExt:Present\n");
	 mystrcat(tmp);
	 bzero((void *) tmp, TMPLN);
      }

      if (stat & CtrDrvrIoStatusCTRXI) {
	 sprintf(tmp,"IoExt:Present\n");
	 mystrcat(tmp);
	 bzero((void *) tmp, TMPLN);
      }

      if (stat & CtrDrvrIoStatusV1_PCB) {
	 sprintf(tmp,"PcbVer:ONE\n");
	 mystrcat(tmp);
	 bzero((void *) tmp, TMPLN);
      }

      if (stat & CtrDrvrIoStatusV2_PCB) {
	 sprintf(tmp,"PcbVer:TWO\n");
	 mystrcat(tmp);
	 bzero((void *) tmp, TMPLN);
      }

      if (stat & CtrDrvrIOStatusIDOkP) {
	 sprintf(tmp,"BoardID:Present\n");
	 mystrcat(tmp);
	 if (ioctl(ctr,CtrDrvrGET_IDENTITY,&brid) >= 0) {
	    if (brid.IdMSL != 0) {
	       if (brid.IdMSL == 0xFFFFFFFF)
		  sprintf(tmp,"BoardID:0xFFFFFFFF:Old PCB\n");
	       else
		  sprintf(tmp,"BoardID:0x%08x%08X\n",(int) brid.IdMSL,(int) brid.IdLSL);
	    }
	    mystrcat(tmp);
	 }
      }

      if (stat & CtrDrvrIOStatusDebugHistory) {
	 sprintf(tmp,"DebugHis:ON\n");
	 mystrcat(tmp);
      }

      if (stat & CtrDrvrIOStatusUtcPllEnabled) {
	 sprintf(tmp,"PllUtc:ON\n");
	 mystrcat(tmp);
      }

      if (stat & CtrDrvrIOStatusTemperatureOk) {
	 tempr = (float) mstat.Temperature / 2.0;
	 sprintf(tmp,"Temperature:%2.1f C\n",tempr);
	 mystrcat(tmp);
      }

      if (stat & CtrDrvrIOStatusExtendedMemory) {
	 sprintf(tmp,"ExtMem:Present\n");
	 if (ioctl(ctr,CtrDrvrGET_MODULE_STATS,&mstat) >= 0) {
	    sprintf(tmp,"PllErrThresh:%d\n",(int) mstat.PllErrorThreshold);
	    mystrcat(tmp);
	    sprintf(tmp,"PllDacLowPass:%d\n",(int) mstat.PllDacLowPassValue);
	    mystrcat(tmp);
	    sprintf(tmp,"PllDacCICConst:%d\n",(int) mstat.PllDacCICConstant);
	    mystrcat(tmp);
	    sprintf(tmp,"PllMonCICConst:%d\n",(int) mstat.PllMonitorCICConstant);
	    mystrcat(tmp);
	    sprintf(tmp,"PhaseDCM:%d\n",(int) mstat.PhaseDCM);
	    mystrcat(tmp);
	    sprintf(tmp,"UtcPllPhaseErr:%d\n",(int) mstat.UtcPllPhaseError);
	    mystrcat(tmp);
	    sprintf(tmp,"MsMissedErrs:%d\n",(int) mstat.MsMissedErrs);
	    mystrcat(tmp);
	    sprintf(tmp,"LastMsMissed:%s\n",TmToSt(&(mstat.LastMsMissed)));
	    mystrcat(tmp);
	    sprintf(tmp,"PllErrs:%d\n",(int) mstat.PllErrors);
	    mystrcat(tmp);
	    sprintf(tmp,"LastPllErr:%s\n",TmToSt(&(mstat.LastPllError)));
	    mystrcat(tmp);
	    sprintf(tmp,"MissedFrms:%d\n",(int) mstat.MissedFrames);
	    mystrcat(tmp);
	    sprintf(tmp,"LastFrmMissed:%s\n",TmToSt(&(mstat.LastFrameMissed)));
	    mystrcat(tmp);
	    sprintf(tmp,"BadRecCycles:%d\n",(int) mstat.BadReceptionCycles);
	    mystrcat(tmp);
	    sprintf(tmp,"RecvFrms:%d\n",(int) mstat.ReceivedFrames);
	    mystrcat(tmp);
	    sprintf(tmp,"SentFrms:%d\n",(int) mstat.SentFramesEvent);
	    mystrcat(tmp);
	    sprintf(tmp,"UtcPllErrs:%d\n",(int) mstat.UtcPllErrs);
	    mystrcat(tmp);
	    sprintf(tmp,"LastExt1Str:%s\n",TmToSt(&(mstat.LastExt1Start)));
	    mystrcat(tmp);
	 }
      }
   }
   return res;
}

/* ==================================================================== */
/* Get Module statistics                                                */

TimLibError CtrLibGetModuleStats(unsigned long module,
				 TimLibModuleStats *stats) {

CtrDrvrBoardId brid;
CtrDrvrReceptionErrors rers;
CtrDrvrPll plb;
float aspn;
unsigned long stat;
CtrDrvrModuleStats mstat;
TimLibTime tlt;

   if (ctr == 0)      return TimLibErrorINIT;
   if (stats == NULL) return TimLibErrorNOMEM;
   if (ioctl(ctr,CtrDrvrSET_MODULE, &module) < 0) return TimLibErrorIO;

   bzero((void *) stats, sizeof(TimLibModuleStats));
   CtrLibGetTime(module, &tlt);

   stats->Module = module;

   if (ioctl(ctr,CtrDrvrGET_PLL,&plb) >= 0) {
      stats->Pll.Valid      = 1;
      stats->Pll.Error      = plb.Error;
      stats->Pll.Integrator = plb.Integrator;
      stats->Pll.Dac        = plb.Dac;
      stats->Pll.LastItLen  = plb.LastItLen;
      stats->Pll.KI         = plb.KI;
      stats->Pll.KP         = plb.KP;
      stats->Pll.NumAverage = plb.NumAverage;
      stats->Pll.Phase      = plb.Phase;

      if (ioctl(ctr,CtrDrvrGET_PLL_ASYNC_PERIOD,&aspn) >= 0) {
	 stats->Pll.AsPrdNs    = aspn;
      }
   }

   if (ioctl(ctr,CtrDrvrGET_RECEPTION_ERRORS,&rers) >= 0) {
      stats->Rec.Valid    = 1;
      stats->Rec.PrtyErrs = rers.PartityErrs;
      stats->Rec.SyncErrs = rers.SyncErrs;
      stats->Rec.CodeErrs = rers.CodeViolErrs;
      stats->Rec.QueuErrs = rers.QueueErrs;
      stats->Rec.TotlErrs = rers.TotalErrs;

      stats->Rec.LastRset.Second  = rers.LastReset;
      stats->Rec.LastRset.Machine = tlt.Machine;
   }

   if (ioctl(ctr,CtrDrvrGET_IO_STATUS,&stat) >= 0) {
      stats->Cst.Valid = 1;
      stats->Cst.Stat  = stat;
      if (stat & CtrDrvrIOStatusIDOkP) {
	 if (ioctl(ctr,CtrDrvrGET_IDENTITY,&brid) >= 0) {
	    stats->Cst.IdMSL = brid.IdMSL;
	    stats->Cst.IdLSL = brid.IdLSL;
	 }
      }

      if (stat & CtrDrvrIOStatusExtendedMemory) {
	 if (ioctl(ctr,CtrDrvrGET_MODULE_STATS,&mstat) >= 0) {
	    stats->Ext.Valid         = 1;
	    stats->Ext.PllErrThresh  = mstat.PllErrorThreshold;
	    stats->Ext.PllDacLowPass = mstat.PllDacLowPassValue;
	    stats->Ext.PllDacCIConst = mstat.PllDacCICConstant;
	    stats->Ext.PllMonCIConst = mstat.PllMonitorCICConstant;
	    stats->Ext.PllPhaseDCM   = mstat.PhaseDCM;
	    stats->Ext.PllUtcPhasErr = mstat.UtcPllPhaseError;
	    stats->Ext.Temperature   = mstat.Temperature;
	    stats->Ext.MsMissed      = mstat.MsMissedErrs;
	    stats->Ext.PllErrCount   = mstat.PllErrors;
	    stats->Ext.FrmMissed     = mstat.MissedFrames;
	    stats->Ext.RecBadCycles  = mstat.BadReceptionCycles;
	    stats->Ext.RecRcvdFrms   = mstat.ReceivedFrames;
	    stats->Ext.RecSentFrms   = mstat.SentFramesEvent;
	    stats->Ext.PllUtcErrs    = mstat.UtcPllErrs;

	    stats->Ext.FrmMissedLast.Second  = mstat.LastFrameMissed.Second;
	    stats->Ext.FrmMissedLast.Nano    = CtrHptdcToNano(mstat.LastFrameMissed.TicksHPTDC);
	    stats->Ext.FrmMissedLast.Machine = tlt.Machine;

	    stats->Ext.PllLastErr.Second     = mstat.LastPllError.Second;
	    stats->Ext.PllLastErr.Nano       = CtrHptdcToNano(mstat.LastPllError.TicksHPTDC);
	    stats->Ext.PllLastErr.Machine    = tlt.Machine;

	    stats->Ext.MsLastErr.Second      = mstat.LastMsMissed.Second;
	    stats->Ext.MsLastErr.Nano        = CtrHptdcToNano(mstat.LastMsMissed.TicksHPTDC);
	    stats->Ext.MsLastErr.Machine     = tlt.Machine;

	    stats->Ext.StartOne.Second       = mstat.LastExt1Start.Second;
	    stats->Ext.StartOne.Nano         = CtrHptdcToNano(mstat.LastExt1Start.TicksHPTDC);
	    stats->Ext.StartOne.Machine      = tlt.Machine;
	 }
      }
   }
   return TimLibErrorSUCCESS;
}

/* ==================================================================== */
/* Control how the PLL locks after synchronization loss                 */

TimLibError CtrLibSetPllLocking(unsigned long module,
				unsigned long lockflag) { /* 1=> Brutal, else Slow */

   if (ctr == 0) return TimLibErrorINIT;
   if (ioctl(ctr,CtrDrvrSET_MODULE, &module) < 0) return TimLibErrorIO;

   if (ioctl(ctr,CtrDrvrSET_BRUTAL_PLL,&lockflag) < 0) return TimLibErrorIO;

   return TimLibErrorSUCCESS;
}
@


1.79
log
@Added routines to connect to C-time and get module for a CTIM
@
text
@d1201 4
a1204 2
   if ((cstat & CtrDrvrStatusNO_BUS_ERROR)
   &&  (cstat & CtrDrvrStatusNO_LOST_INTERRUPTS)) tstat |= TimLibStatusBUS_OK;
@


1.78
log
@*** empty log message ***
@
text
@d215 46
@


1.77
log
@Added hidden routine CtrLibSetCableId
@
text
@d1216 2
a1217 1
TimLibError CtrLibGetIoStatus(TimLibLemo *input) {
d1224 2
d1251 2
a1252 1
TimLibError CtrLibSetOutputs(TimLibLemo output,
d1260 5
a1264 1
   err = CtrLibGetIoStatus(&input);
@


1.76
log
@Added PLL lock control and module stats routines
@
text
@d1119 18
@


1.75
log
@Added extra info
@
text
@d1375 1
a1375 1
CtrDrvrBoardId bird;
d1489 3
a1491 3
	 if (ioctl(ctr,CtrDrvrGET_IDENTITY,&bird) >= 0) {
	    if (bird.IdMSL != 0) {
	       if (bird.IdMSL == 0xFFFFFFFF)
d1494 1
a1494 1
		  sprintf(tmp,"BoardID:0x%08x%08X\n",(int) bird.IdMSL,(int) bird.IdLSL);
d1558 114
@


1.74
log
@Use group value to pass payload when simulating a CTIM
@
text
@d1350 19
a1372 1
#define RESLN 1024
a1373 1
static char res[RESLN];
a1377 1
TimLibError ter;
d1380 1
a1380 1
float aspn;
d1383 2
d1386 1
a1386 4
   if (ctr                                         == 0) return NULL;
   if (ioctl(ctr,CtrDrvrSET_MODULE, &module)        < 0) return NULL;
   if (ioctl(ctr,CtrDrvrGET_PLL,&plb)               < 0) return NULL;
   if (ioctl(ctr,CtrDrvrGET_PLL_ASYNC_PERIOD,&aspn) < 0) return NULL;
d1388 3
d1393 40
a1432 2
   ph = aspn * ((double) (int) plb.Phase / (double) (int) plb.NumAverage);
   er = aspn * ((double) (int) plb.Error / (double) (int) plb.NumAverage);
d1434 5
a1438 36
   sprintf(tmp,"\nPhase Locked Loop Parameters Module:%d\n"
	      "PllError   : 0x%08x %d\n"
	      "Integrator : 0x%08x %d\n"
	      "Dac        : 0x%08x %d\n"
	      "LastItLen  : 0x%08x %d\n"
	      "KI         : 0x%08x %d\n"
	      "KP         : 0x%08x %d\n"
	      "NumAverage : 0x%08x %d\n"
	      "Phase      : 0x%08x %d\n"
	      "AsPrdNs    : %f (ns)\n"
	      "Error*Period/Naverage: %fns\n"
	      "Phase*Period/Naverage: %fns\n"
	      ,(int) module
	      ,(int) plb.Error     ,(int) plb.Error
	      ,(int) plb.Integrator,(int) plb.Integrator
	      ,(int) plb.Dac       ,(int) plb.Dac
	      ,(int) plb.LastItLen ,(int) plb.LastItLen
	      ,(int) plb.KI        ,(int) plb.KI
	      ,(int) plb.KP        ,(int) plb.KP
	      ,(int) plb.NumAverage,(int) plb.NumAverage
	      ,(int) plb.Phase     ,(int) plb.Phase
	      ,aspn
	      ,er
	      ,ph);
   strcat(res,tmp);

   ter = CtrLibGetModuleVersion(&tver);
   if (ter != TimLibErrorSUCCESS)               return res;
   if (tver.CorVer != tver.ModVer[module-1])    return res;

   if (ioctl(ctr,CtrDrvrSET_MODULE, &module) < 0) return res;
   if (ioctl(ctr,CtrDrvrGET_IDENTITY,&bird)  < 0) return res;

   if (bird.IdMSL != 0) {
      if (bird.IdMSL == 0xFFFFFFFF)
	 sprintf(tmp,"\nPcbId : 0xFFFFFFFF: Old style CTR PCB\n");
d1440 16
a1455 1
	 sprintf(tmp,"\nPcbId : 0x%08x%08X\n",(int) bird.IdMSL,(int) bird.IdLSL);
a1456 1
   strcat(res,tmp);
d1458 98
a1555 21
   if (ioctl(ctr,CtrDrvrGET_RECEPTION_ERRORS,&rers) < 0) return res;

   t.Second = rers.LastReset; t.TicksHPTDC = 0;
   if (t.Second < tver.CorVer) sprintf(txd,"Reset : Has never been reset");
   else                        sprintf(txd,"Reset : UTC[%d]/%s",
					   (int) rers.LastReset,
					   TmToSt(&t));
   sprintf(tmp,"\nReception error log\n"
	       "%s\n"
	       "Parity: %d\n"
	       "Sync  : %d\n"
	       "Code  : %d\n"
	       "Queue : %d\n"
	       "Total : %d\n"
	       ,txd
	       ,(int) rers.PartityErrs
	       ,(int) rers.SyncErrs
	       ,(int) rers.CodeViolErrs
	       ,(int) rers.QueueErrs
	       ,(int) rers.TotalErrs);
   strcat(res,tmp);
@


1.73
log
@Better way to do FdInit
@
text
@d768 1
@


1.72
log
@Always do a normal initialization first from FdInit
@
text
@d146 4
a149 8
   if ((device == TimLibDevice_ANY)
   ||  (device == TimLibDevice_CTR)) {
      if (ctr == 0) {
	 er = CtrLibInitialize(device);
	 if (er != TimLibErrorSUCCESS) return 0;
	 return ctr;
      }
      return CtrFdOpen();
d151 1
a151 1
   return 0;
@


1.71
log
@Added Thread support via File Descriptor FD extra parameter
@
text
@d144 2
d148 5
@


1.70
log
@Added specific info status string
@
text
@d45 14
a71 31
/* Adjust CTR time to the same as a CPS-TG8 would give.                 */
/* This adjustment code is needed so that CTR and TG8 time stamps can   */
/* be compared using exact equality. Its easier to change the CTR than  */
/* the Tg8, when the last Tg8 disapears, then this code can be removed  */
/* by setting timlib_real_utc non zero.                                 */

#ifdef CTR_TIME_ADJUST_TG8

#define NS_IN_SEC 1000000000    /* Ns in one second 10^9 */
#define NS_TWO_MS 2000000       /* Ns in two millisecond 2 x 10^6 */

static void CtrTimeAdjustTg8(TimLibTime *ttm) {

unsigned long ins;

   /* 18 July 06 CPS_TG8 Force real UTC time */
   /* No correction needed for CPS_TG8 any longer */

   if (timlib_real_utc) return;

   ins = ttm->Nano + NS_TWO_MS;
   if (ins > NS_IN_SEC) {
      ins -= NS_IN_SEC;              /* then remove 1S from NS */
      ttm->Second++;                 /* and add 1S to UTC */
   }
   ttm->Nano = ins;
}

#endif

/* ==================================================================== */
d140 11
d187 25
d250 14
a282 1

d371 1
d373 53
a425 3
#ifdef CTR_TIME_ADJUST_TG8
      CtrTimeAdjustTg8(onzero);
#endif
d427 27
a460 5

#ifdef CTR_TIME_ADJUST_TG8
      CtrTimeAdjustTg8(trigger);
#endif

a466 5

#ifdef CTR_TIME_ADJUST_TG8
      CtrTimeAdjustTg8(start);
#endif

@


1.69
log
@Added GetModuleVersion
@
text
@d221 1
a221 1
			 unsigned long tmout) {  /* 0=>No time outs       */
d1206 132
@


1.68
log
@DisConnect
@
text
@d1155 51
@


1.67
log
@*** empty log message ***
@
text
@d182 2
a183 1
      ioctl(ctr,CtrDrvrDISCONNECT,&con);
d194 23
@


1.66
log
@Bug, I was overwritint the PLNUM pointer in wait.
@
text
@d293 2
a294 2
      if (iclss != TimLibClassHARDWARE) *machine = TgvTgvToTgmMachine(TgvGetMachineForMember(rbf.Ctim));
      else                              *machine = mch;
@


1.65
log
@Added IO command and corrected bugs
@
text
@d305 1
a305 1
      } else plnum = 0;
@


1.64
log
@Changed IO API to use TimLibLemo IO types
@
text
@d7 1
a7 2
#define CTR_PMC
#define CTR_PCI
d1072 1
a1072 1
CtrDrvrIoStatus iostat;
d1113 2
@


1.63
log
@Added IO routines to CTR lemos
@
text
@d1071 1
a1071 1
TimLibError CtrLibGetIoStatus(CtrDrvrIoStatus *input) {
d1073 3
d1078 1
a1078 1
   if (ioctl(ctr,CtrDrvrGET_IO_STATUS,input) < 0) return TimLibErrorIO;
d1080 1
a1080 1
   if (*input & CtrDrvrIoStatusCTRXI) return TimLibErrorSUCCESS;
d1082 15
d1103 2
a1104 2
TimLibError CtrLibSetOutputs(CtrDrvrIoStatus output,
			     CtrDrvrIoStatus value_mask) {
d1106 1
a1106 1
CtrDrvrIoStatus input;
d1114 1
a1114 1
   for (msk = CtrDrvrIoStatusO1; msk <= CtrDrvrIoStatusO8; msk <<= 1) {
d1116 1
a1116 1
      if (value_mask & msk) {
@


1.62
log
@Removed Time adjustment and FESA 2.6 support
@
text
@d1067 45
@


1.61
log
@End 2006, This is a restore point
@
text
@d65 2
a76 2
/*   timlib_real_utc = 1;  */ /* 18 July 06 CPS_TG8 returns correct time now ! */

d87 2
a271 6
#ifndef FESA2p7
TimLibTime    etm;
unsigned long cytag, ncytag, us, bp;
TgmBeamState  bs;
#endif

a300 15
#ifndef FESA2p7
   if (payload) {
      if (*payload) {
	 etm.Machine = mch;
	 etm.CTrain  = rbf.OnZeroTime.CTrain;
	 etm.Second  = rbf.OnZeroTime.Time.Second;
	 etm.Nano    = CtrHptdcToNano(rbf.OnZeroTime.Time.TicksHPTDC);
	 CtrTimeAdjustTg8(&etm);
	 TimLibGetTgmInfo(etm,NULL,&cytag,&ncytag);
	 TgmDecodeTag(cytag,&bs, (Cardinal *) &us, (Cardinal *) &bp);
	 if (us == *payload) *payload = cytag; else *payload = ncytag;
      }
   }
#endif

d316 2
d319 2
d328 2
d331 2
d339 2
d342 2
@


1.60
log
@Added GetQueueSize
@
text
@d28 3
d40 1
a40 1
      sprintf(fnm,"/dev/ctr.%1d",i);
d72 5
@


1.59
log
@*** empty log message ***
@
text
@d199 20
@


1.58
log
@Important to monitor the LOST_INTERRUPT status
@
text
@d236 1
a236 1
int                cbl;
d262 1
a262 1
   ioctl(ctr,CtrDrvrGET_CABLE_ID,&cbl);
@


1.57
log
@Removed 1S adjustment as CTG hardware bug is corrected
@
text
@d988 3
a990 1
   if (cstat & CtrDrvrStatusNO_BUS_ERROR) tstat |= TimLibStatusBUS_OK;
@


1.56
log
@*** empty log message ***
@
text
@d59 2
a60 1
/* the Tg8, when the last Tg8 disapears, then this code can be removed. */
d69 2
a70 4
   if (timlib_real_utc) {
      ttm->Second++;                 /* and add 1S to UTC */
      return;
   }
@


1.55
log
@Bug in errno handling in CreatePtim corrected
@
text
@d23 1
d68 4
a77 1
   ttm->CTrain++;
@


1.54
log
@Forgot to set the module when reading status
@
text
@d12 3
d922 2
a923 2
   if (cc == EBUSY)  return TimLibErrorEXISTS;
   if (cc == ENOMEM) return TimLibErrorNOMEM;
@


1.53
log
@Added ifdef FESA2p7 to suppress frigging CYTAG payloads
@
text
@d974 2
a975 1
   if (ioctl(ctr,CtrDrvrGET_STATUS,&cstat)) return TimLibErrorIO;
@


1.52
log
@Bug in simulate interrupt corrected
@
text
@d236 1
d240 1
d271 1
d284 1
@


1.51
log
@Frig the payload for the SPS
@
text
@d619 1
a619 2
	 act.TriggerNumber = anum;
	 if (ioctl(ctr,CtrDrvrGET_ACTION,&act) < 0) return TimLibErrorIO;
d621 4
a624 1
	 /* If the Tgm group number is not zero, search for the PTIM action */
a625 14
	 if (grnum) {
	    do {
	       if ((TgvTgvToTgmMachine(trg->Machine) == machine)
	       &&  (trg->Group.GroupNumber           == grnum)
	       &&  (trg->Group.GroupValue            == grval)) break;

	       if (anum++ >= ob.Size) return TimLibErrorGROUP;

	       act.TriggerNumber = anum;
	       if (ioctl(ctr,CtrDrvrGET_ACTION,&act) < 0) return TimLibErrorIO;
	    } while (1);
	 }

	 wbf.TriggerNumber = anum;
@


1.50
log
@*** empty log message ***
@
text
@d236 4
d266 1
d269 13
d299 1
@


1.49
log
@Added logic to set output bytes on CTRV P2 connector
@
text
@d113 1
a113 1
	 fprintf(stdout,"CtrLibInitialize:Execute:%s",cmd);
d128 1
a128 1
	    fprintf(stdout,"CtrLibInitialize:Execute:%s",cmd);
@


1.48
log
@Added GetAllCtims
@
text
@d18 2
d98 1
d100 1
d111 5
a115 2
      if (timlib_jtag) system("echo \"(Xjtag) (load 1) q\" | /usr/local/bin/ctrtest");

d122 11
@


1.47
log
@Loads HPTDC if needed
@
text
@d976 28
a1003 2
      ptimlist[i] = ptimo.Objects[i].EqpNum;
      *psize = i +1;
@


1.46
log
@*** empty log message ***
@
text
@d107 1
a107 1
      if (timlib_jtag) system("echo \"(Xjtag) q\" | /usr/local/bin/ctrtest");
@


1.45
log
@Xjtag take parameters now
@
text
@d107 1
a107 1
      if (timlib_jtag) system("echo (Xjtag) q | /usr/local/bin/ctrtest");
@


1.44
log
@*** empty log message ***
@
text
@d107 1
a107 1
      if (timlib_jtag) system("echo Xjtag q | /usr/local/bin/ctrtest");
@


1.43
log
@Allows JTAG reload checking
@
text
@d17 1
a17 1
extern_int timlib_jtag;
@


1.42
log
@*** empty log message ***
@
text
@d17 1
d68 1
d107 2
d118 1
@


1.41
log
@Set delay on ALL modules
@
text
@d112 2
@


1.40
log
@*** empty log message ***
@
text
@d70 12
d94 1
d105 7
a111 4
      if (timlib_debug)  ioctl(ctr,CtrDrvrSET_SW_DEBUG,   &timlib_debug);
      if (timlib_delay)  ioctl(ctr,CtrDrvrSET_INPUT_DELAY,&timlib_delay);
      if (timlib_enable) ioctl(ctr,CtrDrvrENABLE,         &timlib_enable);

a801 12
/* Lets you know how many installed modules there are on this host.     */

unsigned long CtrLibGetInstalledModuleCount() {

unsigned long cnt;

   if (ctr == 0) return 0;
   if (ioctl(ctr,CtrDrvrGET_MODULE_COUNT,&cnt) < 0) return 0;
   return cnt;
}

/* ==================================================================== */
@


1.39
log
@*** empty log message ***
@
text
@d14 4
@


1.38
log
@Fixed bug in GetAllPtime where size was un initialized.
@
text
@d87 5
a91 1
      ioctl(ctr,CtrDrvrSET_SW_DEBUG,&timlib_debug);
@


1.37
log
@Fixed module setting before retriving action in TimLibWait. Bug corrected.
@
text
@d949 2
@


1.36
log
@Changed the way time is adjusted
@
text
@a189 2
   ioctl(ctr,CtrDrvrSET_MODULE,&module);

d193 1
@


1.35
log
@*** empty log message ***
@
text
@d51 1
a51 1
#define NS_IN_MS  1000000       /* Ns in one millisecond 10^6 */
d55 1
a55 31
int u;
unsigned long ms, ins, cyw;
TgmMachine mch;
double dns;

static unsigned long  init = 0;
static unsigned long  gn  [TgmMACHINES];
static unsigned long  bpw [TgmMACHINES];
static TgmCycleWidths cyws[TgmMACHINES];

   mch = ttm->Machine;

   /* Clear memory on first call */

   if (!init) {
      init = 1;
      bzero((void *) gn, (sizeof(unsigned long) * TgmMACHINES));
   }

   /* This bit only runs once per machine */

   if (!gn[mch]) {
      if (mch == -1) return;
      if (TgmAttach(mch,TgmTELEGRAM) != TgmFAILURE) {
	 if ((bpw[mch] = TgmGetBPWidth())) {
	    if (TgmGetCycleWidths(mch,&(cyws[mch])) != TgmFAILURE) {
	       gn[mch] = TgmGetGroupNumber(mch,"USER");
	    }
	 }
      }
   }
d57 4
a60 32
  /* Add '1' to the CTrain value. In order to handle roll over properly */
  /* I need to know the current cycle width so that I only set C-Zero   */
  /* when, by adding one, we arrive in the next cycle.                  */
  /* We do this because although the trigger time is correct, the next  */
  /* C-Event is the one that interests us, that is the validation time. */

   if (gn[mch]) {
      if (TgmGetGroupValue(mch,TgmCURRENT,0,gn[mch],&u) != TgmFAILURE) {
	 if ((u > 0) && (u <= cyws[mch].Size)) {
	    cyw = cyws[mch].Widths[u -1];
	    if (cyw) {
	       ms = ttm->CTrain + 1;
	       if (ms >= (cyw * bpw[mch])) ms = 0;
	       ttm->CTrain = ms;

	       /* And add 2ms to the UTC time, and round down to the milli-second */
	       /* The Tg8 time is wrong by 2ms, so I will add 2 here. */
	       /* This has to be done in float because of values like 200999950ns */

	       ins = ttm->Nano;                  /* Unsigned long ns */
	       dns = ((double) ins) / NS_IN_MS;  /* So now its 200.999.. ms */
	       ins = (unsigned long) round(dns); /* Now its 201 integer */
	       ins += 2;                         /* And now 203 integer */
	       ins = ins * NS_IN_MS;             /* And then 203 * 10^6 ns */
	       if (ins >= NS_IN_SEC) {           /* If its bigger than 1S */
		  ins -= NS_IN_SEC;              /* then remove 1S from NS */
		  ttm->Second++;                 /* and add 1S to UTC */
	       }
	       ttm->Nano = ins;
	    }
	 }
      }
d62 1
d231 1
d245 1
@


1.34
log
@*** empty log message ***
@
text
@d783 1
a783 1
   utc->Machine = (TgmMachine) cbl;
@


1.33
log
@Forced check in
@
text
@d259 3
a261 14
  // ioctl(ctr,CtrDrvrGET_CABLE_ID,&cbl);
  // mch = TgvTgvToTgmMachine(TgvFirstMachineForCableId(cbl));
   @@@@@@
   @@@@  JC and IOAN are working
   @@@@
   switch (rbf.Connection.EqpClass) {
   	case TimLibClassCTIM :
	break;
	case TimLibClassPTIM :
	break;
	case TimLibClassHARDWARE:
	  mch=-1;
   }
   
d266 4
a269 1
   if (machine) *machine = mch;
@


1.32
log
@*** empty log message ***
@
text
@a247 2
   ioctl(ctr,CtrDrvrGET_CABLE_ID,&cbl);
   mch = TgvTgvToTgmMachine(TgvFirstMachineForCableId(cbl));
d258 15
a272 1

@


1.31
log
@Works correctly
@
text
@d364 2
a365 2
	       if (ccv->Enable) cnf->OnZero |= CtrDrvrCounterOnZeroOUT;
	       else             cnf->OnZero &= ~CtrDrvrCounterOnZeroOUT;
d526 3
a528 2
   if (cnf->OnZero & CtrDrvrCounterOnZeroOUT) ccv->Enable = 1;
   else                                       ccv->Enable = 0;
d678 6
a683 1
      if (ccvm & TimLibCcvMaskENABLE) cnf->OnZero    = ccv->Enable;
d737 4
a740 1
      *ccvm |= TimLibCcvMaskENABLE; ccv->Enable    = cnf->OnZero;
@


1.30
log
@Added plnum to Get
Added GetAllPtimObjects
Added GetStatus
Bug module not set corrected
@
text
@d77 1
d342 1
a342 1
      if (anum >= ob.StartIndex + ob.Size) return TimLibErrorGROUP;
d411 10
d510 1
a510 1
      if (anum >= ob.StartIndex + ob.Size) return TimLibErrorGROUP;
d538 2
a539 1
   ccv->GrNum     = grp->GroupNumber;
d677 1
a677 4
      if (ccvm & TimLibCcvMaskENABLE) {
	 if (ccv->Enable) cnf->OnZero |=  CtrDrvrCounterOnZeroOUT;
	 else             cnf->OnZero &= ~CtrDrvrCounterOnZeroOUT;
      }
d682 1
d697 49
@


1.29
log
@*** empty log message ***
@
text
@d899 46
@


1.28
log
@*** empty log message ***
@
text
@d340 5
a344 1
      if (ioctl(ctr,CtrDrvrGET_ACTION,&act) < 0) return TimLibErrorGROUP;
d463 1
d495 9
a503 1
   if (grnum) {
@


1.27
log
@Ignore interrupte from PTIM equipments that have no output
@
text
@d143 1
d311 1
a311 1
int                          anum, msk, i, found;
d327 3
d464 1
a464 1
int                          anum;
d478 3
@


1.26
log
@Added time correction so that CTR trigger times correspond
to the TG8 triggers time. Hence time stamps can be compared
between the two systems exactly.
@
text
@d12 2
d239 1
d249 9
a257 1
   if (read(ctr,&rbf,sizeof(CtrDrvrReadBuf)) <= 0) return TimLibErrorTIMEOUT;
@


1.25
log
@*** empty log message ***
@
text
@d48 3
d54 1
a54 1
unsigned long ms, ns, cyw;
d56 1
d58 2
a59 1
static unsigned long  gn  [TgmMACHINES] = {0,0,0,0,0,0,0,0};
d65 7
d87 2
d100 2
d103 8
a110 6
	       ns = ttm->Nano / 1000000;
	       ns += 2;
	       ns *= 1000000;
	       if (ns >= 1000000000) {
		  ns -= 1000000000;
		  ttm->Second++;
d112 1
a112 1
	       ttm->Nano = ns;
@


1.24
log
@*** empty log message ***
@
text
@d43 59
d219 1
d224 4
d234 1
a234 1
   if (machine) *machine = TgvTgvToTgmMachine(TgvMACHINE_HEADER(rbf.Frame.Struct.Header));
a247 3
   ioctl(ctr,CtrDrvrSET_MODULE,&module);
   ioctl(ctr,CtrDrvrGET_CABLE_ID,&cbl);

d249 1
a249 1
      onzero->Machine = TgvTgvToTgmMachine(TgvFirstMachineForCableId(cbl));
d255 1
a255 1
      trigger->Machine = TgvTgvToTgmMachine(TgvFirstMachineForCableId(cbl));
d259 1
d262 1
a262 1
      start->Machine = TgvTgvToTgmMachine(TgvFirstMachineForCableId(cbl));
@


1.23
log
@*** empty log message ***
@
text
@d188 1
a188 1
      onzero->Machine = (TgmMachine) cbl;
d194 1
a194 1
      trigger->Machine = (TgmMachine) cbl;
d200 1
a200 1
      start->Machine = (TgmMachine) cbl;
@


1.22
log
@*** empty log message ***
@
text
@d645 1
a645 1
      TgmSetGroupValueInTelegram(i+1,(long) tgmb.Telegram[i], (TgmTelegram *) &telegram);
@


1.21
log
@*** empty log message ***
@
text
@d773 15
@


1.20
log
@Added module parameter to Remote routine
@
text
@d143 13
a155 13
TimLibError CtrLibWait(TimLibClass    *iclss,   /* Class of interrupt */
		       unsigned long  *equip,   /* PTIM CTIM or hardware mask */
		       unsigned long  *plnum,   /* Ptim line number 1..n or 0 */
		       TimLibHardware *source,  /* Hardware source of interrupt */
		       TimLibTime     *onzero,  /* Time of interrupt/output */
		       TimLibTime     *trigger, /* Time of counters load */
		       TimLibTime     *start,   /* Time of counters start */
		       unsigned long  *ctim,    /* CTIM trigger equipment ID */
		       unsigned long  *payload, /* Payload of trigger event */
		       unsigned long  *module,  /* Module that interrupted */
		       unsigned long  *missed,  /* Number of missed interrupts */
		       unsigned long  *qsize,   /* Remaining interrupts on queue */
		       TgmMachine     *mch) {   /* Corresponding TgmMachine */
d166 5
a170 6
   if (iclss)   *iclss  = rbf.Connection.EqpClass;
   if (equip)   *equip  = rbf.Connection.EqpNum;
   if (source)  *source = rbf.InterruptNumber;
   if (module)  *module = rbf.Connection.Module;
   if (mch)     *mch    = TgvTgvToTgmMachine(TgvMACHINE_HEADER(rbf.Frame.Struct.Header));

a212 1
		      TgmMachine    machine, /* Telegram identifier */
a213 1
		      unsigned long ctim,    /* If plnum is not zero this is the ctim trigger */
d244 2
a245 26

      if (grnum) {
	 if (TgmGetGroupDescriptor(machine,grnum,&desc) != TgmSUCCESS) return TimLibErrorPTIM;
	 if (desc.Type != TgmBIT_PATTERN)
	    trg->TriggerCondition = CtrDrvrTriggerConditionEQUALITY;
	 else
	    trg->TriggerCondition = CtrDrvrTriggerConditionAND;
      } else trg->TriggerCondition = CtrDrvrTriggerConditionNO_CHECK;

      found = 0;
      if (ioctl(ctr,CtrDrvrLIST_CTIM_OBJECTS,&ctimo) < 0) return TimLibErrorIO;
      for (i=0; i<ctimo.Size; i++) {
	 if (ctimo.Objects[i].EqpNum == ctim) {
	    trg->Ctim  = ctim;
	    trg->Frame = ctimo.Objects[i].Frame;
	    found = 1;
	    break;
	 }
      }
      if (!found) return TimLibErrorCTIM;

      trg->Machine     = TgvTgmToTgvMachine(machine);
      trg->Counter     = ob.Counter;
      grp->GroupNumber = grnum;
      grp->GroupValue  = grval;

d248 2
a249 3
	 if ((TgvTgvToTgmMachine(trg->Machine) == machine)
	 &&  (trg->Group.GroupNumber           == grnum)
	 &&  (trg->Group.GroupValue            == grval)) break;
d257 2
d308 40
a363 1
		      TgmMachine    machine,
d394 2
a395 3
	 if ((TgvTgvToTgmMachine(trg->Machine) == machine)
	 &&  (trg->Group.GroupNumber           == grnum)
	 &&  (trg->Group.GroupValue            == grval)) break;
d413 5
d630 1
a630 1
			      TgmTelegram   *telegram) {
d645 1
a645 1
      TgmSetGroupValueInTelegram(i+1,(long) tgmb.Telegram[i], telegram);
@


1.19
log
@*** empty log message ***
@
text
@d185 1
a185 1
   ioctl(ctr,CtrDrvrSET_MODULE,module);
d506 5
a510 4
				 unsigned long cntr,   /* 1..8 counter number */
				 TimLibRemote  rcmd,   /* Command */
				 TimLibCcvMask ccvm,   /* Fields to be set */
				 TimLibCcv     *ccv) { /* Value to load in counter */
d519 2
@


1.18
log
@*** empty log message ***
@
text
@d402 1
@


1.17
log
@*** empty log message ***
@
text
@d248 7
a254 5
      if (TgmGetGroupDescriptor(machine,grnum,&desc) != TgmSUCCESS) return TimLibErrorPTIM;
      if (desc.Type != TgmBIT_PATTERN)
	 trg->TriggerCondition = CtrDrvrTriggerConditionEQUALITY;
      else
	 trg->TriggerCondition = CtrDrvrTriggerConditionAND;
@


1.16
log
@*** empty log message ***
@
text
@d242 1
@


1.15
log
@*** empty log message ***
@
text
@d276 1
a276 1
	 if (anum++ >= ob.Size) return TimLibErrorGROUP;
d347 5
a351 5
		       TgmMachine    machine,
		       unsigned long grnum,
		       unsigned long grval,
		       TimLibCcvMask *ccvm,  /* Valid fields in ccv */
		       TimLibCcv     *ccv) {
d382 1
a382 1
	 if (anum++ >= ob.Size) return TimLibErrorGROUP;
@


1.14
log
@*** empty log message ***
@
text
@d58 1
a58 1
      if (ctr) {
@


1.13
log
@*** empty log message ***
@
text
@d56 9
a64 4
   if (ctr) return TimLibErrorSUCCESS;
   if (CtrOpen() == 0) {
      ctr = 0;
      return TimLibErrorOPEN;
d66 1
a66 7

   /* Do loads of initialization stuff here */

   /* Check VHDL version, and reload if needed */
   /* Load CTIM and PTIM definitions */

   return TimLibErrorSUCCESS;
@


1.12
log
@*** empty log message ***
@
text
@a238 1
   act.TriggerNumber = anum;
d266 5
a270 4
      trg->Machine           = machine;
      trg->Counter           = ob.Counter;
      trg->Group.GroupNumber = grnum;
      trg->Group.GroupValue  = grval;
d338 1
@


1.11
log
@*** empty log message ***
@
text
@d214 8
a221 6
TimLibError CtrLibSet(unsigned long  ptim,    /* PTIM to write to */
		       TgmMachine    machine, /* Telegram identifier */
		       unsigned long grnum,   /* Tgm group number or Zero */
		       unsigned long grval,   /* Group value if num not zero */
		       TimLibCcvMask ccvm,    /* Which values to write */
		       TimLibCcv     *ccv) {  /* Current control value */
d223 1
a223 1
int                          anum, msk;
d230 2
d246 2
a247 1
   /* If the Tgm group number is not zero, search for the PTIM action */
d249 23
a271 1
   if (grnum) {
d282 1
a282 2
   } else if (grval) anum += (grval -1);

@


1.10
log
@*** empty log message ***
@
text
@d485 1
d510 6
a515 2
   if (ccvm & TimLibCcvMaskOMASK) {
      if (ioctl(ctr,CtrDrvrSET_OUT_MASK,&(ccv->OutputMask)) < 0) return TimLibErrorIO;
d517 1
d646 1
a646 1
   if (ioctl(ctr,CtrDrvrLIST_CTIM_OBJECTS,&ctimo) < 0) return TimLibErrorPTIM;
@


1.9
log
@Added Create PTIM and CTIM entries
Added Polarity
@
text
@d10 1
d255 1
a255 1
   }
d375 2
a376 2
   ccv->OutputMask = cnf->Mask;
   ccv->Polarity   = cnf->Polarity;
a565 3
#define GET_TGM 1495
int TimLibClient = 0;

a580 4
#if 0
   if (TimLibClient != GET_TGM) return TimLibErrorBLOCKED;
#endif

d587 1
d672 1
a672 1
TimLibError CtrLibCreatePtimObject(unsigned long ptim, /* PTIM equipment number */
d676 17
a692 1
   return TimLibErrorNOT_IMP;
d699 1
a699 1
TimLibError CtrLibCreateCtimObject(unsigned long ctim, /* CTIM equipment number */
d701 15
a715 1
   return TimLibErrorNOT_IMP;
@


1.8
log
@*** empty log message ***
@
text
@d213 1
a213 1
TimLibError CtrLibSet(unsigned long ptim,    /* PTIM to write to */
d226 1
d292 11
a302 1
	       if (ioctl(ctr,CtrDrvrSET_OUT_MASK,&(ccv->OutputMask)) < 0) return TimLibErrorIO;
d332 1
d371 5
a375 1
   if (ioctl(ctr,CtrDrvrGET_OUT_MASK,&(ccv->OutputMask)) < 0) return TimLibErrorIO;
d671 20
@


1.7
log
@HPTDC Ticks to Nano Seconds conversion added.
@
text
@d567 1
d569 1
@


1.6
log
@*** empty log message ***
@
text
@d33 1
a33 1
float fns;
@


1.5
log
@*** empty log message ***
@
text
@d33 1
a33 1
double fns;
@


1.4
log
@I added a Hptdc to Nano routine. The old conversion was crap.
@
text
@d93 4
d549 3
d566 2
@


1.3
log
@*** empty log message ***
@
text
@d30 12
d82 2
a83 2
			   unsigned long equip,    /* Equipment or hardware mask */
			   unsigned long module) { /* For HARD or CTIM classes */
d140 12
a151 11
			unsigned long  *equip,   /* PTIM CTIM or hardware mask */
			unsigned long  *plnum,   /* Ptim line number 1..n or 0 */
			TimLibHardware *source,  /* Hardware source of interrupt */
			TimLibTime     *onzero,  /* Time of interrupt/output */
			TimLibTime     *trigger, /* Time of counters load */
			TimLibTime     *start,   /* Time of counters start */
			unsigned long  *ctim,    /* CTIM trigger equipment ID */
			unsigned long  *payload, /* Payload of trigger event */
			unsigned long  *module,  /* Module that interrupted */
			unsigned long  *missed,  /* Number of missed interrupts */
			unsigned long  *qsize) { /* Remaining interrupts on queue */
d166 1
d185 1
a185 1
      onzero->Machine = TgvTgvToTgmMachine(cbl);
d188 1
a188 1
      onzero->Nano    = (rbf.OnZeroTime.Time.TicksHPTDC>>5)*25;
d191 4
a194 4
      trigger->Machine   = TgvTgvToTgmMachine(cbl);
      trigger->CTrain    = rbf.TriggerTime.CTrain;
      trigger->Second    = rbf.TriggerTime.Time.Second;
      trigger->Nano      = (rbf.TriggerTime.Time.TicksHPTDC>>5)*25;
d197 4
a200 4
      start->Machine  = TgvTgvToTgmMachine(cbl);
      start->CTrain   = rbf.StartTime.CTrain;
      start->Second   = rbf.StartTime.Time.Second;
      start->Nano     = (rbf.StartTime.Time.TicksHPTDC>>5)*25;
d523 1
a523 1
   utc->Machine = TgvTgvToTgmMachine(cbl);
d526 1
a526 1
   utc->Nano    = (t->TicksHPTDC>>5)*25;
@


1.2
log
@*** empty log message ***
@
text
@d7 2
@


1.1
log
@Initial revision
@
text
@d522 1
a522 2
/* unsigned long grval = TgmGetGroupValueFromTelegram(TgmMachine    machine,   */
/*                                                    unsigned long grnum,     */
d536 2
a537 2
			       TgmMachine    machine,
			       TgmTelegram   *telegram) {
a540 1
unsigned short *sp;
a547 1
   sp = (unsigned short *) telegram;
d549 3
a551 2
   for (i=0; i<TgmLastGroupNumber(machine); i++) {
      sp[i] = (unsigned short) tgmb.Telegram[i];
@
