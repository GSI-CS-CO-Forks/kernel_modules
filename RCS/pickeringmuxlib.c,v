head	1.9;
access;
symbols
	VersionKernel2-4:1.7;
locks; strict;
comment	@ * @;


1.9
date	2006.03.21.15.06.57;	author sdeghaye;	state Exp;
branches;
next	1.8;

1.8
date	2005.06.29.07.51.25;	author sdeghaye;	state Exp;
branches;
next	1.7;

1.7
date	2005.06.08.07.47.42;	author sdeghaye;	state Exp;
branches;
next	1.6;

1.6
date	2005.02.15.16.49.52;	author ygeorgie;	state Exp;
branches;
next	1.5;

1.5
date	2005.02.15.14.08.38;	author ygeorgie;	state Exp;
branches;
next	1.4;

1.4
date	2004.10.13.06.37.38;	author sdeghaye;	state Exp;
branches;
next	1.3;

1.3
date	2004.03.22.13.47.41;	author sdeghaye;	state Released;
branches;
next	1.2;

1.2
date	2004.03.16.14.10.27;	author sdeghaye;	state Released;
branches;
next	1.1;

1.1
date	2004.03.09.13.00.03;	author sdeghaye;	state Exp;
branches;
next	;


desc
@User library for the Pickering Mux Driver
@


1.9
log
@Add a function for the attenuator
@
text
@static char *rcsid(){return "$Id: pickeringmuxlib.c,v 1.8 2005/06/29 07:51:25 sdeghaye Exp $";}

#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#include <sys/types.h>
#include <sys/ioctl.h>
#include <sys/stat.h>
#include <fcntl.h>
#include "pickeringmuxdrv.h"
#include "pickeringmuxlib.h"
#include "pciioconfig/crateconfig.h"

typedef struct
{
  int fd;
  int maxInput;
  int maxOutput;
} MuxHandle;

static MuxHandle muxHanlde[MAX_SLOT];

/***************************************************************************************************
 *
 */
static MuxHandle * checkMuxHandle(int aSlot)
{
  int fd;
  
  if(aSlot > MAX_SLOT)
  {
    return NULL;
  }
  
  if(muxHanlde[aSlot].fd == 0)
  {
    char buf[50];
    int bus;
    int device;
    int rc;
    
    rc = getPCIPosition(aSlot, &bus, &device);
    if(rc != 0)
    {
      return NULL;
    }
    
    sprintf(buf, PICKERINGMUX_PATH_TEMPLATE, bus, device);
    fd = open(buf, O_RDWR);
    if(fd == -1)
    {
      return NULL;
    }
    muxHanlde[aSlot].fd = fd;
    
    /* Get the ranges */
    if(ioctl(fd, PICKERINGMUX_MAXINPUT, &muxHanlde[aSlot].maxInput) != 0)
    {
      perror("pickeringmuxlib ioctl(PICKERINGMUX_MAXINPUT)");
      return NULL;
    }
    
    if(ioctl(fd, PICKERINGMUX_MAXOUTPUT, &muxHanlde[aSlot].maxOutput) != 0)
    {
      perror("pickeringmuxlib ioctl(PICKERINGMUX_MAXOUTPUT)");
      return NULL;
    }
  }
  return &muxHanlde[aSlot];
}

/***************************************************************************************************
 *
 */
int pickeringMuxConnect(int aSlot, int anInput, int anOutput)
{
  MuxHandle *muxHandle;
  PickeringMuxConnectData connectData;
  int rc;
  
  muxHandle = checkMuxHandle(aSlot);
  if(muxHandle == NULL)
  {
    return PICKERINGMUX_NO_SUCH_MUX;
  }
  
  if(anInput > muxHandle->maxInput || anOutput > muxHandle->maxOutput)
  {
    return PICKERINGMUX_BAD_PARAMETER;
  }
 
  connectData.input = anInput;
  connectData.output = anOutput;
  
  rc = ioctl(muxHandle->fd, PICKERINGMUX_CONNECT, &connectData);
  if(rc != 0)
  {
    return rc;
  }
  return 0;
}

/***************************************************************************************************
 *
 */
int pickeringMuxDisconnect(int aSlot, int anOutput)
{
  MuxHandle *muxHandle;
  int rc;
  
  muxHandle = checkMuxHandle(aSlot);
  if(muxHandle == NULL)
  {
    return PICKERINGMUX_NO_SUCH_MUX;
  }
  
  if(anOutput > muxHandle->maxOutput)
  {
    return PICKERINGMUX_BAD_PARAMETER;
  }
  
  rc = ioctl(muxHandle->fd, PICKERINGMUX_DISCONNECT, &anOutput);
  if(rc != 0)
  {
    return rc;
  }
  return 0;
}
    
/***************************************************************************************************
 *
 */
int pickeringMuxReset(int aSlot)
{
  
  MuxHandle *muxHandle;
  int rc;
  
  muxHandle = checkMuxHandle(aSlot);
  if(muxHandle == NULL)
  {
    return PICKERINGMUX_NO_SUCH_MUX;
  }
  
  rc = ioctl(muxHandle->fd, PICKERINGMUX_RESET, NULL);
  if(rc != 0)
  {
    return rc;
  }
  return 0;
}

/*-----------------------------------------------------------------------------
 * FUNCTION:    pickeringMuxWidth.
 * DESCRIPTION: Returns the width of the hardware module, installed in
 *		slot 'aSlot'. Module width can be up to 2 slots. 
 * RETURNS:	module width             - if succeed.
 *		PICKERINGMUX_NO_SUCH_MUX - if slot is empty.
 *    PICKERINGMUX_SYSTEM_ERROR - if the driver returns an error.
 *-----------------------------------------------------------------------------
 */
int
pickeringMuxWidth(
		  int aSlot)	/* slot number to check */
{
  MuxHandle *muxHandle;
  int rc, width;
  
  muxHandle = checkMuxHandle(aSlot);

  if (muxHandle == NULL)
    return(PICKERINGMUX_NO_SUCH_MUX); /* error */
  
  rc = ioctl(muxHandle->fd, PICKERINGMUX_WIDTH, &width);
  if (rc != 0)
    return(PICKERINGMUX_SYSTEM_ERROR);			/* internal error */
  
  return(width);
}


/***************************************************************************************************
 *
 */
int pickeringMuxMaxOutput(int aSlot)
{
  MuxHandle *muxHandle = checkMuxHandle(aSlot);
  if(muxHandle == NULL)
  {
    return PICKERINGMUX_NO_SUCH_MUX;
  }
  return muxHandle->maxOutput;
}
    
/***************************************************************************************************
 *
 */
int pickeringMuxMaxInput(int aSlot)
{
  MuxHandle *muxHandle = checkMuxHandle(aSlot);
  if(muxHandle == NULL)
  {
    return PICKERINGMUX_NO_SUCH_MUX;
  }
  return muxHandle->maxInput;
}
    
/***************************************************************************************************
 *
 */
int pickeringMuxOuputStatus(int aSlot, const int *outputs)
{
  MuxHandle *muxHandle;
  int rc;
  
  muxHandle = checkMuxHandle(aSlot);
  if(muxHandle == NULL)
  {
    return PICKERINGMUX_NO_SUCH_MUX;
  }

  rc = ioctl(muxHandle->fd, PICKERINGMUX_STATUS, outputs);
  if(rc != 0)
  {
    return rc;
  }
  return 0;
}

/***************************************************************************************************
 *
 */
int  pickeringAttn(int aSlot, int aChannel, int anAttn)
{
  MuxHandle *muxHandle;
  PickeringAttnData data;
  int rc;
  
  muxHandle = checkMuxHandle(aSlot);
  if(muxHandle == NULL)
  {
    return PICKERINGMUX_NO_SUCH_MUX;
  }
  
  data.channel = aChannel;
  data.attn = anAttn;
  
  rc = ioctl(muxHandle->fd, PICKERING_SET_ATTN, &data);
  if(rc != 0)
  {
    return rc;
  }
  return 0;
}

/***************************************************************************************************
 *
 */
void pickeringMuxPrintError(char *aMessage, int anError)
{
  switch(anError)
  {
  case PICKERINGMUX_BAD_PARAMETER:
    printf("%s: %s\n", aMessage, PICKERINGMUX_BAD_PARAMETER_STRING);
    break;
  case PICKERINGMUX_NO_SUCH_MUX:
    printf("%s: %s\n", aMessage, PICKERINGMUX_NO_SUCH_MUX_STRING);
    break;
  case PICKERINGMUX_SYSTEM_ERROR:
    perror(aMessage);
    break;
  default:
    printf("%s: pickeringmuxlib: No such error code (%d)\n", aMessage, anError);
    break;
  } 
}
@


1.8
log
@Use the new PATH template
Return the error code PICKERINGMUX_SYSTEM_ERROR in case of problem in the getWidth function
@
text
@d1 1
a1 1
static char *rcsid(){return "$Id: pickeringmuxlib.c,v 1.7 2005/06/08 07:47:42 sdeghaye Exp sdeghaye $";}
d233 26
@


1.7
log
@Change the direction of a test
@
text
@d1 1
a1 1
static char *rcsid(){return "$Id: pickeringmuxlib.c,v 1.6 2005/02/15 16:49:52 ygeorgie Exp sdeghaye $";}
d48 1
a48 1
    sprintf(buf, "/dev/%s/%s%d-%d", PICKERINGMUX_DIR_NAME, PICKERINGMUX_FILE_NAME, bus, device);
d159 1
a159 1
 *		0			 - in case of 'ioctl' failure.
d176 1
a176 1
    return(0);			/* internal error */
@


1.6
log
@MESSAGE: Add 'const' qualifier to library function
@
text
@d1 1
a1 1
static char *rcsid(){return "$Id: pickeringmuxlib.c,v 1.5 2005/02/15 14:08:38 ygeorgie Exp ygeorgie $";}
d175 1
a175 1
  if (!rc)
@


1.5
log
@MESSAGE: Now it's possible to obtain module width
@
text
@d1 1
a1 1
static char *rcsid(){return "$Id: pickeringmuxlib.c,v 1.4 2004/10/13 06:37:38 sdeghaye Exp ygeorgie $";}
d211 1
a211 1
int pickeringMuxOuputStatus(int aSlot, int *outputs)
@


1.4
log
@Use the pciioconfig lib to find the name of the handle.
@
text
@d1 1
a1 1
static char *rcsid(){return "$Id: pickeringmuxlib.c,v 1.3 2004/03/22 13:47:41 sdeghaye Released sdeghaye $";}
d152 29
@


1.3
log
@Add a forgotten check in the getMin/Max functions after the checkMuxHandle call
@
text
@d1 1
a1 1
static char *rcsid(){return "$Id: pickeringmuxlib.c,v 1.3 2004/03/22 13:26:27 sdeghaye Released sdeghaye $";}
d12 1
d38 11
a48 2
  
    sprintf(buf, "/dev/%s/%s%d", PICKERINGMUX_DIR_NAME, PICKERINGMUX_FILE_NAME, aSlot);
@


1.2
log
@Driver & Library with support for the Pickering modules 4-1, 9-8 and 16-16.
First working version.
@
text
@d1 1
a1 1
static char *rcsid(){return "$Id: pickeringmuxlib.c,v 1.1 2004/03/09 13:00:03 sdeghaye Exp $";}
d148 6
a153 1
  return checkMuxHandle(aSlot)->maxOutput;
d161 6
a166 1
  return checkMuxHandle(aSlot)->maxInput;
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
static char *rcsid(){return "$Id: prfmuxlib.c,v 1.2 2004/03/08 10:42:33 sdeghaye Exp $";}
d7 1
d13 6
a18 1
#define MAX_SLOT 32
d20 1
a20 1
static int fd[MAX_SLOT];
d25 1
a25 1
static int checkFileDescr(int aSlot)
d27 8
a34 1
  if(fd[aSlot] == 0)
d39 9
a47 2
    fd[aSlot] = open(buf, O_RDWR);
    if(fd[aSlot] == 0)
d49 2
a50 1
      return PICKERINGMUX_SYSTEM_ERROR;
d52 2
a53 1
    else
d55 2
a56 1
      return fd[aSlot];
d59 14
a72 1
  else
d74 1
a74 1
    return fd[aSlot];
d76 15
d96 1
a96 1
int pickeringMuxConnect(int aSlot, int anInput, int anOutput)
d98 1
a98 1
  int muxFd;
a99 1
  char buf[5];
d101 7
a107 1
  if(anInput > /* ioctl */4 || anOutput > /* ioctl */1 || aSlot > MAX_SLOT)
d111 3
a113 1
  else
d115 24
a138 12
    muxFd = checkFileDescr(aSlot);
    if(muxFd == PICKERINGMUX_SYSTEM_ERROR)
    {
      return PICKERINGMUX_NO_SUCH_MUX;
    }
    sprintf(buf, "%d", anInput);
    rc = write(muxFd, buf, 1);
    if(rc == PICKERINGMUX_SYSTEM_ERROR)
    {
      return rc;
    }
    return 0;
d140 1
d146 9
a154 1
int pickeringMuxOuputStatus(int aSlot, int anOutput)
d156 9
a164 1
  int muxFd;
a165 1
  char buf[5];
d167 2
a168 1
  if(anOutput > /* ioctl */1 || aSlot > MAX_SLOT)
d170 1
a170 1
    return PICKERINGMUX_BAD_PARAMETER;
d172 3
a174 1
  else
d176 1
a176 11
    muxFd = checkFileDescr(aSlot);
    if(muxFd == PICKERINGMUX_SYSTEM_ERROR)
    {
      return PICKERINGMUX_NO_SUCH_MUX;
    }
    rc = read(muxFd, buf, 1);
    if(rc == PICKERINGMUX_SYSTEM_ERROR)
    {
      sscanf(buf, "%d", &rc);
    }
    return 0;
d178 1
d198 1
a198 1
    printf("%s: prfmuxlib: No such error code (%d)\n", aMessage, anError);
@
