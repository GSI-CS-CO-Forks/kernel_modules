head	1.4;
access;
symbols
	VersionKernel2-4:1.3;
locks; strict;
comment	@ * @;


1.4
date	2005.06.29.07.53.20;	author sdeghaye;	state Exp;
branches;
next	1.3;

1.3
date	2004.10.13.06.36.06;	author sdeghaye;	state Exp;
branches;
next	1.2;

1.2
date	2004.03.16.14.10.27;	author sdeghaye;	state Released;
branches;
next	1.1;

1.1
date	2004.03.09.13.00.03;	author sdeghaye;	state Exp;
branches;
next	;


desc
@Specific part for the 4 to 1 mux
@


1.4
log
@Use variable instead of function in the RCS id
@
text
@static char *rcsid = "$Id: pickering4to1.c,v 1.3 2004/10/13 06:36:06 sdeghaye Exp sdeghaye $";

#include <asm/uaccess.h>
#include "pickering4to1.h"

#define INPUT1_CMD 0x9
#define INPUT2_CMD 0x1
#define INPUT3_CMD 0x4
#define INPUT4_CMD 0x0
#define PICK_MUX_4_TO_1_MAX_OUTPUT 1
#define PICK_MUX_4_TO_1_MAX_INPUT 4

/***************************************************************************************************
 *
 */
int pickMux4to1Probe(struct pci_dev *pcidev, PickeringMuxDescr *muxDesc)
{      
  if(pcidev->subsystem_device != PICK_MUX_4_TO_1_SUBSYSTEM_ID)
  {
    printk(KERN_ERR "pickMux4to1Probe: Unsupported subdevice id (0x%X)\n", pcidev->subsystem_device);
    return -1;
  }
  
  /* LAS0 memory address space is region 2 (BAR2) */
  muxDesc->las0addr = pci_resource_start(pcidev, 2);
  muxDesc->las0len = pci_resource_len(pcidev, 2);
  printk(KERN_INFO "pickMux4to1Probe: LAS0 @@ 0x%lx, size=%d\n", muxDesc->las0addr
                                                              , muxDesc->las0len);
  if (!request_mem_region(muxDesc->las0addr, muxDesc->las0len, "pickeringmux4to1"))
  {
    /* nothing to free*/      
    printk(KERN_CRIT "pickMux4to1Probe: Unable to request LAS0 @@ 0x%lx, size=%d\n"
                                                               , muxDesc->las0addr
                                                               , muxDesc->las0len);
    return -1;
  }
  muxDesc->las0 = ioremap(muxDesc->las0addr, muxDesc->las0len);
  printk(KERN_INFO "pickMux4to1Probe: LAS0 remap @@ 0x%lx (%p), size=%d\n", muxDesc->las0addr
                                                                         , muxDesc->las0
                                                                         , muxDesc->las0len);

  /* LAS1 memory address space is region 3 (BAR3) */
  muxDesc->las1addr = pci_resource_start(pcidev, 3);
  muxDesc->las1len = pci_resource_len(pcidev, 3);
  printk(KERN_INFO "pickMux4to1Probe: LAS1 @@ 0x%lx, size=%d\n", muxDesc->las1addr
                                                              , muxDesc->las1len);
  if (!request_mem_region(muxDesc->las1addr, muxDesc->las1len, "pickeringmux4to1"))
  {
    iounmap(muxDesc->las0);
    release_mem_region(muxDesc->las0addr, muxDesc->las0len);
    printk(KERN_CRIT "pickMux4to1Probe: Unable to request LAS1 @@ 0x%lx, size=%d\n"
                                                               , muxDesc->las1addr
                                                               , muxDesc->las1len);
    return -1;
  }
  muxDesc->las1 = ioremap(muxDesc->las1addr, muxDesc->las1len);
  printk(KERN_INFO "pickMux4to1Probe: LAS1 remap @@ 0x%lx (%p), size=%d\n", muxDesc->las1addr
                                                                         , muxDesc->las1
                                                                         , muxDesc->las1len);

  /* Allocate space to store output status */
  muxDesc->inputs = (int *)kmalloc(sizeof(int) * PICK_MUX_4_TO_1_MAX_OUTPUT, GFP_KERNEL);
  if(muxDesc->inputs == NULL)
  {
    printk(KERN_CRIT "pickMux4to1Probe: Unable to allocate memory\n");
    return -1;
  }
  memset(muxDesc->inputs, 0, sizeof(int) * PICK_MUX_4_TO_1_MAX_OUTPUT);
  
  /* Init the hardware and the status */
  pickMux4to1Reset(muxDesc);
  
  return 0;
}

/***************************************************************************************************
 *
 */
void pickMux4to1Remove(PickeringMuxDescr *muxDesc)
{
  printk(KERN_INFO "pickMux4to1Remove: Removing device in bus-device: \"%d-%d\"\n", muxDesc->bus, muxDesc->device);
  if(muxDesc->type != PICK_MUX_4_TO_1_SUBSYSTEM_ID)
  {
    printk(KERN_ERR "pickMux4to1Remove: Unsupported subdevice id (0x%X)\n", muxDesc->type);
    return;
  }
  
  /* Release reserved resources */
  iounmap(muxDesc->las0);
  release_mem_region(muxDesc->las0addr, muxDesc->las0len);
  iounmap(muxDesc->las1);
  release_mem_region(muxDesc->las1addr, muxDesc->las1len);
  kfree(muxDesc->inputs);  
}

/***************************************************************************************************
 *
 */
int pickMux4to1MaxOutput(PickeringMuxDescr *muxDesc, int *maxOutput)
{
  *maxOutput = PICK_MUX_4_TO_1_MAX_OUTPUT;
  return 0;
}

/***************************************************************************************************
 *
 */
int pickMux4to1MaxInput(PickeringMuxDescr *muxDesc, int *maxInput)
{
  *maxInput = PICK_MUX_4_TO_1_MAX_INPUT;
  return 0;
}

/***************************************************************************************************
 *
 */
int pickMux4to1Connect(PickeringMuxDescr *muxDesc, PickeringMuxConnectData data)
{  
  if(muxDesc->type != PICK_MUX_4_TO_1_SUBSYSTEM_ID)
  {
    printk(KERN_ERR "pickMux4to1Connect: Unsupported subdevice id (0x%X)\n", muxDesc->type);
    return -1;
  }
  
  switch(data.input)
  {
  case 1:
    *(int *)muxDesc->las1 = INPUT1_CMD;
    printk(KERN_DEBUG "pickMux4to1Connect: write %d @@ 0x%p\n",INPUT1_CMD, muxDesc->las1);
    break;
  case 2:
    *(int *)muxDesc->las1 = INPUT2_CMD;
    printk(KERN_DEBUG "pickMux4to1Connect: write %d @@ 0x%p\n", INPUT2_CMD, muxDesc->las1);
    break;
  case 3:
    *(int *)muxDesc->las1 = INPUT3_CMD;
    printk(KERN_DEBUG "pickMux4to1Connect: write %d @@ 0x%p\n", INPUT3_CMD, muxDesc->las1);
    break;
  case 4:
    *(int *)muxDesc->las1 = INPUT4_CMD;
    printk(KERN_DEBUG "pickMux4to1Connect: write %d @@ 0x%p\n", INPUT4_CMD, muxDesc->las1);
    break;
  default:
    printk(KERN_ERR "pickMux4to1Connect: write: Unknown input %d\n", data.input);
    return -1;
  }
  muxDesc->inputs[0] = data.input;
  return 0;
}

/***************************************************************************************************
 *
 */
int pickMux4to1Disconnect(PickeringMuxDescr *muxDesc, int output)
{
  if(muxDesc->type != PICK_MUX_4_TO_1_SUBSYSTEM_ID)
  {
    printk(KERN_ERR "pickMux4to1Disconnect: Unsupported subdevice id (0x%X)\n", muxDesc->type);
    return -1;
  }
  
  *(int *)muxDesc->las1 = INPUT4_CMD;
  printk(KERN_DEBUG "pickMux4to1Disconnect: write %d @@ 0x%p\n", INPUT4_CMD, muxDesc->las1);
  muxDesc->inputs[0] = 4;
  return 0;
}

/***************************************************************************************************
 *
 */
int pickMux4to1Reset(PickeringMuxDescr *muxDesc)
{
  return pickMux4to1Disconnect(muxDesc, 1);
}

/***************************************************************************************************
 *
 */
int pickMux4to1Status(PickeringMuxDescr *muxDesc, int *status)
{
  int rc;
  int size;
  
  size = sizeof(int)*PICK_MUX_4_TO_1_MAX_OUTPUT;
  rc = copy_to_user(status, muxDesc->inputs, size);
  if(rc != 0)
  {
    printk(KERN_ERR "pickMux4to1Status: copy not done correctly from %p to %p, size = %d, rc = %d.\n"
                                                                          , muxDesc->inputs
                                                                          , status
                                                                          , size
                                                                          , rc);
    return rc;
  }
  return rc; 
}
@


1.3
log
@Use the new structure based on PCI bus/slot instead of physical slot.
@
text
@d1 1
a1 1
static char *rcsid(){return "$Id: pickering4to1.c,v 1.2 2004/03/16 14:10:27 sdeghaye Released sdeghaye $";}
@


1.2
log
@Driver & Library with support for the Pickering modules 4-1, 9-8 and 16-16.
First working version.
@
text
@d1 1
a1 1
static char *rcsid(){return "$Id: pickering4to1.c,v 1.1 2004/03/09 13:00:03 sdeghaye Exp sdeghaye $";}
d81 1
a81 1
  printk(KERN_INFO "pickMux4to1Remove: Removing device in slot: \"%d\"\n", muxDesc->slot);
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
static char *rcsid(){return "$Id: prfmuxdriver.c,v 1.3 2003/05/12 15:32:52 sdeghaye Exp sdeghaye $";}
d3 1
d32 1
a32 1
    printk(KERN_ERR "pickMux4to1Probe: Unable to request LAS0 @@ 0x%lx, size=%d\n"
d51 1
a51 1
    printk(KERN_ERR "pickMux4to1Probe: Unable to request LAS1 @@ 0x%lx, size=%d\n"
d62 1
a62 1
  muxDesc->inputs = (int *)kmalloc(pickMux4to1MaxOutput(), GFP_KERNEL);
d65 1
a65 1
    printk(KERN_ERR "pickMux4to1Probe: Unable to allocate memory\n");
d68 1
d71 1
a71 2
  *(int *)muxDesc->las1 = INPUT4_CMD;
/* Should call write*/*(muxDesc->inputs) = 4; /* At reset, the input 4 is connected to the output*/
d99 1
a99 1
int pickMux4to1Read(struct file *file, char *buffer, size_t count, loff_t* ppos)
d101 2
a102 18
  /*
  PrfmuxDescr *prfmux;
  
  if(muxDesc->type != PICK_MUX_4_TO_1_SUBSYSTEM_ID)
  {
    printk(KERN_ERR "pickMux4to1Read: Unsupported subdevice id (0x%X)\n", muxDesc->type);
    return -1;
  }
  
  prfmux = file->private_data;
  if(prfmux == NULL)
  {
    printk(KERN_ERR "prfmux: read: No private data (device descriptor) in the file handle\n");
    return -1;
  }
  sprintf(buffer, "%d", prfmux->input);
  */
  return 1;
d108 1
a108 1
int pickMux4to1Write(struct file *file, const char *buffer, size_t count, loff_t* ppos)
d110 9
a118 4
  /*
  PrfmuxDescr *prfmux;
  int anInput;
  
d121 1
a121 8
    printk(KERN_ERR "pickMux4to1Write: Unsupported subdevice id (0x%X)\n", muxDesc->type);
    return -1;
  }
  
  prfmux = file->private_data;
  if(prfmux == NULL)
  {
    printk(KERN_ERR "prfmux: write: No private data (device descriptor) in the file handle\n");
d125 1
a125 2
  sscanf(buffer, "%d", &anInput); 
  switch(anInput)
d128 2
a129 2
    *(int *)prfmux->las1 = INPUT1_CMD;
    printk(KERN_INFO "prfmux: write %d @@ 0x%p\n",INPUT1_CMD, prfmux->las1);
d132 2
a133 2
    *(int *)prfmux->las1 = INPUT2_CMD;
    printk(KERN_INFO "prfmux: write %d @@ 0x%p\n", INPUT2_CMD, prfmux->las1);
d136 2
a137 2
    *(int *)prfmux->las1 = INPUT3_CMD;
    printk(KERN_INFO "prfmux: write %d @@ 0x%p\n", INPUT3_CMD, prfmux->las1);
d140 2
a141 2
    *(int *)prfmux->las1 = INPUT4_CMD;
    printk(KERN_INFO "prfmux: write %d @@ 0x%p\n", INPUT4_CMD, prfmux->las1);
d144 1
a144 1
    printk(KERN_ERR "prfmux: write: Unknown input %d\n", anInput);
d147 2
a148 3
  prfmux->input = anInput;
  */
  return 1;
d154 1
a154 1
int pickMux4to1MaxOutput()
d156 10
a165 1
  return PICK_MUX_4_TO_1_MAX_OUTPUT;
d171 1
a171 1
int pickMux4to1MaxInput()
d173 23
a195 1
  return PICK_MUX_4_TO_1_MAX_INPUT;
@
