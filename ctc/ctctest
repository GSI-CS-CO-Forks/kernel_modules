#!   /usr/bin/env	python
#    coding: utf8
#    vim: tabstop=8 expandtab shiftwidth=4 softtabstop=4

from ctypes import *
from subprocess import Popen
import shlex
import sys
import os
import os.path
import re
import cmd
import struct
import csv
import errno

class ctc_cfg_reg_t(Structure):
    _fields_ = [
        ('ext_start',	c_int),
        ('clk1',	c_int),
        ('clk2',	c_int),
        ('mode',	c_int),
        ('direction',	c_int),
    ]

progpath      = os.path.realpath(sys.argv[0])
basepath      = os.path.dirname(progpath)
libctcpath    = os.path.join(basepath, 'libctc.so')

libc = CDLL('libc.so.6')
lctc = CDLL(libctcpath)
# encore = CDLL(libencorepath)

data_width_format = {
    32 : 'I',
    16 : 'H',
     8 : 'B',
}

wordsize_to_data_width = {
    'char'  :  8,
    'short' : 16,
    'long'  : 32,
}

class TestProgram(cmd.Cmd):

    def __init__(self):
        cmd.Cmd.__init__(self)
        self.fd = None
        self.lun = 0
        self.device = None
        self.devname = None
        self.fname = None
        self.regdata = None

        self.do_q    = self.do_quit
        self.do_exit = self.do_quit
        self.do_h    = self.do_help

    def emptyline(self):
        return

    def do_quit(self, arg):
        return 1

    def do_EOF(self, arg):
        print
        return 1

    def do_shell(self, arg):
        """open a subshell"""
        if arg:
            args = shlex.split(arg)
        else:
            args = 'sh'
        try:
            p = Popen(args)
            p.wait()
        except OSError:
            print 'error: cannot execute', arg
    do_sh = do_shell

    def do_cd(self, arg):
        if not arg:
            print os.getcwd()
            return
        try:
            os.chdir(arg)
        except OSError:
            print 'error: cannot chdir to', arg

    def do_open(self, arg):
        """open LUN"""

        try:
            lun = int(arg)
        except ValueError, e:
            print 'invalid lun argument: ', e.args[0]
            return
        self.fd = lctc.ctc_open(lun)
        if self.fd < 0:
            print 'cannot open CTC number', lun
            return
        self.device = 'CTC'
        self.devname = '/dev/ctc.%d' % lun
        self.lun = lun
        self.prompt = 'ctc:%d> ' % self.lun

    def do_close(self, arg):
        """close currently open file descriptor"""
        if self.fd > 0:
            lctc.close(self.fd)
        self.h = None
        self.fd = None
        self.prompt = 'ctc> '

    def do_version(self, arg):
        """get hardware version"""
        version = c_int(0)
        lctc.ctc_get_hw_version(self.fd, byref(version))
        print('0x%x' % version.value)

    def do_channel_status(self, arg):
        """display channel status"""

        status = c_uint(0)
        try:
            if not arg:
                channel = range(1, 9)
            else:
                channel = map(int, arg.split())
        except ValueError, e:
            print 'invalid arguments: ', e.args[0]
            return
        for ch in channel:
            cc = lctc.ctc_chan_get_status(self.fd, ch, byref(status))
            if cc < 0:
                print 'could not get status for lun:ch %d:%d' % (
                    self.lun, ch)
                return
            print 'ch%d: %d'  % (ch, status.value),
            if status.value == 1:
                print ' enabled'
            else:
                print ' disabled'
            
    def do_set_ext_start(self, arg):
        """set_input channel [1-8] ext_start [1-40]"""

        if arg == '':
            self.do_help('set_ext_start')
            return
        try:
            ch, ext_start = map(int, arg.split())
        except ValueError, e:
            print 'invalid arguments: ', e.args[0]
            return
        cc = lctc.ctc_chan_set_ext_start(self.fd, ch, ext_start);
        print cc
    do_set_input = do_set_ext_start

    def do_set_clock(self, arg):
        """set_clock clock [1-2] channel [1-8] ext_clock [1-6]"""

        if arg == '':
            self.do_help('set_clock')
            return
        try:
            clock, channel, ext_clock = map(int, arg.split())
            if not clock in range(1, 3):
                raise ValueError('bad clock number')
            if not channel in range(1,9):
                raise ValueError('bad channel number')
            if not ext_clock in range(1, 7):
                raise ValueError('bad external clock number')
        except ValueError, e:
            print 'invalid arguments:', e.args[0]
            return
        if clock == 1:
            ret = lctc.ctc_chan_set_clk_counter1(self.fd, channel, ext_clock)
        else:
            ret = lctc.ctc_chan_set_clk_counter2(self.fd, channel, ext_clock)
        if ret:
            print ret
            print 'could not set clock %d for channel %d to %d' % (
                clock, channel, ext_clock)
            return

    def do_set_delay_counter(self, arg):
        """set_delay_counter clock [1-2] channel [1-8] ticks"""

        if arg == '':
            self.do_help('set_delay_counter')
            return
        try:
            clock, channel, ticks = map(lambda x: int(x, 0), arg.split())
            if not clock in range(1, 3):
                raise ValueError('bad clock number')
            if not channel in range(1,9):
                raise ValueError('bad channel number')
        except ValueError, e:
            print 'invalid arguments:', e.args[0]
            return
        if clock == 1:
            ret = lctc.ctc_chan_set_delay_counter1(self.fd, channel, ticks)
        else:
            ret = lctc.ctc_chan_set_delay_counter2(self.fd, channel, ticks)
        if ret:
            print ret
            print 'could not set clock %d for channel %d to %d' % (
                clock, channel, ticks)
            return

    def do_enable(self, arg):
        """enable given channels, or all if no args given"""

        try:
            if not arg:
                channels = range(1,9)
            else:
                channels = map(int, arg.split())
        except ValueError, e:
            print 'invalid arguments:', e.args[0]
            return

        for channel in channels:
            ret = lctc.ctc_chan_enable(self.fd, channel)
            if ret:
                print 'could not enable channel', channel
                continue

    def do_disable(self, arg):
        """disable given channels, or all if no args given"""

        try:
            if not arg:
                channels = range(1,9)
            else:
                channels = map(int, arg.split())
        except ValueError, e:
            print 'invalid arguments:', e.args[0]
            return

        for channel in channels:
            ret = lctc.ctc_chan_disable(self.fd, channel)
            if ret:
                print 'could not disable channel', channel
                continue

    def do_reset(self, arg):
        """reset module"""
        lctc.ctc_reset(self.fd)

    def do_show_channel(self, arg):
        """show complete info about a channel"""

        ch = int(arg)

        status = c_int(0)
        ext_start = c_int(0)
        clk_counter1 = c_int(0)
        clk_counter2 = c_int(0)
        delay_counter1 = c_int(0)
        delay_counter2 = c_int(0)
        output_counter = c_int(0)
        cur_val_counter1 = c_int(0)
        cur_val_counter2 = c_int(0)

        lctc.ctc_chan_get_status(self.fd, ch, byref(status));
        lctc.ctc_chan_get_ext_start(self.fd, ch, byref(ext_start));
        lctc.ctc_chan_get_clk_counter1(self.fd, ch, byref(clk_counter1));
        lctc.ctc_chan_get_clk_counter2(self.fd, ch, byref(clk_counter2));
        lctc.ctc_chan_get_delay_counter1(self.fd, ch, byref(delay_counter1));
        lctc.ctc_chan_get_delay_counter2(self.fd, ch, byref(delay_counter2));
        lctc.ctc_chan_get_output_counter(self.fd, ch, byref(output_counter));
        lctc.ctc_chan_get_cur_val_counter1(self.fd, ch, byref(cur_val_counter1));
        lctc.ctc_chan_get_cur_val_counter2(self.fd, ch, byref(cur_val_counter2));

        print """lun %d channel %d:
        status:    %d
        ext_start: %d clk1:%d clk2:%d
        delay1:    %10d/0x%08x
        delay2:    %10d/0x%08x
        output:    %10d/0x%08x
        current1:  %10d/0x%08x
        current2:  %10d/0x%08x""" % (
            self.lun, ch,
            status.value,
            ext_start.value, clk_counter1.value, clk_counter2.value,
            delay_counter1.value, delay_counter1.value, 
            delay_counter2.value, delay_counter2.value, 
            output_counter.value, output_counter.value,
            cur_val_counter1.value, cur_val_counter1.value, 
            cur_val_counter2.value, cur_val_counter2.value,  )

if __name__ == '__main__':
    tp = TestProgram()
    tp.prompt = 'ctc> '
    if len(sys.argv) > 1:
        try:
            lun = int(sys.argv[1])
            tp.do_open(lun)
        except:
            print 'usage: %s [LUN]' % sys.argv[0]
    tp.cmdloop()

"""
int ctc_open(int lun);
int ctc_close(int fd);
void ctc_reset(int fd);
int ctc_get_hw_version(int fd, int *hw_version);
int ctc_chan_get_status(int fd, int chan, int *status);
int ctc_chan_enable(int fd, int chan);
int ctc_chan_disable(int fd, int chan);
int ctc_chan_set_ext_start(int fd, int chan, int ext_start);
int ctc_chan_get_ext_start(int fd, int chan, int *ext_start);
int ctc_chan_set_clk_counter1(int fd, int chan, int clk);
int ctc_chan_get_clk_counter1(int fd, int chan, int *clk);
int ctc_chan_set_clk_counter2(int fd, int chan, int clk);
int ctc_chan_get_clk_counter2(int fd, int chan, int *clk);
  \param mode		variable to indicate the mode used. Please use enum ctc_mode values.
  \param direction	variable to indicate the direction used. Please use enum ctc_mode values.
int ctc_chan_set_mode(int fd, int chan, int mode, int direction);
int ctc_chan_get_mode(int fd, int chan, int *mode, int *direction);
int ctc_chan_set_delay_counter1(int fd, int chan, int delay);
int ctc_chan_get_delay_counter1(int fd, int chan, int *delay);
int ctc_chan_set_delay_counter2(int fd, int chan, int delay);
int ctc_chan_get_delay_counter2(int fd, int chan, int *delay);
int ctc_chan_get_output_counter(int fd, int chan, int *value);
int ctc_chan_get_cur_val_counter1(int fd, int chan, int *value);
int ctc_chan_get_cur_val_counter2(int fd, int chan, int *value);
"""
