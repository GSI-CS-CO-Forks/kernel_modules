#!   /usr/bin/env	python
#    coding: utf8
#    vim: tabstop=8 expandtab shiftwidth=4 softtabstop=4

from ctypes import *
from subprocess import Popen
import shlex
import sys
import os
import os.path
import re
import cmd
import struct
import csv

class ctc_cfg_reg_t(Structure):
    _fields_ = [
        ('ext_start',	c_int),
        ('clk1',	c_int),
        ('clk2',	c_int),
        ('mode',	c_int),
        ('direction',	c_int),
    ]

progpath      = os.path.realpath(sys.argv[0])
basepath      = os.path.dirname(progpath)
libctcpath    = os.path.join(basepath, 'libctc.so')

libc = CDLL('libc.so.6')
lctc = CDLL(libctcpath)
# encore = CDLL(libencorepath)

data_width_format = {
    32 : 'I',
    16 : 'H',
     8 : 'B',
}

wordsize_to_data_width = {
    'char'  :  8,
    'short' : 16,
    'long'  : 32,
}

class TestProgram(cmd.Cmd):

    def __init__(self):
        cmd.Cmd.__init__(self)
        self.fd = None
        self.lun = 0
        self.device = None
        self.devname = None
        self.fname = None
        self.regdata = None

        self.do_q    = self.do_quit
        self.do_exit = self.do_quit
        self.do_h    = self.do_help

    def emptyline(self):
        return

    def do_quit(self, arg):
        return 1

    def do_EOF(self, arg):
        print
        return 1

    def do_shell(self, arg):
        """open a subshell"""
        if arg:
            args = shlex.split(arg)
        else:
            args = 'sh'
        try:
            p = Popen(args)
            p.wait()
        except OSError:
            print 'error: cannot execute', arg
    do_sh = do_shell

    def do_cd(self, arg):
        if not arg:
            print os.getcwd()
            return
        try:
            os.chdir(arg)
        except OSError:
            print 'error: cannot chdir to', arg

    def do_open(self, arg):
        """open LUN"""

        try:
            lun = int(arg)
        except ValueError, e:
            print 'invalid lun argument: ', e.args[0]
            return
        self.fd = lctc.ctc_open(lun)
        if not self.fd:
            print 'cannot open CTC number', lun
            return
        self.fd = self.h.contents.fd
        self.device = 'CTC'
        self.devname = '/dev/ctc.%d' % lun
        self.lun = lun
        self.prompt = 'ctc:%d> ' % self.lun

    def do_close(self, arg):
        """close currently open file descriptor"""
        if self.fd > 0:
            lctc.close(self.fd)
        self.h = None
        self.fd = None
        self.prompt = 'ctc> '

    def do_version(self, arg):
        """get hardware version"""
        version = 0
        lctc.ctc_get_hw_version(self.fd, byref(version))
        print('0x%x' % version)

    def do_channel_status(self, arg):
        """FIXME: I stopped here"""
        status = 0
        lctc.ctc_chan_get_status(self.fd, byref(status))
        try:
            if not arg:
                channel = range(1, 9)
            else:
                channel = map(int, arg.split())
        except ValueError, e:
            print 'invalid arguments: ', e.args[0]
            return
    def do_display(self, arg):
        pass

    def do_set_input(self, arg):
        """set_input channel ext_start"""

        try:
            channel, ext_start = map(int, arg.split())
        except ValueError, e:
            print 'invalid arguments: ', e.args[0]
            return
        lctc.ctc_setInputChan(self.h, channel, ext_start)

    def do_get_channel_config(self, arg):
        """get_channel_config [channel...]"""

        try:
            channels = arg.split()
            if len(channels) == 0:
                channels = range(1,9)
            else:
                channels = map(int, channels)
        except ValueError, e:
            print 'invalid arguments: ', e.args[0]
            return

        for channel in channels:
            conf = lctc.ctc_getChanConf(self.h, channel)
            if not conf:
                print 'could not get channel %d config' % channel
            conf = cast(conf, POINTER(ctc_cfg_reg_t))
            print 'ch%d:' % channel,
            print 'ext_start %d' % conf.contents.ext_start,
            print 'clk1 %d' % conf.contents.clk1,
            print 'clk2 %d' % conf.contents.clk2,
            print 'mode %d' % conf.contents.mode,
            print 'direction %d' % conf.contents.direction,
            print

    def do_get_clocks(self, arg):
        """get_clocks channel"""

        try:
            channels = arg.split()
            if len(channels) == 0:
                channels = range(1,9)
            else:
                channels = map(int, channels)
        except ValueError, e:
            print 'invalid arguments: ', e.args[0]
            return
        clk1 = c_int(-1)
        clk2 = c_int(-1)
        for channel in channels:
            ret1 = lctc.ctc_getClock1(self.h, channel, byref(clk1))
            ret2 = lctc.ctc_getClock2(self.h, channel, byref(clk2))
            if ret1 or ret2:
                print 'invalid channel', channel
                continue
            print 'ch%d' % channel,
            print 'clk1: %d' % clk1.value,
            print 'clk2: %d' % clk2.value

    def do_set_clock(self, arg):
        """set_clock clock [1-2] channel [1-40] ext_clock [1-6]"""

        try:
            clock, channel, ext_clock = map(int, arg.split())
            if not clock in range(1, 3):
                raise ValueError('bad clock number')
            if not channel in range(1,9):
                raise ValueError('bad channel number')
            if not ext_clock in range(1, 7):
                raise ValueError('bad external clock number')
        except ValueError, e:
            print 'invalid arguments:', e.args[0]
            return
        if clock == 1:
            ret = lctc.ctc_setClock1(self.h, channel, ext_clock)
        else:
            ret = lctc.ctc_setClock2(self.h, channel, ext_clock)
        if ret:
            print ret
            print 'could not set clock %d for channel %d to %d' % (
                clock, channel, ext_clock)
            return

    def do_get_clock_ticks(self, arg):
        """get_clock_ticks channel"""

        try:
            if not arg:
                channels = range(1, 9)
            else:
                channels = map(int, arg.split())
        except ValueError, e:
            print 'invalid arguments:', e.args[0]
            return

        clk1 = c_int(-1)
        clk2 = c_int(-1)
        for channel in channels:
            ret1 = lctc.ctc_getClock1Tick(self.h, channel, byref(clk1))
            ret2 = lctc.ctc_getClock2Tick(self.h, channel, byref(clk2))
            if ret1 or ret2:
                print 'invalid channel', channel
                continue
            print 'ch%d:' % channel,
            print 'clk1ticks: %6d' % clk1.value,
            print 'clk2ticks: %6d' % clk2.value

    def do_set_clock_ticks(self, arg):
        """set_clock clock [1-2] channel [1-8] ticks"""

        try:
            clock, channel, ticks = map(lambda x: int(x, 0), arg.split())
            if not clock in range(1, 3):
                raise ValueError('bad clock number')
            if not channel in range(1,9):
                raise ValueError('bad channel number')
        except ValueError, e:
            print 'invalid arguments:', e.args[0]
            return
        if clock == 1:
            ret = lctc.ctc_setClock1Tick(self.h, channel, ticks)
        else:
            ret = lctc.ctc_setClock2Tick(self.h, channel, ticks)
        if ret:
            print ret
            print 'could not set clock %d for channel %d to %d' % (
                clock, channel, ext_clock)
            return

    def do_get_output_counter(self, arg):
        """get_output_counter channel"""

        try:
            if not arg:
                channels = range(1,9)
            else:
                channels = map(int, arg.split())
        except ValueError, e:
            print 'invalid arguments:', e.args[0]
            return

        for channel in channels:
            counter = c_uint(-1)
            ret = lctc.ctc_getOutPutCounter(self.h, channel, counter)
            if ret:
                print 'could not get counter'
                return
            print 'ch%d:' % channel,
            print 'counter 0x%08x (%d)' % (counter.value, counter.value)

    def do_version(self, arg):
        version = c_uint(-1)
        ret = lctc.ctc_getModuleStatus(self.h, byref(version))
        print 'version: 0x%x' % version.value

    def do_get_counters(self, arg):

        try:
            if not arg:
                channels = range(1,9)
            else:
                channels = map(int, arg.split())
        except ValueError, e:
            print 'invalid arguments:', e.args[0]
            return
        for channel in channels:
            cntr1 = c_uint(-1)
            cntr2 = c_uint(-1)
            ret1 = lctc.ctc_getCntr1CurVal(self.h, channel, byref(cntr1)) 
            ret2 = lctc.ctc_getCntr2CurVal(self.h, channel, byref(cntr2)) 
            if ret1 or ret2:
                print 'could not get counters for channel', channel
                continue
            print 'ch%d:' % channel,
            print 'counter1: 0x%08x (%d),' % (cntr1.value,cntr1.value),
            print 'counter2: 0x%08x (%d),' % (cntr2.value,cntr2.value)

    def do_enable(self, arg):

        try:
            if not arg:
                channels = range(1,9)
            else:
                channels = map(int, arg.split())
        except ValueError, e:
            print 'invalid arguments:', e.args[0]
            return

        for channel in channels:
            ret = lctc.ctc_enableChannel(self.h, channel)
            if ret:
                print 'could not enable channel', channel
                continue

    def do_disable(self, arg):

        try:
            if not arg:
                channels = range(1,9)
            else:
                channels = map(int, arg.split())
        except ValueError, e:
            print 'invalid arguments:', e.args[0]
            return

        for channel in channels:
            ret = lctc.ctc_disableChannel(self.h, channel)
            if ret:
                print 'could not disable channel', channel
                continue

    def do_get_channel_status(self, arg):

        status = (8 * c_int)()
        ret = lctc.ctc_getChannelStatus(self.h, status)
        if ret:
            print 'could not get channel status'
            return
        for channel in range(1,9):
            print 'channel %d:' % channel, 
            s = status[channel-1] 
            print s or 'disabled'

    def do_reset(self, arg):
        """reset module"""
        lctc.ctc_reset(self.fd)
        

if __name__ == '__main__':
    tp = TestProgram()
    tp.prompt = 'ctc> '
    if len(sys.argv) > 1:
        try:
            lun = int(sys.argv[1])
            tp.do_open(lun)
        except:
            print 'usage: %s [LUN]' % sys.argv[0]
    tp.cmdloop()

"""
int ctc_open(int lun);
int ctc_close(int fd);
void ctc_reset(int fd);
int ctc_get_hw_version(int fd, int *hw_version);
int ctc_chan_get_status(int fd, int chan, int *status);
int ctc_chan_enable(int fd, int chan);
int ctc_chan_disable(int fd, int chan);
int ctc_chan_set_ext_start(int fd, int chan, int ext_start);
int ctc_chan_get_ext_start(int fd, int chan, int *ext_start);
int ctc_chan_set_clk_counter1(int fd, int chan, int clk);
int ctc_chan_get_clk_counter1(int fd, int chan, int *clk);
int ctc_chan_set_clk_counter2(int fd, int chan, int clk);
int ctc_chan_get_clk_counter2(int fd, int chan, int *clk);
  \param mode		variable to indicate the mode used. Please use enum ctc_mode values.
  \param direction	variable to indicate the direction used. Please use enum ctc_mode values.
int ctc_chan_set_mode(int fd, int chan, int mode, int direction);
int ctc_chan_get_mode(int fd, int chan, int *mode, int *direction);
int ctc_chan_set_delay_counter1(int fd, int chan, int delay);
int ctc_chan_get_delay_counter1(int fd, int chan, int *delay);
int ctc_chan_set_delay_counter2(int fd, int chan, int delay);
int ctc_chan_get_delay_counter2(int fd, int chan, int *delay);
int ctc_chan_get_output_counter(int fd, int chan, int *value);
int ctc_chan_get_cur_val_counter1(int fd, int chan, int *value);
int ctc_chan_get_cur_val_counter2(int fd, int chan, int *value);
"""
